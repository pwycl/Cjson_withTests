        -:    0:Source:/mnt/d/CLionProjects/Cjson_withTests/Google_tests/ConverterTests.cpp
        -:    0:Graph:ConverterTests.cpp.gcno
        -:    0:Data:ConverterTests.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "gtest/gtest.h"
        -:    2:#include "cJSON.h"
        -:    3:#include "../Cjson_lib/cJSON.c"
        -:    4:
        -:    5:static cJSON item[1];
       23:    6:void reset(cJSON *item) {
       23:    7:    if ((item != NULL) && (item->child != NULL))
        -:    8:    {
       12:    9:        cJSON_Delete(item->child);
        -:   10:    }
       23:   11:    if ((item->valuestring != NULL) && !(item->type & cJSON_IsReference))
        -:   12:    {
    #####:   13:        global_hooks.deallocate(item->valuestring);
        -:   14:    }
       23:   15:    if ((item->string != NULL) && !(item->type & cJSON_StringIsConst))
        -:   16:    {
    #####:   17:        global_hooks.deallocate(item->string);
        -:   18:    }
        -:   19:
       23:   20:    memset(item, 0, sizeof(cJSON));
       23:   21:}
        -:   22:
        -:   23:
        -:   24:class CjsonFixture : public ::testing::Test {
        -:   25:
        -:   26:protected:
        -:   27:    virtual void SetUp()
        -:   28:    {
        -:   29:        memset(item, 0, sizeof(cJSON));
        -:   30://        gregDate = new GregorianDate();
        -:   31://        julDate = new JulianDate();
        -:   32:    }
        -:   33:
        -:   34:    virtual void TearDown() {
        -:   35://        delete gregDate;
        -:   36://        delete julDate;
        -:   37:        reset(item);
        -:   38:    }
        -:   39:
        -:   40://    GregorianDate * gregDate;
        -:   41://    JulianDate * julDate;
        -:   42:};
        -:   43:
        2:   44:static void assert_not_in_list(cJSON *object_item){
        2:   45:    ASSERT_TRUE(object_item->next==NULL);
        2:   46:    ASSERT_TRUE(object_item->prev==NULL);
        -:   47:}
        2:   48:static void assert_has_type(cJSON *object_item, int expect_type){    //判断类型
        2:   49:    ASSERT_TRUE((0xff & (object_item->type))==(0xff & expect_type));
        -:   50:}
        2:   51:static void assert_has_no_reference(cJSON *object_item){
        2:   52:    ASSERT_TRUE((cJSON_IsReference & (object_item->type))==(cJSON_IsReference & 0));
        -:   53:}
        2:   54:static void assert_has_no_const_string(cJSON *object_item){
        2:   55:    ASSERT_TRUE((cJSON_StringIsConst & (object_item->type))==(cJSON_StringIsConst & 0));
        -:   56:}
        2:   57:static void assert_is_object(cJSON *object_item)
        -:   58:{
        -:   59://    TEST_ASSERT_NOT_NULL_MESSAGE(object_item, "Item is NULL.");
        2:   60:    ASSERT_TRUE(object_item!=NULL);
        -:   61:
        2:   62:    assert_not_in_list(object_item);
        2:   63:    assert_has_type(object_item, cJSON_Object);
        2:   64:    assert_has_no_reference(object_item);
        2:   65:    assert_has_no_const_string(object_item);
        -:   66://    assert_has_no_valuestring(object_item);
        -:   67://    assert_has_no_string(object_item);
        -:   68:}
        -:   69:
        2:   70:static void assert_parse_object(const char *json)
        -:   71:{
        2:   72:    parse_buffer parsebuffer = { 0, 0, 0, 0, { 0, 0, 0 } };
        2:   73:    parsebuffer.content = (const unsigned char*)json;
        2:   74:    parsebuffer.length = strlen(json) + sizeof("");
        2:   75:    parsebuffer.hooks = global_hooks;
        -:   76:
        2:   77:    ASSERT_TRUE(parse_object(item, &parsebuffer));
        2:   78:    assert_is_object(item);
        -:   79:}
        -:   80:
        5:   81:TEST(CjsonFixture, parse_empty_objects){
        1:   82:    assert_parse_object("{}");
        1:   83:    assert_parse_object("{\n\t}");
        1:   84:}
        -:   85://
        -:   86://TEST(CjsonFixture, parse_object_should_parse_objects_with_one_element){
        -:   87://    assert_parse_object("{\"one\":1}");
        -:   88:////    assert_is_child(item->child, "one", cJSON_Number);
        -:   89://    reset(item);
        -:   90://
        -:   91://    assert_parse_object("{\"hello\":\"world!\"}");
        -:   92:////    assert_is_child(item->child, "hello", cJSON_String);
        -:   93://    reset(item);
        -:   94://
        -:   95://    assert_parse_object("{\"array\":[]}");
        -:   96:////    assert_is_child(item->child, "array", cJSON_Array);
        -:   97://    reset(item);
        -:   98://
        -:   99://    assert_parse_object("{\"null\":null}");
        -:  100:////    assert_is_child(item->child, "null", cJSON_NULL);
        -:  101://    reset(item);
        -:  102://}
        -:  103://TEST(CjsonFixture, parse_object_should_parse_objects_with_multiple_elements)
        -:  104://{
        -:  105://    assert_parse_object("{\"one\":1\t,\t\"two\"\n:2, \"three\":3}");
        -:  106:////    assert_is_child(item->child, "one", cJSON_Number);
        -:  107:////    assert_is_child(item->child->next, "two", cJSON_Number);
        -:  108:////    assert_is_child(item->child->next->next, "three", cJSON_Number);
        -:  109://    reset(item);
        -:  110://
        -:  111://    {
        -:  112://        size_t i = 0;
        -:  113://        cJSON *node = NULL;
        -:  114://        int expected_types[7] =
        -:  115://                {
        -:  116://                        cJSON_Number,
        -:  117://                        cJSON_NULL,
        -:  118://                        cJSON_True,
        -:  119://                        cJSON_False,
        -:  120://                        cJSON_Array,
        -:  121://                        cJSON_String,
        -:  122://                        cJSON_Object
        -:  123://                };
        -:  124://        const char *expected_names[7] =
        -:  125://                {
        -:  126://                        "one",
        -:  127://                        "NULL",
        -:  128://                        "TRUE",
        -:  129://                        "FALSE",
        -:  130://                        "array",
        -:  131://                        "world",
        -:  132://                        "object"
        -:  133://                };
        -:  134://        assert_parse_object("{\"one\":1, \"NULL\":null, \"TRUE\":true, \"FALSE\":false, \"array\":[], \"world\":\"hello\", \"object\":{}}");
        -:  135://
        -:  136://        node = item->child;
        -:  137://        for (
        -:  138://                i = 0;
        -:  139://                (i < (sizeof(expected_types)/sizeof(int)))
        -:  140://                && (node != NULL);
        -:  141://                (void)i++, node = node->next)
        -:  142://        {
        -:  143:////            assert_is_child(node, expected_names[i], expected_types[i]);
        -:  144://        }
        -:  145:////        TEST_ASSERT_EQUAL_INT(i, 7);
        -:  146://        reset(item);
        -:  147://    }
        -:  148://}
        -:  149://
        -:  150://static void assert_parse_array(const char *json)
        -:  151://{
        -:  152://    parse_buffer buffer = { 0, 0, 0, 0, { 0, 0, 0 } };
        -:  153://    buffer.content = (const unsigned char*)json;
        -:  154://    buffer.length = strlen(json) + sizeof("");
        -:  155://    buffer.hooks = global_hooks;
        -:  156://
        -:  157://    ASSERT_TRUE(parse_array(item, &buffer));
        -:  158:////    assert_is_array(item);
        -:  159://}
        -:  160://
        -:  161://TEST(CjsonFixture, parse_array_should_parse_empty_arrays)
        -:  162:////static void parse_array_should_parse_empty_arrays(void)
        -:  163://{
        -:  164://    assert_parse_array("[]");
        -:  165:////    assert_has_no_child(item);
        -:  166://
        -:  167://    assert_parse_array("[\n\t]");
        -:  168:////    assert_has_no_child(item);
        -:  169://}
        -:  170://TEST(CjsonFixture, parse_array_should_parse_arrays_with_one_element)
        -:  171://{
        -:  172://
        -:  173://    assert_parse_array("[1]");
        -:  174:////    assert_has_child(item);
        -:  175://    assert_has_type(item->child, cJSON_Number);
        -:  176://    reset(item);
        -:  177://
        -:  178://    assert_parse_array("[\"hello!\"]");
        -:  179:////    assert_has_child(item);
        -:  180://    assert_has_type(item->child, cJSON_String);
        -:  181://    ASSERT_STREQ("hello!", item->child->valuestring);
        -:  182://    reset(item);
        -:  183://
        -:  184://    assert_parse_array("[[]]");
        -:  185:////    assert_has_child(item);
        -:  186:////    assert_is_array(item->child);
        -:  187:////    assert_has_no_child(item->child);
        -:  188://    reset(item);
        -:  189://
        -:  190://    assert_parse_array("[null]");
        -:  191:////    assert_has_child(item);
        -:  192://    assert_has_type(item->child, cJSON_NULL);
        -:  193://    reset(item);
        -:  194://}
        -:  195://TEST(CjsonFixture, parse_array_should_parse_arrays_with_multiple_elements)
        -:  196://{
        -:  197://    assert_parse_array("[1\t,\n2, 3]");
        -:  198:////    assert_has_child(item);
        -:  199:////    TEST_ASSERT_NOT_NULL(item->child->next);
        -:  200:////    TEST_ASSERT_NOT_NULL(item->child->next->next);
        -:  201:////    TEST_ASSERT_NULL(item->child->next->next->next);
        -:  202://    assert_has_type(item->child, cJSON_Number);
        -:  203://    assert_has_type(item->child->next, cJSON_Number);
        -:  204://    assert_has_type(item->child->next->next, cJSON_Number);
        -:  205://    reset(item);
        -:  206://
        -:  207://    {
        -:  208://        size_t i = 0;
        -:  209://        cJSON *node = NULL;
        -:  210://        int expected_types[7] =
        -:  211://                {
        -:  212://                        cJSON_Number,
        -:  213://                        cJSON_NULL,
        -:  214://                        cJSON_True,
        -:  215://                        cJSON_False,
        -:  216://                        cJSON_Array,
        -:  217://                        cJSON_String,
        -:  218://                        cJSON_Object
        -:  219://                };
        -:  220://        assert_parse_array("[1, null, true, false, [], \"hello\", {}]");
        -:  221://
        -:  222://        node = item->child;
        -:  223://        for (
        -:  224://                i = 0;
        -:  225://                (i < (sizeof(expected_types)/sizeof(int)))
        -:  226://                && (node != NULL);
        -:  227://                (void)i++, node = node->next)
        -:  228://        {
        -:  229:////            TEST_ASSERT_BITS(0xFF, expected_types[i], node->type);
        -:  230://        }
        -:  231:////        TEST_ASSERT_EQUAL_INT(i, 7);
        -:  232://        reset(item);
        -:  233://    }
        -:  234://}
        -:  235://
       18:  236:static void assert_parse_number(const char *string, int integer, double real)
        -:  237:{
       18:  238:    parse_number(item, NULL);
       18:  239:    parse_buffer buffer = { 0, 0, 0, 0, { 0, 0, 0 } };
       18:  240:    parse_number(item, &buffer);
       18:  241:    buffer.content = (const unsigned char*)string;
       18:  242:    buffer.length = strlen(string) + sizeof("");
        -:  243:
       18:  244:    ASSERT_TRUE(parse_number(item, &buffer));
        -:  245://    assert_is_number(item);
       18:  246:    ASSERT_EQ(integer, item->valueint);
       18:  247:    ASSERT_DOUBLE_EQ(real, item->valuedouble);
        -:  248:}
        -:  249:
        5:  250:TEST(CjsonFixture, buffer_skip_whitespace){
        1:  251:    buffer_skip_whitespace(NULL);
        1:  252:    skip_utf8_bom(NULL);
        -:  253:    unsigned char printed[1024];
        -:  254:    cJSON item[1];
        1:  255:    printbuffer buffer = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };
        1:  256:    parse_buffer parsebuffer = { 0, 0, 0, 0, { 0, 0, 0 } };
        1:  257:    buffer.buffer = printed;
        1:  258:    buffer.length = sizeof(printed);
        1:  259:    skip_utf8_bom(&parsebuffer);
        1:  260:    parsebuffer.offset=1;
        1:  261:    skip_utf8_bom(&parsebuffer);
        1:  262:    buffer_skip_whitespace(&parsebuffer);
        1:  263:}
        5:  264:TEST(CjsonFixture, parse_number_should_parse_zero)
        -:  265:{
        1:  266:    assert_parse_number("0", 0, 0);
        1:  267:    assert_parse_number("0.0", 0, 0.0);
        1:  268:    assert_parse_number("-0", 0, -0.0);
        1:  269:}
        -:  270:
        5:  271:TEST(CjsonFixture, parse_number_should_parse_negative_integers)
        -:  272:{
        1:  273:    assert_parse_number("-1", -1, -1);
        1:  274:    assert_parse_number("-32768", -32768, -32768.0);
        1:  275:    assert_parse_number("-2147483648", (int)-2147483648.0, -2147483648.0);
        1:  276:}
        -:  277:
    #####:  278:static void parse_number_should_parse_positive_integers(void)
        -:  279:{
    #####:  280:    assert_parse_number("1", 1, 1);
    #####:  281:    assert_parse_number("32767", 32767, 32767.0);
    #####:  282:    assert_parse_number("2147483647", (int)2147483647.0, 2147483647.0);
    #####:  283:}
        5:  284:TEST(CjsonFixture, parse_number_should_parse_positive_reals)
        -:  285:{
        1:  286:    assert_parse_number("0.001", 0, 0.001);
        1:  287:    assert_parse_number("10e-10", 0, 10e-10);
        1:  288:    assert_parse_number("10E-10", 0, 10e-10);
        1:  289:    assert_parse_number("10e10", INT_MAX, 10e10);
        1:  290:    assert_parse_number("123e+127", INT_MAX, 123e127);
        1:  291:    assert_parse_number("123e-128", 0, 123e-128);
        1:  292:}
        5:  293:TEST(CjsonFixture, parse_number_should_parse_negative_reals)
        -:  294:{
        1:  295:    assert_parse_number("-0.001", 0, -0.001);
        1:  296:    assert_parse_number("-10e-10", 0, -10e-10);
        1:  297:    assert_parse_number("-10E-10", 0, -10e-10);
        1:  298:    assert_parse_number("-10e20", INT_MIN, -10e20);
        1:  299:    assert_parse_number("-123e+127", INT_MIN, -123e127);
        1:  300:    assert_parse_number("-123e-128", 0, -123e-128);
        1:  301:}
        -:  302://
        -:  303://static void assert_parse_value(const char *string, int type)
        -:  304://{
        -:  305://    parse_buffer buffer = { 0, 0, 0, 0, { 0, 0, 0 } };
        -:  306://    buffer.content = (const unsigned char*) string;
        -:  307://    buffer.length = strlen(string) + sizeof("");
        -:  308://    buffer.hooks = global_hooks;
        -:  309://
        -:  310://    parse_value(item, &buffer);
        -:  311:////    TEST_ASSERT_TRUE(parse_value(item, &buffer));
        -:  312:////    assert_is_value(item, type);
        -:  313://}
        -:  314://
        -:  315://TEST(CjsonFixture, parse_value)
        -:  316://{
        -:  317://    assert_parse_value("null", cJSON_NULL);
        -:  318://    reset(item);
        -:  319://
        -:  320://    assert_parse_value("true", cJSON_True);
        -:  321://    reset(item);
        -:  322://
        -:  323://    assert_parse_value("false", cJSON_False);
        -:  324://    reset(item);
        -:  325://
        -:  326://    assert_parse_value("1.5", cJSON_Number);
        -:  327://    reset(item);
        -:  328://
        -:  329://    assert_parse_value("\"\"", cJSON_String);
        -:  330://    reset(item);
        -:  331://    assert_parse_value("\"hello\"", cJSON_String);
        -:  332://    reset(item);
        -:  333://
        -:  334://    assert_parse_value("[]", cJSON_Array);
        -:  335://    reset(item);
        -:  336://
        -:  337://    assert_parse_value("{}", cJSON_Object);
        -:  338://    reset(item);
        -:  339://
        -:  340://
        -:  341://}
        -:  342://
        -:  343://static void assert_case_insensitive_strcmp(const unsigned char *string1, const unsigned char *string2,int integer)
        -:  344://{
        -:  345://    ASSERT_EQ(integer,case_insensitive_strcmp(string1,string2));
        -:  346://}
        -:  347://TEST(CjsonFixture, case_insensitive_strcmp)
        -:  348://{
        -:  349://    assert_case_insensitive_strcmp(NULL,NULL,1);
        -:  350://
        -:  351://}
        -:  352://
        1:  353:static void assert_cJSON_GetErrorPtr()
        -:  354:{
        1:  355:    cJSON_GetErrorPtr();
        1:  356:}
        -:  357://
        5:  358:TEST(CjsonFixture, assert_cJSON_GetErrorPtr)
        -:  359:{
        1:  360:    assert_cJSON_GetErrorPtr();
        1:  361:}
        -:  362://
        -:  363://
        -:  364://
        1:  365:static void assert_cJSON_Version()
        -:  366:{
        1:  367:    cJSON_Version();
        1:  368:}
        -:  369:
        5:  370:TEST(CjsonFixture, assert_cJSON_Version)
        -:  371:{
        1:  372:    assert_cJSON_Version();
        1:  373:}
        -:  374://
        -:  375://static void assert_cJSON_strdup()
        -:  376://{
        -:  377://    cJSON_strdup((const unsigned char*)"number", &global_hooks);
        -:  378://}
        -:  379://TEST(CjsonFixture, assert_cJSON_strdup)
        -:  380://{
        -:  381://    assert_cJSON_strdup();
        -:  382://}
        -:  383://
        -:  384://
        -:  385://
        -:  386:
        -:  387://
        -:  388:////测试出问题
        3:  389:static void assert_cJSON_SetNumberHelper(cJSON *object, double number)
        -:  390:{
        3:  391:    cJSON_SetNumberHelper(object, number);
        3:  392:}
        5:  393:TEST(CjsonFixture, assert_cJSON_SetNumberHelper)
        -:  394:{
        1:  395:    cJSON *object = cJSON_CreateObject();
        1:  396:    assert_cJSON_SetNumberHelper(object,0);
        1:  397:    assert_cJSON_SetNumberHelper(object,INT_MAX);
        1:  398:    assert_cJSON_SetNumberHelper(object,(double)INT_MIN);
        1:  399:}
        -:  400://
        -:  401://
        -:  402://
        -:  403://
        2:  404:static void * CJSON_CDECL failing_realloc(void *pointer, size_t size)
        -:  405:{
        -:  406:    (void)size;
        -:  407:    (void)pointer;
        2:  408:    return NULL;
        -:  409:}
    #####:  410:static void assert_ensure(printbuffer * const p, size_t needed)
        -:  411:{
    #####:  412:    ensure(p,needed);
    #####:  413:}
        5:  414:TEST(CjsonFixture, assert_ensure)
        -:  415:{
        -:  416:
        -:  417:
        1:  418:    printbuffer buffer = {NULL, 10, 0, 0, false, false, {&malloc, &free, &failing_realloc}};
        1:  419:    ensure(&buffer, 200);
        1:  420:    buffer.buffer = (unsigned char*)malloc(100);
        -:  421://    ensure(&buffer, 200);
        1:  422:    long long need= INT_MAX;
        1:  423:    need=need+1;
        1:  424:    ASSERT_TRUE(need>INT_MAX);
        -:  425://
        1:  426:    ASSERT_FALSE(ensure(&buffer,need));
        1:  427:    ensure(&buffer,INT_MAX/2 +1);
        -:  428:
        -:  429://    ensure(output_buffer, (size_t)length + sizeof(""));
        -:  430:
        -:  431://    printbuffer *buffer1;
        -:  432://    buffer1->buffer = NULL;
        -:  433://    buffer1->length = 10;
        -:  434://    buffer1->hooks.reallocate = NULL;
        -:  435://    ensure(buffer1, 200);
        -:  436:}
        -:  437:
        5:  438:TEST(CjsonFixture2, assert_ensure2){
        1:  439:    printbuffer buffer = {NULL, 10, 0, 0, false, false, {&malloc, &free, &failing_realloc}};
        1:  440:    buffer.buffer = (unsigned char*)malloc(100);
        -:  441:
        1:  442:    buffer.noalloc=1;
        1:  443:    ensure(&buffer, 200);
        1:  444:    ensure(NULL,200);
        1:  445:}
        -:  446:
        5:  447:TEST(CjsonFixture2, assert_ensure3){
        1:  448:    printbuffer buffer = {NULL, 10, 0, 0, false, false, {&malloc, &free, &failing_realloc}};
        1:  449:    buffer.buffer = (unsigned char*)malloc(100);
        1:  450:    buffer.length=1;
        1:  451:    buffer.offset=2;
        1:  452:    ensure(&buffer, 200);
        1:  453:}
        5:  454:TEST(CjsonFixture2, assert_ensure4){
        1:  455:    printbuffer buffer = {NULL, 10, 0, 0, false, false, {&malloc, &free, &failing_realloc}};
        1:  456:    buffer.buffer = (unsigned char*)malloc(100);
        -:  457:
        1:  458:    ensure(&buffer,INT_MAX/2 -1);
        1:  459:    ensure(&buffer,INT_MAX);
        1:  460:}
        -:  461:
        -:  462:
        5:  463:TEST(CjsonFixture2, assert_ensure5){
        1:  464:    printbuffer buffer = {NULL, 10, 0, 0, false, false, {&malloc, &free, &failing_realloc}};
        1:  465:    buffer.buffer = (unsigned char*)malloc(100);
        1:  466:    buffer.length=-1;
        -:  467://    buffer.offset=2;
        1:  468:    ensure(&buffer, 200);
        1:  469:}
        -:  470:
        5:  471:TEST(CjsonFixture2, assert_ensure6){
        1:  472:    printbuffer buffer = {NULL, 10, 0, 0, false, false, {&malloc, &free, &failing_realloc}};
        1:  473:    buffer.buffer = (unsigned char*)malloc(100);
        1:  474:    buffer.hooks.reallocate=NULL;
        1:  475:    ensure(&buffer, 200);
        1:  476:}
        -:  477:
        -:  478://
        3:  479:static void assert_update_offset(printbuffer *buffer)
        -:  480:{
        3:  481:    update_offset(buffer);
        3:  482:}
        5:  483:TEST(CjsonFixture, assert_update_offset)
        -:  484:{
        1:  485:    printbuffer buffer = {NULL, 10, 0, 0, false, false, {&malloc, &free, &failing_realloc}};
        1:  486:    assert_update_offset(&buffer);
        1:  487:    buffer.buffer = (unsigned char*)malloc(100);
        1:  488:    assert_update_offset(NULL);
        1:  489:    assert_update_offset(&buffer);
        -:  490://    printbuffer *buffer1 ;
        -:  491://    buffer1->length = 10;
        -:  492://
        -:  493://    assert_update_offset(buffer1);
        1:  494:}
        -:  495://
        -:  496://
        -:  497://static void assert_compare_double(double a, double b)
        -:  498://{
        -:  499://    compare_double(a,b);
        -:  500://}
        -:  501://TEST(CjsonFixture, assert_compare_double)
        -:  502://{
        -:  503://    assert_compare_double(0.0,2.0);
        -:  504://}
        -:  505://
        -:  506://
        -:  507://
       18:  508:static void assert_print_number(const char *expected, double input)
        -:  509:{
        -:  510:    unsigned char printed[1024];
        -:  511:    unsigned char new_buffer[26];
       18:  512:    unsigned int i = 0;
        -:  513:    cJSON item[1];
       18:  514:    printbuffer buffer = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };
       18:  515:    buffer.buffer = printed;
       18:  516:    buffer.length = sizeof(printed);
       18:  517:    buffer.offset = 0;
       18:  518:    buffer.noalloc = true;
       18:  519:    buffer.hooks = global_hooks;
       18:  520:    buffer.buffer = new_buffer;
        -:  521:
       18:  522:    memset(item, 0, sizeof(item));
       18:  523:    memset(new_buffer, 0, sizeof(new_buffer));
       18:  524:    cJSON_SetNumberValue(item, input);
       18:  525:    print_number(item, &buffer);
       18:  526:    print_number(item, NULL);
       18:  527:}
        5:  528:TEST(CjsonFixture, print_number)
        -:  529:{
        1:  530:    assert_print_number("0", 0);
        1:  531:    assert_print_number("-1", -1.0);
        1:  532:    assert_print_number("-32768", -32768.0);
        1:  533:    assert_print_number("-2147483648", -2147483648.0);
        1:  534:    assert_print_number("1", 1.0);
        1:  535:    assert_print_number("32767", 32767.0);
        1:  536:    assert_print_number("2147483647", 2147483647.0);
        1:  537:    assert_print_number("0.123", 0.123);
        1:  538:    assert_print_number("1e-09", 10e-10);
        1:  539:    assert_print_number("1000000000000", 10e11);
        1:  540:    assert_print_number("1.23e+129", 123e+127);
        1:  541:    assert_print_number("1.23e-126", 123e-128);
        1:  542:    assert_print_number("3.1415926535897931", 3.1415926535897931);
        1:  543:    assert_print_number("-0.0123", -0.0123);
        1:  544:    assert_print_number("-1e-09", -10e-10);
        1:  545:    assert_print_number("-1e+21", -10e20);
        1:  546:    assert_print_number("-1.23e+129", -123e+127);
        1:  547:    assert_print_number("-1.23e-126", -123e-128);
        1:  548:}
        -:  549://
        -:  550://
        4:  551:static void assert_print_string(const char *expected, const char *input)
        -:  552:{
        -:  553:    unsigned char printed[1024];
        4:  554:    printbuffer buffer = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };
        4:  555:    buffer.buffer = printed;
        4:  556:    buffer.length = sizeof(printed);
        4:  557:    buffer.offset = 0;
        4:  558:    buffer.noalloc = true;
        4:  559:    buffer.hooks = global_hooks;
        -:  560:
        4:  561:    print_string_ptr((const unsigned char*)input, &buffer);
        -:  562://    TEST_ASSERT_TRUE_MESSAGE(print_string_ptr((const unsigned char*)input, &buffer), "Failed to print string.");
        -:  563://    TEST_ASSERT_EQUAL_STRING_MESSAGE(expected, printed, "The printed string isn't as expected.");
        4:  564:}
        5:  565:TEST(CjsonFixture, print_string_should_print_empty_strings)
        -:  566://static void print_string_should_print_empty_strings(void)
        -:  567:{
        1:  568:    assert_print_string("\"\"", "");
        1:  569:    assert_print_string("\"\"", NULL);
        -:  570:
        -:  571:    char ascii[0x7F];
        1:  572:    size_t i = 1;
        -:  573:
        -:  574:    /* create ascii table */
      127:  575:    for (i = 1; i < 0x7F; i++)
        -:  576:    {
      126:  577:        ascii[i-1] = (char)i;
        -:  578:    }
        1:  579:    ascii[0x7F-1] = '\0';
        -:  580:
        1:  581:    assert_print_string("\"\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\\u0010\\u0011\\u0012\\u0013\\u0014\\u0015\\u0016\\u0017\\u0018\\u0019\\u001a\\u001b\\u001c\\u001d\\u001e\\u001f !\\\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\"",
        -:  582:            ascii);
        -:  583:
        1:  584:    assert_print_string("\"ü猫慕\"", "ü猫慕");
        -:  585:
        1:  586:}
        -:  587://
    #####:  588:static void assert_cJSON_ParseWithOpts(const char *value, const char **return_parse_end, cJSON_bool require_null_terminated)
        -:  589:{
    #####:  590:    cJSON_ParseWithOpts(value,return_parse_end,require_null_terminated);
    #####:  591:}
        5:  592:TEST(CjsonFixture, assert_cJSON_ParseWithOpts)
        -:  593:{
        1:  594:    const char *error_pointer = NULL;
        1:  595:    cJSON *item = NULL;
        1:  596:    cJSON_ParseWithOpts(NULL, &error_pointer, false);
        1:  597:    item = cJSON_ParseWithOpts("{}", NULL, false);
        1:  598:    ASSERT_TRUE(item!=NULL);
        1:  599:    cJSON_Delete(item);
        1:  600:    ASSERT_TRUE(cJSON_ParseWithOpts(NULL, NULL, false)==NULL);
        1:  601:    ASSERT_TRUE(cJSON_ParseWithOpts("{", NULL, false)==NULL);
        -:  602:
        -:  603:}
        5:  604:TEST(CjsonFixture, assert_cJSON_ParseWithOpts2)
        -:  605:{
        1:  606:    const char empty_string[] = "";
        1:  607:    const char *error_pointer = NULL;
        -:  608:
        1:  609:    ASSERT_TRUE(cJSON_ParseWithOpts(empty_string, NULL, false)==NULL);
        1:  610:    ASSERT_TRUE(cJSON_ParseWithOpts(empty_string, &error_pointer, false)==NULL);
        -:  611:
        1:  612:    const char json[] = "{ \"name\": ";
        1:  613:    const char *parse_end = NULL;
        -:  614:
        1:  615:    ASSERT_TRUE(cJSON_ParseWithOpts(json, &parse_end, false)==NULL);
        -:  616:
        1:  617:    cJSON *item = cJSON_ParseWithOpts("{}", NULL, true);
        1:  618:    ASSERT_TRUE(item!=NULL);
        1:  619:    cJSON_Delete(item);
        1:  620:    item = cJSON_ParseWithOpts("{} \n", NULL, true);
        1:  621:    ASSERT_TRUE(item!=NULL);
        1:  622:    cJSON_Delete(item);
        1:  623:    ASSERT_TRUE(cJSON_ParseWithOpts("{}x", NULL, true)==NULL);
        -:  624:
        -:  625:}
        5:  626:TEST(CjsonFixture, assert_cJSON_ParseWithOpts3)
        -:  627:{
        1:  628:    const char json[] = "[] empty array XD";
        1:  629:    const char *parse_end = NULL;
        -:  630:
        1:  631:    cJSON *item = cJSON_ParseWithOpts(json, &parse_end, false);
        1:  632:    ASSERT_TRUE(item!=NULL);
        1:  633:    cJSON_Delete(item);
        -:  634:
        1:  635:    cJSON *with_bom = NULL;
        1:  636:    cJSON *without_bom = NULL;
        -:  637:
        1:  638:    with_bom = cJSON_ParseWithOpts("\xEF\xBB\xBF{}", NULL, true);
        1:  639:    ASSERT_TRUE(with_bom!=NULL);
        1:  640:    without_bom = cJSON_ParseWithOpts("{}", NULL, true);
        1:  641:    ASSERT_TRUE(with_bom!=NULL);
        -:  642:
        1:  643:    ASSERT_TRUE(cJSON_Compare(with_bom, without_bom, true));
        -:  644:
        1:  645:    cJSON_Delete(with_bom);
        1:  646:    cJSON_Delete(without_bom);
        -:  647:}
        -:  648://
        -:  649://
        -:  650://static void assert_cJSON_Parse()
        -:  651://{
        -:  652://    cJSON_Parse("a");
        -:  653://}
        -:  654://TEST(CjsonFixture, assert_cJSON_Parse)
        -:  655://{
        -:  656://    assert_cJSON_Parse();
        -:  657://}
        -:  658://
        -:  659:
        5:  660:TEST(CjsonFixture, assert_cJSON_Print)
        -:  661:{
        1:  662:    cJSON *root=NULL;
        1:  663:    cJSON_Print(root);
        1:  664:    root=cJSON_CreateString("root");
        1:  665:    cJSON_Print(root);
        1:  666:    root=cJSON_Parse("\"[true, false]\"");
        1:  667:    cJSON_Print(root);
        -:  668:
        1:  669:    global_hooks.reallocate=NULL;
        1:  670:    cJSON_Print(root);
        1:  671:    global_hooks.reallocate=internal_realloc;
        1:  672:}
        -:  673://
        1:  674:static void assert_cJSON_PrintUnformatted()
        -:  675:{
        1:  676:    const char *merges[15][3] =
        -:  677:            {
        -:  678:                    {"{\"a\":\"b\"}", "{\"a\":\"c\"}", "{\"a\":\"c\"}"},
        -:  679:                    {"{\"a\":\"b\"}", "{\"b\":\"c\"}", "{\"a\":\"b\",\"b\":\"c\"}"},
        -:  680:                    {"{\"a\":\"b\"}", "{\"a\":null}", "{}"},
        -:  681:                    {"{\"a\":\"b\",\"b\":\"c\"}", "{\"a\":null}", "{\"b\":\"c\"}"},
        -:  682:                    {"{\"a\":[\"b\"]}", "{\"a\":\"c\"}", "{\"a\":\"c\"}"},
        -:  683:                    {"{\"a\":\"c\"}", "{\"a\":[\"b\"]}", "{\"a\":[\"b\"]}"},
        -:  684:                    {"{\"a\":{\"b\":\"c\"}}", "{\"a\":{\"b\":\"d\",\"c\":null}}", "{\"a\":{\"b\":\"d\"}}"},
        -:  685:                    {"{\"a\":[{\"b\":\"c\"}]}", "{\"a\":[1]}", "{\"a\":[1]}"},
        -:  686:                    {"[\"a\",\"b\"]", "[\"c\",\"d\"]", "[\"c\",\"d\"]"},
        -:  687:                    {"{\"a\":\"b\"}", "[\"c\"]", "[\"c\"]"},
        -:  688:                    {"{\"a\":\"foo\"}", "null", "null"},
        -:  689:                    {"{\"a\":\"foo\"}", "\"bar\"", "\"bar\""},
        -:  690:                    {"{\"e\":null}", "{\"a\":1}", "{\"e\":null,\"a\":1}"},
        -:  691:                    {"[1,2]", "{\"a\":\"b\",\"c\":null}", "{\"a\":\"b\"}"},
        -:  692:                    {"{}","{\"a\":{\"bb\":{\"ccc\":null}}}", "{\"a\":{\"bb\":{}}}"}
        -:  693:            };
       16:  694:    for (int i = 0; i <15 ; ++i) {
       15:  695:        cJSON *object_to_be_merged = cJSON_Parse(merges[i][0]);
       15:  696:        cJSON *patch = cJSON_Parse(merges[i][1]);
        -:  697:
        -:  698:
       15:  699:        cJSON_PrintUnformatted(patch);
       15:  700:        cJSON_PrintUnformatted(object_to_be_merged);
        -:  701:    }
        -:  702:
        1:  703:}
        5:  704:TEST(CjsonFixture, assert_cJSON_PrintUnformatted)
        -:  705:{
        1:  706:    assert_cJSON_PrintUnformatted();
        1:  707:}
        -:  708://
        -:  709://
        1:  710:static void assert_cJSON_PrintBuffered()
        -:  711:{
        1:  712:    cJSON_PrintBuffered(NULL, 10, true);
        1:  713:}
        5:  714:TEST(CjsonFixture, assert_cJSON_PrintBuffered)
        -:  715:{
        1:  716:    assert_cJSON_PrintBuffered();
        1:  717:}
        -:  718://
        -:  719://static void assert_cJSON_PrintPreallocated(cJSON *item, char *buffer, const int length, const cJSON_bool format)
        -:  720://{
        -:  721://    cJSON_PrintPreallocated(item,buffer,length,format);
        -:  722://}
        -:  723://TEST(CjsonFixture, assert_cJSON_PrintPreallocated)
        -:  724://{
        -:  725:////    char *out = NULL;
        -:  726:////    cJSON *root;
        -:  727:////    char *buf = NULL;
        -:  728:////    size_t len = 0;
        -:  729:////    out = cJSON_Print(root);
        -:  730:////    len = strlen(out) + 5;
        -:  731:////    buf = (char*)malloc(len);
        -:  732:////    cJSON_PrintPreallocated(root, buf, (int)len, 1);
        -:  733://
        -:  734://    char buffer[10];
        -:  735://    cJSON *item = cJSON_CreateString("item");
        -:  736://    cJSON_PrintPreallocated(NULL, buffer, sizeof(buffer), true);
        -:  737://    cJSON_PrintPreallocated(item, NULL, 1, true);
        -:  738://}
        -:  739://
        -:  740://static void assert_print_value(const char *input)
        -:  741://{
        -:  742://    unsigned char printed[1024];
        -:  743://    cJSON item[1];
        -:  744://    printbuffer buffer = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };
        -:  745://    parse_buffer parsebuffer = { 0, 0, 0, 0, { 0, 0, 0 } };
        -:  746://    buffer.buffer = printed;
        -:  747://    buffer.length = sizeof(printed);
        -:  748://    buffer.offset = 0;
        -:  749://    buffer.noalloc = true;
        -:  750://    buffer.hooks = global_hooks;
        -:  751://
        -:  752://    parsebuffer.content = (const unsigned char*)input;
        -:  753://    parsebuffer.length = strlen(input) + sizeof("");
        -:  754://    parsebuffer.hooks = global_hooks;
        -:  755://
        -:  756://    memset(item, 0, sizeof(item));
        -:  757://
        -:  758://    parse_value(item, &parsebuffer);
        -:  759:////    TEST_ASSERT_TRUE_MESSAGE(parse_value(item, &parsebuffer), "Failed to parse value.");
        -:  760://
        -:  761://    print_value(item, &buffer);
        -:  762:////    TEST_ASSERT_TRUE_MESSAGE(print_value(item, &buffer), "Failed to print value.");
        -:  763:////    TEST_ASSERT_EQUAL_STRING_MESSAGE(input, buffer.buffer, "Printed value is not as expected.");
        -:  764://
        -:  765://    reset(item);
        -:  766://}
        -:  767://
        -:  768://TEST(CjsonFixture, print_value)
        -:  769://{
        -:  770://    assert_print_value("null");
        -:  771://    assert_print_value("true");
        -:  772://    assert_print_value("false");
        -:  773://    assert_print_value("1.5");
        -:  774://    assert_print_value("\"\"");
        -:  775://    assert_print_value("\"hello\"");
        -:  776://    assert_print_value("[]");
        -:  777://    assert_print_value("{}");
        -:  778://
        -:  779://}
        -:  780://
        -:  781://
        7:  782:static void assert_print_array(const char * const expected, const char * const input)
        -:  783:{
        -:  784:    unsigned char printed_unformatted[1024];
        -:  785:    unsigned char printed_formatted[1024];
        -:  786:
        -:  787:    cJSON item[1];
        -:  788:
        7:  789:    printbuffer formatted_buffer = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };
        7:  790:    printbuffer unformatted_buffer = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };
        -:  791:
        7:  792:    parse_buffer parsebuffer = { 0, 0, 0, 0, { 0, 0, 0 } };
        7:  793:    parsebuffer.content = (const unsigned char*)input;
        7:  794:    parsebuffer.length = strlen(input) + sizeof("");
        7:  795:    parsebuffer.hooks = global_hooks;
        -:  796:
        -:  797:    /* buffer for formatted printing */
        7:  798:    formatted_buffer.buffer = printed_formatted;
        7:  799:    formatted_buffer.length = sizeof(printed_formatted);
        7:  800:    formatted_buffer.offset = 0;
        7:  801:    formatted_buffer.noalloc = true;
        7:  802:    formatted_buffer.hooks = global_hooks;
        -:  803:
        -:  804:    /* buffer for unformatted printing */
        7:  805:    unformatted_buffer.buffer = printed_unformatted;
        7:  806:    unformatted_buffer.length = sizeof(printed_unformatted);
        7:  807:    unformatted_buffer.offset = 0;
        7:  808:    unformatted_buffer.noalloc = true;
        7:  809:    unformatted_buffer.hooks = global_hooks;
        -:  810:
        7:  811:    memset(item, 0, sizeof(item));
        7:  812:    parse_array(item, &parsebuffer);
        7:  813:    cJSON_GetArraySize(item);
        -:  814://    TEST_ASSERT_TRUE_MESSAGE(parse_array(item, &parsebuffer), "Failed to parse array.");
        -:  815:
        7:  816:    unformatted_buffer.format = false;
        7:  817:    print_array(item, &unformatted_buffer);
        -:  818://    TEST_ASSERT_TRUE_MESSAGE(print_array(item, &unformatted_buffer), "Failed to print unformatted string.");
        -:  819://    TEST_ASSERT_EQUAL_STRING_MESSAGE(input, printed_unformatted, "Unformatted array is not correct.");
        -:  820:
        7:  821:    formatted_buffer.format = true;
        7:  822:    print_array(item, &formatted_buffer);
        -:  823://    TEST_ASSERT_TRUE_MESSAGE(print_array(item, &formatted_buffer), "Failed to print formatted string.");
        -:  824://    TEST_ASSERT_EQUAL_STRING_MESSAGE(expected, printed_formatted, "Formatted array is not correct.");
        -:  825:
        7:  826:    reset(item);
        7:  827:}
        -:  828:
        5:  829:TEST(CjsonFixture, print_array)
        -:  830:{
        1:  831:    assert_print_array("[]", "[]");
        1:  832:    assert_print_array("[1]", "[1]");
        1:  833:    assert_print_array("[\"hello!\"]", "[\"hello!\"]");
        1:  834:    assert_print_array("[[]]", "[[]]");
        1:  835:    assert_print_array("[null]", "[null]");
        1:  836:    assert_print_array("[1, 2, 3]", "[1,2,3]");
        1:  837:    assert_print_array("[1, null, true, false, [], \"hello\", {\n\t}]", "[1,null,true,false,[],\"hello\",{}]");
        -:  838:
        1:  839:}
        -:  840://
        7:  841:static void assert_print_object(const char * const expected, const char * const input)
        -:  842:{
        -:  843:    unsigned char printed_unformatted[1024];
        -:  844:    unsigned char printed_formatted[1024];
        -:  845:
        -:  846:    cJSON item[1];
        -:  847:
        7:  848:    printbuffer formatted_buffer = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };
        7:  849:    printbuffer unformatted_buffer = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };
        7:  850:    parse_buffer parsebuffer = { 0, 0, 0, 0, { 0, 0, 0 } };
        -:  851:
        -:  852:    /* buffer for parsing */
        7:  853:    parsebuffer.content = (const unsigned char*)input;
        7:  854:    parsebuffer.length = strlen(input) + sizeof("");
        7:  855:    parsebuffer.hooks = global_hooks;
        -:  856:
        -:  857:    /* buffer for formatted printing */
        7:  858:    formatted_buffer.buffer = printed_formatted;
        7:  859:    formatted_buffer.length = sizeof(printed_formatted);
        7:  860:    formatted_buffer.offset = 0;
        7:  861:    formatted_buffer.noalloc = true;
        7:  862:    formatted_buffer.hooks = global_hooks;
        -:  863:
        -:  864:    /* buffer for unformatted printing */
        7:  865:    unformatted_buffer.buffer = printed_unformatted;
        7:  866:    unformatted_buffer.length = sizeof(printed_unformatted);
        7:  867:    unformatted_buffer.offset = 0;
        7:  868:    unformatted_buffer.noalloc = true;
        7:  869:    unformatted_buffer.hooks = global_hooks;
        -:  870:
        7:  871:    memset(item, 0, sizeof(item));
        7:  872:    parse_object(item, &parsebuffer);
        -:  873://    TEST_ASSERT_TRUE_MESSAGE(parse_object(item, &parsebuffer), "Failed to parse object.");
        -:  874:
        7:  875:    unformatted_buffer.format = false;
        7:  876:    print_object(item, &unformatted_buffer);
        -:  877://    TEST_ASSERT_TRUE_MESSAGE(print_object(item, &unformatted_buffer), "Failed to print unformatted string.");
        -:  878://    TEST_ASSERT_EQUAL_STRING_MESSAGE(input, printed_unformatted, "Unformatted object is not correct.");
        -:  879:
        7:  880:    formatted_buffer.format = true;
        7:  881:    print_object(item, &formatted_buffer);
        -:  882://    TEST_ASSERT_TRUE_MESSAGE(print_object(item, &formatted_buffer), "Failed to print formatted string.");
        -:  883://    TEST_ASSERT_EQUAL_STRING_MESSAGE(expected, printed_formatted, "Formatted ojbect is not correct.");
        -:  884:
        7:  885:    reset(item);
        7:  886:}
        -:  887:
        5:  888:TEST(CjsonFixture, print_object)
        -:  889://static void print_object_should_print_objects_with_multiple_elements(void)
        -:  890:{
        1:  891:    assert_print_object("{\n}", "{}");
        1:  892:    assert_print_object("{\n\t\"one\":\t1\n}", "{\"one\":1}");
        1:  893:    assert_print_object("{\n\t\"hello\":\t\"world!\"\n}", "{\"hello\":\"world!\"}");
        1:  894:    assert_print_object("{\n\t\"array\":\t[]\n}", "{\"array\":[]}");
        1:  895:    assert_print_object("{\n\t\"null\":\tnull\n}", "{\"null\":null}");
        1:  896:    assert_print_object("{\n\t\"one\":\t1,\n\t\"two\":\t2,\n\t\"three\":\t3\n}", "{\"one\":1,\"two\":2,\"three\":3}");
        1:  897:    assert_print_object("{\n\t\"one\":\t1,\n\t\"NULL\":\tnull,\n\t\"TRUE\":\ttrue,\n\t\"FALSE\":\tfalse,\n\t\"array\":\t[],\n\t\"world\":\t\"hello\",\n\t\"object\":\t{\n\t}\n}", "{\"one\":1,\"NULL\":null,\"TRUE\":true,\"FALSE\":false,\"array\":[],\"world\":\"hello\",\"object\":{}}");
        -:  898:
        1:  899:}
        -:  900://
        -:  901://
        5:  902:TEST(CjsonFixture, misc_tests)
        -:  903:{
        1:  904:    cJSON_GetArraySize(NULL);
        -:  905:
        1:  906:    int numbers[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
        1:  907:    cJSON *object = NULL;
        1:  908:    cJSON *nums = NULL;
        1:  909:    cJSON *num6 = NULL;
        1:  910:    char *pointer = NULL;
        -:  911:
        1:  912:    printf("JSON Pointer construct\n");
        1:  913:    object = cJSON_CreateObject();
        1:  914:    nums = cJSON_CreateIntArray(numbers, 10);
        1:  915:    num6 = cJSON_GetArrayItem(nums, 6);
        1:  916:    cJSON_AddItemToObject(object, "numbers", nums);
        -:  917:
        1:  918:    cJSON_Delete(object);
        -:  919:
        1:  920:    cJSON_GetObjectItem(NULL, "test");
        1:  921:    cJSON_GetObjectItemCaseSensitive(NULL, "test");
        1:  922:    cJSON_HasObjectItem(NULL, "test");
        -:  923:
        -:  924:    cJSON replacements[3];
        1:  925:    cJSON *beginning = NULL;
        1:  926:    cJSON *middle = NULL;
        1:  927:    cJSON *end = NULL;
        1:  928:    cJSON *array = NULL;
        -:  929:
        1:  930:    beginning = cJSON_CreateNull();
        1:  931:    ASSERT_TRUE(beginning!=NULL);
        1:  932:    middle = cJSON_CreateNull();
        1:  933:    ASSERT_TRUE(middle!=NULL);
        1:  934:    end = cJSON_CreateNull();
        1:  935:    ASSERT_TRUE(end!=NULL);
        -:  936:
        1:  937:    array = cJSON_CreateArray();
        1:  938:    ASSERT_TRUE(array!=NULL);
        -:  939:
        1:  940:    cJSON_AddItemToArray(array, beginning);
        1:  941:    cJSON_AddItemToArray(array, middle);
        1:  942:    cJSON_AddItemToArray(array, end);
        -:  943:
        -:  944:    char buffer[10];
        1:  945:    cJSON *item = cJSON_CreateString("item");
        1:  946:    ASSERT_FALSE(cJSON_PrintPreallocated(NULL, buffer, sizeof(buffer), true));
        1:  947:    ASSERT_FALSE(cJSON_PrintPreallocated(item, NULL, 1, true));
        -:  948:
        1:  949:    case_insensitive_strcmp((const unsigned char *)"a",(const unsigned char *)"a");
        1:  950:    case_insensitive_strcmp(NULL,(const unsigned char *)"a");
        1:  951:    case_insensitive_strcmp((const unsigned char *)"a",NULL);
        -:  952:
        1:  953:    char *name = (char*)cJSON_strdup(NULL, &global_hooks);
        -:  954:}
        -:  955://
        -:  956://
        -:  957:
        -:  958://
        -:  959:
        -:  960://
        -:  961://TEST(CjsonFixture, assert_cJSON_AddItemToArray)
        -:  962://{
        -:  963://    cJSON_AddItemToArray(NULL, NULL);
        -:  964://
        -:  965://    cJSON replacements[3];
        -:  966://    cJSON *beginning = NULL;
        -:  967://    cJSON *middle = NULL;
        -:  968://    cJSON *end = NULL;
        -:  969://    cJSON *array = NULL;
        -:  970://
        -:  971://    beginning = cJSON_CreateNull();
        -:  972://    middle = cJSON_CreateNull();
        -:  973://    end = cJSON_CreateNull();
        -:  974://
        -:  975://    array = cJSON_CreateArray();
        -:  976://
        -:  977://    cJSON_AddItemToArray(array, beginning);
        -:  978://    cJSON_AddItemToArray(array, middle);
        -:  979://    cJSON_AddItemToArray(array, end);
        -:  980://}
        -:  981://
        -:  982://TEST(CjsonFixture, assert_cast_away_const)
        -:  983://{
        -:  984://    cast_away_const(NULL);
        -:  985://}
        -:  986://
        -:  987://TEST(CjsonFixture, assert_cJSON_AddItemToObject)
        -:  988://{
        -:  989://    cJSON *root = NULL;
        -:  990://    cJSON *fmt = NULL;
        -:  991://    cJSON *img = NULL;
        -:  992://    cJSON *thm = NULL;
        -:  993://    cJSON *fld = NULL;
        -:  994://    int i = 0;
        -:  995://
        -:  996://    /* Our "days of the week" array: */
        -:  997://    const char *strings[7] =
        -:  998://            {
        -:  999://                    "Sunday",
        -: 1000://                    "Monday",
        -: 1001://                    "Tuesday",
        -: 1002://                    "Wednesday",
        -: 1003://                    "Thursday",
        -: 1004://                    "Friday",
        -: 1005://                    "Saturday"
        -: 1006://            };
        -: 1007://    /* Our matrix: */
        -: 1008://    int numbers[3][3] =
        -: 1009://            {
        -: 1010://                    {0, -1, 0},
        -: 1011://                    {1, 0, 0},
        -: 1012://                    {0 ,0, 1}
        -: 1013://            };
        -: 1014://    /* Our "gallery" item: */
        -: 1015://    int ids[4] = { 116, 943, 234, 38793 };
        -: 1016://    /* Our array of "records": */
        -: 1017://
        -: 1018://    root = cJSON_CreateObject();
        -: 1019://    cJSON_AddItemToObject(root, "name", cJSON_CreateString("Jack (\"Bee\") Nimble"));
        -: 1020://    cJSON_AddItemToObject(root, "format", fmt = cJSON_CreateObject());
        -: 1021://
        -: 1022://    cJSON *monitor = cJSON_CreateObject();
        -: 1023://    cJSON *name = NULL;
        -: 1024://    cJSON *resolutions = NULL;
        -: 1025://    cJSON *resolution = NULL;
        -: 1026://    resolutions = cJSON_CreateArray();
        -: 1027://
        -: 1028://    cJSON_AddItemToObject(monitor, "name", name);
        -: 1029://    cJSON_AddItemToObject(monitor, "name", name);
        -: 1030://    cJSON_AddItemToObject(monitor, "resolutions", resolutions);
        -: 1031://
        -: 1032://    cJSON *width = NULL;
        -: 1033://    cJSON *height = NULL;
        -: 1034://    const unsigned int resolution_numbers[3][2] = {
        -: 1035://            {1280, 720},
        -: 1036://            {1920, 1080},
        -: 1037://            {3840, 2160}
        -: 1038://    };
        -: 1039://    size_t index = 0;
        -: 1040://    width = cJSON_CreateNumber(resolution_numbers[index][0]);
        -: 1041://    cJSON_AddItemToObject(resolution, "width", width);
        -: 1042://
        -: 1043://    height = cJSON_CreateNumber(resolution_numbers[index][1]);
        -: 1044://    cJSON_AddItemToObject(resolution, "height", height);
        -: 1045://
        -: 1046://}
        -: 1047://
        5: 1048:TEST(CjsonFixture, assert_cJSON_AddItemToObjectCS)
        -: 1049:{
        1: 1050:    cJSON *item = cJSON_CreateString("item");
        1: 1051:    cJSON *sec_item = cJSON_CreateString("item");
        -: 1052://    cJSON_AddItemToObjectCS(item, "item", NULL);
        -: 1053://    cJSON_AddItemToObjectCS(item, NULL, item);
        1: 1054:    cJSON_AddItemToObjectCS(sec_item, "item", item);
        1: 1055:}
        -: 1056://
        5: 1057:TEST(CjsonFixture, assert_cJSON_AddItemReferenceToArray)
        -: 1058:{
        1: 1059:    cJSON *item = cJSON_CreateString("item");
        1: 1060:    cJSON *arr = cJSON_CreateArray();
        -: 1061:
        1: 1062:    cJSON_AddItemReferenceToArray(NULL, item);
        1: 1063:    cJSON_AddItemReferenceToArray(item, NULL);
        1: 1064:    cJSON_AddItemReferenceToArray(arr, item);
        1: 1065:}
        -: 1066://
        5: 1067:TEST(CjsonFixture, assert_cJSON_AddItemReferenceToObject)
        -: 1068:{
        1: 1069:    cJSON *item = cJSON_CreateString("item");
        -: 1070:
        1: 1071:    cJSON_AddItemReferenceToObject(item, "item", NULL);
        1: 1072:    cJSON_AddItemReferenceToObject(item, NULL, item);
        1: 1073:    cJSON_AddItemReferenceToObject(NULL, "item", item);
        1: 1074:}
        -: 1075://
        5: 1076:TEST(CjsonFixture, assert_cJSON_AddNullToObject)
        -: 1077:{
        1: 1078:    cJSON *root = cJSON_CreateObject();
        1: 1079:    cJSON *null = NULL;
        -: 1080:
        1: 1081:    cJSON_AddNullToObject(root, "null");
        1: 1082:    cJSON_AddNullToObject(NULL, "null");
        1: 1083:}
        -: 1084://
        5: 1085:TEST(CjsonFixture, assert_cJSON_AddTrueToObject)
        -: 1086:{
        1: 1087:    cJSON *root = cJSON_CreateObject();
        1: 1088:    cJSON_AddTrueToObject(NULL, "true");
        1: 1089:    cJSON_AddTrueToObject(root, NULL);
        1: 1090:    cJSON_AddTrueToObject(root, "true");
        1: 1091:}
        -: 1092://
        5: 1093:TEST(CjsonFixture, assert_cJSON_AddFalseToObject)
        -: 1094:{
        1: 1095:    cJSON *root = cJSON_CreateObject();
        1: 1096:    cJSON_AddFalseToObject(root, "false");
        1: 1097:    cJSON_AddFalseToObject(NULL, "false");
        1: 1098:    cJSON_AddFalseToObject(root, NULL);
        -: 1099:
        1: 1100:    cJSON *fmt = NULL;
        1: 1101:    cJSON_AddFalseToObject (fmt, "interlace");
        1: 1102:}
        -: 1103://
        5: 1104:TEST(CjsonFixture, assert_cJSON_AddBoolToObject)
        -: 1105:{
        1: 1106:    cJSON *root = cJSON_CreateObject();
        1: 1107:    cJSON_AddBoolToObject(root, "true", true);
        1: 1108:    cJSON_AddBoolToObject(root, "false", false);
        1: 1109:    cJSON_AddBoolToObject(NULL, "false", false);
        1: 1110:    cJSON_AddBoolToObject(root, NULL, false);
        1: 1111:    cJSON_AddBoolToObject(root, "false", false);
        1: 1112:}
        -: 1113://
        5: 1114:TEST(CjsonFixture, assert_cJSON_AddNumberToObject)
        -: 1115:{
        1: 1116:    cJSON *fmt = NULL;
        1: 1117:    cJSON_AddNumberToObject(fmt, "width", 1920);
        1: 1118:    cJSON_AddNumberToObject(fmt, "height", 1080);
        1: 1119:    cJSON_AddNumberToObject(fmt, "frame rate", 24);
        -: 1120:
        1: 1121:    cJSON *img = NULL;
        1: 1122:    cJSON *thm = NULL;
        1: 1123:    cJSON_AddNumberToObject(img, "Width", 800);
        1: 1124:    cJSON_AddNumberToObject(img, "Height", 600);
        1: 1125:    cJSON_AddNumberToObject(thm, "Height", 125);
        1: 1126:}
        -: 1127:
        5: 1128:TEST(CjsonFixture, assert_cJSON_AddStringToObject)
        -: 1129:{
        1: 1130:    cJSON *fmt = NULL;
        1: 1131:    cJSON *img = NULL;
        1: 1132:    cJSON *thm = NULL;
        -: 1133:
        1: 1134:    cJSON_AddStringToObject(fmt, "type", "rect");
        1: 1135:    cJSON_AddStringToObject(img, "Title", "View from 15th Floor");
        1: 1136:    cJSON_AddStringToObject(thm, "Url", "http:/*www.example.com/image/481989943");
        1: 1137:    cJSON_AddStringToObject(thm, "Width", "100");
        -: 1138:
        1: 1139:}
        -: 1140:
        -: 1141:
        5: 1142:TEST(CjsonFixture, assert_cJSON_AddRawToObject)
        -: 1143:{
        1: 1144:    cJSON *root = cJSON_CreateObject();
        1: 1145:    cJSON *raw = NULL;
        -: 1146:
        1: 1147:    cJSON_AddRawToObject(root, "raw", "{}");
        1: 1148:    cJSON_AddRawToObject(NULL, "raw", "{}");
        1: 1149:    cJSON_AddRawToObject(root, NULL, "{}");
        1: 1150:    cJSON_AddRawToObject(root, "raw", "{}");
        -: 1151:
        1: 1152:}
        -: 1153://
        5: 1154:TEST(CjsonFixture, assert_cJSON_AddObjectToObject)
        -: 1155:{
        1: 1156:    cJSON *root = cJSON_CreateObject();
        -: 1157:
        1: 1158:    cJSON_AddObjectToObject(root, "object");
        1: 1159:    cJSON_AddObjectToObject(NULL, "object");
        1: 1160:    cJSON_AddObjectToObject(root, NULL);
        1: 1161:}
        -: 1162://
        5: 1163:TEST(CjsonFixture, assert_cJSON_AddArrayToObject)
        -: 1164:{
        1: 1165:    cJSON *root = cJSON_CreateObject();
        1: 1166:    cJSON_AddArrayToObject(root, "array");
        -: 1167:
        1: 1168:    cJSON_AddArrayToObject(NULL, "array");
        1: 1169:    cJSON_AddArrayToObject(root, NULL);
        1: 1170:    cJSON_AddArrayToObject(root, "array");
        -: 1171:
        1: 1172:    cJSON *root1 = cJSON_Parse("{}");
        1: 1173:    cJSON_AddArrayToObject(root1, "rd");
        -: 1174:
        1: 1175:    cJSON *monitor = cJSON_CreateObject();
        1: 1176:    cJSON_AddArrayToObject(monitor, "resolutions");
        1: 1177:}
        -: 1178://
        5: 1179:TEST(CjsonFixture, assert_cJSON_DetachItemViaPointer)
        -: 1180:{
        -: 1181:    cJSON list[4];
        -: 1182:    cJSON parent[1];
        -: 1183:
        1: 1184:    memset(list, '\0', sizeof(list));
        -: 1185:
        -: 1186:    /* link the list */
        1: 1187:    list[0].next = &(list[1]);
        1: 1188:    list[1].next = &(list[2]);
        1: 1189:    list[2].next = &(list[3]);
        -: 1190:
        1: 1191:    list[3].prev = &(list[2]);
        1: 1192:    list[2].prev = &(list[1]);
        1: 1193:    list[1].prev = &(list[0]);
        1: 1194:    list[0].prev = &(list[3]);
        -: 1195:
        1: 1196:    parent->child = &list[0];
        1: 1197:    cJSON_DetachItemViaPointer(parent, &(list[1])) == &(list[1]);
        1: 1198:    cJSON_DetachItemViaPointer(parent, &(list[0])) == &(list[0]);
        1: 1199:}
        -: 1200://
        5: 1201:TEST(CjsonFixture, assert_cJSON_DetachItemFromArray)
        -: 1202:{
        1: 1203:    cJSON_DetachItemFromArray(NULL, 0);
        1: 1204:    cJSON_DetachItemFromArray(NULL, -1);
        1: 1205:}
        -: 1206://
        5: 1207:TEST(CjsonFixture, assert_cJSON_DeleteItemFromArray)
        -: 1208:{
        1: 1209:    cJSON_DeleteItemFromArray(NULL, 0);
        1: 1210:}
        -: 1211://
        5: 1212:TEST(CjsonFixture, assert_cJSON_DetachItemFromObject)
        -: 1213:{
        1: 1214:    cJSON *item = cJSON_CreateString("item");
        1: 1215:    cJSON_DetachItemFromObject(NULL, "item");
        1: 1216:    cJSON_DetachItemFromObject(item, NULL);
        1: 1217:    cJSON_DetachItemFromObjectCaseSensitive(NULL, "item");
        1: 1218:    cJSON_DetachItemFromObjectCaseSensitive(item, NULL);
        1: 1219:}
        -: 1220://
        5: 1221:TEST(CjsonFixture, assert_cJSON_DeleteItemFromObject)
        -: 1222:{
        1: 1223:    cJSON *item = cJSON_CreateString("item");
        1: 1224:    cJSON_DeleteItemFromObject(NULL, "item");
        1: 1225:    cJSON_DeleteItemFromObject(item, NULL);
        1: 1226:    cJSON_DeleteItemFromObjectCaseSensitive(NULL, "item");
        1: 1227:    cJSON_DeleteItemFromObjectCaseSensitive(item, NULL);
        1: 1228:}
        -: 1229://
        5: 1230:TEST(CjsonFixture, assert_cJSON_InsertItemInArray)
        -: 1231:{
        1: 1232:    cJSON *item = cJSON_CreateString("item");
        1: 1233:    cJSON *newitem = cJSON_CreateString("item");
        1: 1234:    cJSON_InsertItemInArray(NULL, 0, item);
        1: 1235:    cJSON_InsertItemInArray(item, 0, NULL);
        1: 1236:    cJSON_InsertItemInArray(item, -1, NULL);
        1: 1237:    cJSON_InsertItemInArray(item, 0, newitem);
        1: 1238:}
        -: 1239://
        5: 1240:TEST(CjsonFixture, assert_cJSON_ReplaceItemViaPointer)
        -: 1241:{
        -: 1242:    cJSON replacements[3];
        1: 1243:    cJSON *beginning = NULL;
        1: 1244:    cJSON *middle = NULL;
        1: 1245:    cJSON *end = NULL;
        1: 1246:    cJSON *array = NULL;
        -: 1247:
        1: 1248:    beginning = cJSON_CreateNull();
        1: 1249:    ASSERT_TRUE(beginning!=NULL);
        1: 1250:    middle = cJSON_CreateNull();
        1: 1251:    ASSERT_TRUE(middle!=NULL);
        1: 1252:    end = cJSON_CreateNull();
        1: 1253:    ASSERT_TRUE(end!=NULL);
        -: 1254:
        1: 1255:    array = cJSON_CreateArray();
        1: 1256:    ASSERT_TRUE(array!=NULL);
        -: 1257:
        1: 1258:    cJSON_AddItemToArray(array, beginning);
        1: 1259:    cJSON_AddItemToArray(array, middle);
        1: 1260:    cJSON_AddItemToArray(array, end);
        -: 1261:
        -: 1262:
        1: 1263:    memset(replacements, '\0', sizeof(replacements));
        -: 1264:
        -: 1265:
        1: 1266:    cJSON_ReplaceItemViaPointer(array, beginning, beginning);
        1: 1267:    cJSON_ReplaceItemViaPointer(array, middle, &(replacements[1]));
        1: 1268:    cJSON_ReplaceItemViaPointer(array, end, &(replacements[2]));
        -: 1269:
        1: 1270:    cJSON *item = cJSON_CreateString("item");
        1: 1271:    cJSON_ReplaceItemViaPointer(NULL, item, item);
        1: 1272:    cJSON_ReplaceItemViaPointer(item, NULL, item);
        1: 1273:    cJSON_ReplaceItemViaPointer(item, item, NULL);
        -: 1274:
        1: 1275:    cJSON_ReplaceItemInArray(NULL, 0, item);
        1: 1276:    cJSON_ReplaceItemInArray(item, 0, NULL);
        1: 1277:    cJSON_ReplaceItemInArray(item, -1, NULL);
        1: 1278:    cJSON *root = NULL;
        1: 1279:    root = cJSON_CreateArray();
        1: 1280:    cJSON_ReplaceItemInArray(root, 1, cJSON_CreateString("Replacement"));
        -: 1281:}
        -: 1282://
        5: 1283:TEST(CjsonFixture, assert_cJSON_ReplaceItemInObject)
        -: 1284:{
        -: 1285:
        1: 1286:    cJSON root[1] = {{ NULL, NULL, NULL, 0, NULL, 0, 0, NULL }};
        1: 1287:    cJSON *replacement = NULL;
        1: 1288:    cJSON_ReplaceItemInObject(root, "child", replacement);
        -: 1289:
        1: 1290:    cJSON *item = cJSON_CreateString("item");
        -: 1291:
        -: 1292:
        1: 1293:    cJSON_ReplaceItemInObject(NULL, "item", item) ;
        1: 1294:    cJSON_ReplaceItemInObject(item, NULL, item);
        1: 1295:    cJSON_ReplaceItemInObject(item, "item", NULL);
        -: 1296:
        -: 1297:
        1: 1298:    cJSON_ReplaceItemInObjectCaseSensitive(NULL, "item", item);
        1: 1299:    cJSON_ReplaceItemInObjectCaseSensitive(item, NULL, item);
        1: 1300:    cJSON_ReplaceItemInObjectCaseSensitive(item, "item", NULL);
        1: 1301:}
        -: 1302://
        5: 1303:TEST(CjsonFixture, assert_cJSON_CreateStringReference)
        -: 1304:{
        1: 1305:    const char *string = "I am a string!";
        1: 1306:    cJSON_CreateStringReference(string);
        1: 1307:}
        -: 1308://
        5: 1309:TEST(CjsonFixture, assert_cJSON_CreateObjectReference)
        -: 1310:{
        1: 1311:    cJSON *number = cJSON_CreateNumber(42);
        1: 1312:    cJSON_CreateObjectReference(number);
        1: 1313:    cJSON_CreateArrayReference(number);
        -: 1314:
        1: 1315:    int numbers[3][3] =
        -: 1316:            {
        -: 1317:                    {0, -1, 0},
        -: 1318:                    {1, 0, 0},
        -: 1319:                    {0 ,0, 1}
        -: 1320:            };
        4: 1321:    for (int i = 0; i < 3; i++){
        3: 1322:        cJSON_CreateIntArray(numbers[i], 3);
        -: 1323:    }
        -: 1324:
        1: 1325:    cJSON_CreateIntArray(numbers[1], -3);
        -: 1326:
        1: 1327:    cJSON_CreateFloatArray(NULL, 10);
        -: 1328:
        1: 1329:    float number1=3;
        1: 1330:    cJSON_CreateFloatArray(&number1, 10);
        -: 1331://    ASSERT_NULL(cJSON_CreateFloatArray(NULL, 10));    ASSERT如何写
        -: 1332:
        1: 1333:}
        -: 1334://
        5: 1335:TEST(CjsonFixture, assert_cJSON_CreateDoubleArray)
        -: 1336:{
        -: 1337://    ASSERT_NULL(cJSON_CreateDoubleArray(NULL, 10));
        1: 1338:    cJSON_CreateDoubleArray(NULL, 10);
        -: 1339:
        1: 1340:    double number1=3;
        1: 1341:    cJSON_CreateDoubleArray(&number1, 10);
        1: 1342:}
        -: 1343://
        -: 1344://
        5: 1345:TEST(CjsonFixture, assert_cJSON_CreateStringArray)
        -: 1346:{
        -: 1347://    TEST_ASSERT_NULL(cJSON_CreateStringArray(NULL, 10));
        1: 1348:    cJSON_CreateStringArray(NULL, 10);
        -: 1349:
        1: 1350:    const char *strings[7] =
        -: 1351:            {
        -: 1352:                    "Sunday",
        -: 1353:                    "Monday",
        -: 1354:                    "Tuesday",
        -: 1355:                    "Wednesday",
        -: 1356:                    "Thursday",
        -: 1357:                    "Friday",
        -: 1358:                    "Saturday"
        -: 1359:            };
        1: 1360:    cJSON_CreateStringArray(strings, 7);
        1: 1361:}
        -: 1362://
        -: 1363://
        -: 1364://
        -: 1365://
        5: 1366:TEST(CjsonFixture, assert_cJSON_Duplicate)
        -: 1367:{
        -: 1368://    TEST_ASSERT_NULL(cJSON_Duplicate(NULL, true));
        1: 1369:    cJSON_Duplicate(NULL, true);
        -: 1370:
        1: 1371:    cJSON *doc = NULL;
        1: 1372:    cJSON *patch = NULL;
        1: 1373:    cJSON *expected = NULL;
        1: 1374:    cJSON *error_element = NULL;
        1: 1375:    cJSON *comment = NULL;
        1: 1376:    cJSON *disabled = NULL;
        -: 1377:
        1: 1378:    cJSON *object = NULL;
        1: 1379:    cJSON_bool successful = false;
        -: 1380:
        1: 1381:    cJSON *test=cJSON_CreateString("test");
        -: 1382:
        1: 1383:    object = cJSON_Duplicate(test, true);
        -: 1384:
        1: 1385:    cJSON *array = cJSON_CreateArray();
        1: 1386:    ASSERT_TRUE(array!=NULL);
        -: 1387:
        1: 1388:    cJSON_AddItemToArray(array, test);
        1: 1389:    object = cJSON_Duplicate(array, true);
        -: 1390:}
        -: 1391://
        5: 1392:TEST(CjsonFixture, assert_cJSON_Minify)
        -: 1393:{
        -: 1394:
        1: 1395:    char unclosed_multiline_comment[] = "\" /* bla";
        1: 1396:    char pending_escape[] = "\"\\";
        -: 1397:
        1: 1398:    cJSON_Minify(unclosed_multiline_comment);
        1: 1399:    cJSON_Minify(pending_escape);
        -: 1400:
        1: 1401:    const char to_minify[] = "{// this is {} \"some kind\" of [] comment /*, don't you see\n}";
        -: 1402:
        1: 1403:    char* minified = (char*) malloc(sizeof(to_minify));
        1: 1404:    ASSERT_TRUE(minified!=NULL);
        1: 1405:    strcpy(minified, to_minify);
        -: 1406:
        1: 1407:    cJSON_Minify(minified);
        1: 1408:    free(minified);
        -: 1409:
        -: 1410:
        -: 1411://    char unclosed_multiline_comment[] = "/* bla";
        -: 1412://    cJSON_Minify(unclosed_multiline_comment);
        -: 1413://
        -: 1414://    char pending_escape[] = "\"\\";
        -: 1415://    cJSON_Minify(pending_escape);
        -: 1416://
        -: 1417://
        -: 1418://    const char to_minify[] = "{// this is {} \"some kind\" of [] comment /*, don't you see\n}";
        -: 1419://
        -: 1420://    char* minified = (char*) malloc(sizeof(to_minify));
        -: 1421://    cJSON_Minify(minified);
        -: 1422://
        -: 1423://    const char to_minify2[] = "{ \"key\":\ttrue\r\n    }";
        -: 1424://    char* minified2 = (char*) malloc(sizeof(to_minify2));
        -: 1425://    cJSON_Minify(minified2);
        -: 1426://
        -: 1427://    const char to_minify3[] = "{/* this is\n a /* multi\n //line \n {comment \"\\\" */}";
        -: 1428://    char* minified3 = (char*) malloc(sizeof(to_minify3));
        -: 1429://    cJSON_Minify(minified3);
        -: 1430://
        -: 1431://    const char to_minify4[] = "\"this is a string \\\" \\t bla\"";
        -: 1432://    char* minified4 = (char*) malloc(sizeof(to_minify4));
        -: 1433://    cJSON_Minify(minified4);
        -: 1434://
        -: 1435://    char string[] = { '8', ' ', '/', ' ', '5', '\n', '\0' };
        -: 1436://    /* this should not be an infinite loop */
        -: 1437://    cJSON_Minify(string);
        -: 1438://
        -: 1439://    const char to_minify5[] =
        -: 1440://            "{\n"
        -: 1441://            "    \"glossary\": { // comment\n"
        -: 1442://            "        \"title\": \"example glossary\",\n"
        -: 1443://            "  /* multi\n"
        -: 1444://            " line */\n"
        -: 1445://            "   \"GlossDiv\": {\n"
        -: 1446://            "            \"title\": \"S\",\n"
        -: 1447://            "     \"GlossList\": {\n"
        -: 1448://            "                \"GlossEntry\": {\n"
        -: 1449://            "                    \"ID\": \"SGML\",\n"
        -: 1450://            "         \"SortAs\": \"SGML\",\n"
        -: 1451://            "         \"Acronym\": \"SGML\",\n"
        -: 1452://            "         \"Abbrev\": \"ISO 8879:1986\",\n"
        -: 1453://            "         \"GlossDef\": {\n"
        -: 1454://            "           \"GlossSeeAlso\": [\"GML\", \"XML\"]\n"
        -: 1455://            "                    },\n"
        -: 1456://            "         \"GlossSee\": \"markup\"\n"
        -: 1457://            "                }\n"
        -: 1458://            "            }\n"
        -: 1459://            "        }\n"
        -: 1460://            "    }\n"
        -: 1461://            "}";
        -: 1462://
        -: 1463://
        -: 1464://    char *buffer = (char*) malloc(sizeof(to_minify5));
        -: 1465://    cJSON_Minify(buffer);
        -: 1466:}
        -: 1467://
        5: 1468:TEST(CjsonFixture, assert_cJSON_IsInvalid)
        -: 1469:{
        -: 1470://    TEST_ASSERT_FALSE(cJSON_IsInvalid(NULL));
        -: 1471://    TEST_ASSERT_FALSE(cJSON_IsInvalid(item));
        1: 1472:    cJSON_IsInvalid(NULL);
        1: 1473:    cJSON_IsInvalid(item);
        1: 1474:}
        -: 1475:
        5: 1476:TEST(CjsonFixture, assert_cJSON_IsFalse)
        -: 1477:{
        -: 1478://    TEST_ASSERT_FALSE(cJSON_IsFalse(NULL));
        -: 1479://    TEST_ASSERT_FALSE(cJSON_IsFalse(invalid));
        -: 1480://    TEST_ASSERT_TRUE(cJSON_IsFalse(item));
        -: 1481:
        1: 1482:    item->type = cJSON_False;
        -: 1483:    cJSON invalid[1];
        1: 1484:    cJSON_IsFalse(NULL);
        1: 1485:    cJSON_IsFalse(invalid);
        1: 1486:    cJSON_IsFalse(item);
        1: 1487:}
        -: 1488:
        5: 1489:TEST(CjsonFixture, assert_cJSON_IsTrue)
        -: 1490:{
        -: 1491://   TEST_ASSERT_FALSE(cJSON_IsTrue(NULL));
        -: 1492://    TEST_ASSERT_FALSE(cJSON_IsTrue(invalid));
        -: 1493://    TEST_ASSERT_TRUE(cJSON_IsTrue(item));
        -: 1494:
        1: 1495:    item->type = cJSON_True;
        -: 1496:    cJSON invalid[1];
        1: 1497:    cJSON_IsTrue(NULL);
        1: 1498:    cJSON_IsTrue(invalid);
        1: 1499:    cJSON_IsTrue(item);
        1: 1500:}
        -: 1501:
        5: 1502:TEST(CjsonFixture, assert_cJSON_IsBool)
        -: 1503:{
        -: 1504://   TEST_ASSERT_TRUE(cJSON_IsBool(item));
        -: 1505:
        1: 1506:    cJSON_IsBool(item);
        1: 1507:    cJSON_IsBool(NULL);
        1: 1508:}
        -: 1509:
        5: 1510:TEST(CjsonFixture, assert_cJSON_IsNull)
        -: 1511:{
        -: 1512://    TEST_ASSERT_FALSE(cJSON_IsNull(NULL));
        -: 1513://    TEST_ASSERT_TRUE(cJSON_IsNull(item));
        1: 1514:    item->type = cJSON_NULL;
        1: 1515:    cJSON_IsNull(NULL);
        1: 1516:    cJSON_IsNull(item);
        1: 1517:}
        -: 1518:
        5: 1519:TEST(CjsonFixture, assert_cJSON_IsNumber)
        -: 1520:{
        -: 1521://    TEST_ASSERT_FALSE(cJSON_IsNumber(NULL));
        -: 1522://    TEST_ASSERT_FALSE(cJSON_IsNumber(invalid));
        -: 1523://    TEST_ASSERT_TRUE(cJSON_IsNumber(item));
        -: 1524:
        1: 1525:    item->type = cJSON_Number;
        -: 1526:    cJSON invalid[1];
        1: 1527:    cJSON_IsNumber(NULL);
        1: 1528:    cJSON_IsNumber(invalid);
        1: 1529:    cJSON_IsNumber(item);
        1: 1530:}
        -: 1531:
        5: 1532:TEST(CjsonFixture, assert_cJSON_IsString)
        -: 1533:{
        -: 1534://    TEST_ASSERT_FALSE(cJSON_IsString(NULL));
        -: 1535://    TEST_ASSERT_FALSE(cJSON_IsString(invalid));
        -: 1536://    TEST_ASSERT_TRUE(cJSON_IsString(item));
        -: 1537:
        1: 1538:    item->type = cJSON_String;
        -: 1539:    cJSON invalid[1];
        1: 1540:    cJSON_IsString(NULL);
        1: 1541:    cJSON_IsString(invalid);
        1: 1542:    cJSON_IsString(item);
        1: 1543:}
        -: 1544:
        5: 1545:TEST(CjsonFixture, assert_cJSON_IsArray)
        -: 1546:{
        -: 1547://    TEST_ASSERT_FALSE(cJSON_IsArray(NULL));
        -: 1548://    TEST_ASSERT_FALSE(cJSON_IsArray(invalid));
        -: 1549://    TEST_ASSERT_TRUE(cJSON_IsArray(item));
        -: 1550:
        1: 1551:    item->type = cJSON_Array;
        -: 1552:    cJSON invalid[1];
        1: 1553:    cJSON_IsArray(NULL);
        1: 1554:    cJSON_IsArray(invalid);
        1: 1555:    cJSON_IsArray(item);
        1: 1556:}
        -: 1557:
        5: 1558:TEST(CjsonFixture, assert_cJSON_IsObject)
        -: 1559:{
        -: 1560://    TEST_ASSERT_FALSE(cJSON_IsObject(NULL));
        -: 1561://    TEST_ASSERT_FALSE(cJSON_IsObject(invalid));
        -: 1562://    TEST_ASSERT_TRUE(cJSON_IsObject(item));
        -: 1563:
        1: 1564:    item->type = cJSON_Object;
        -: 1565:    cJSON invalid[1];
        1: 1566:    cJSON_IsObject(NULL);
        1: 1567:    cJSON_IsObject(invalid);
        1: 1568:    cJSON_IsObject(item);
        1: 1569:}
        -: 1570:
        5: 1571:TEST(CjsonFixture, assert_cJSON_IsRaw)
        -: 1572:{
        -: 1573://    TEST_ASSERT_FALSE(cJSON_cJSON_IsRaw(NULL));
        -: 1574://    TEST_ASSERT_FALSE(cJSON_cJSON_IsRaw(invalid));
        -: 1575://    TEST_ASSERT_TRUE(cJSON_cJSON_IsRaw(item));
        -: 1576:
        1: 1577:    item->type = cJSON_Object;
        -: 1578:    cJSON invalid[1];
        1: 1579:    cJSON_IsRaw(NULL);
        1: 1580:    cJSON_IsRaw(invalid);
        1: 1581:    cJSON_IsRaw(item);
        1: 1582:}
        -: 1583://
       40: 1584:static cJSON_bool compare_from_string(const char * const a, const char * const b, const cJSON_bool case_sensitive)
        -: 1585:{
       40: 1586:    cJSON *a_json = NULL;
       40: 1587:    cJSON *b_json = NULL;
       40: 1588:    cJSON_bool result = false;
        -: 1589:
       40: 1590:    a_json = cJSON_Parse(a);
       40: 1591:    EXPECT_TRUE( a_json!= NULL);
        -: 1592://    TEST_ASSERT_NOT_NULL_MESSAGE(a_json, "Failed to parse a.");
       40: 1593:    b_json = cJSON_Parse(b);
       40: 1594:    EXPECT_TRUE( b_json!= NULL);
        -: 1595://    TEST_ASSERT_NOT_NULL_MESSAGE(b_json, "Failed to parse b.");
        -: 1596:
       40: 1597:    result = cJSON_Compare(a_json, b_json, case_sensitive);
        -: 1598:
       40: 1599:    cJSON_Delete(a_json);
       40: 1600:    cJSON_Delete(b_json);
        -: 1601:
       40: 1602:    return result;
        -: 1603:}
        -: 1604:
        5: 1605:TEST(CjsonFixture, cJSON_Compare)
        -: 1606:{
        1: 1607:    cJSON_Compare(NULL, NULL, true);
        1: 1608:    cJSON_Compare(NULL, NULL, false);
        -: 1609:    cJSON invalid[1];
        1: 1610:    memset(invalid, '\0', sizeof(invalid));
        -: 1611:
        1: 1612:    cJSON_Compare(invalid, invalid, false);
        1: 1613:    cJSON_Compare(invalid, invalid, true);
        -: 1614://    TEST_ASSERT_FALSE(cJSON_Compare(invalid, invalid, false));
        -: 1615://    TEST_ASSERT_FALSE(cJSON_Compare(invalid, invalid, true));
        -: 1616:
        1: 1617:    compare_from_string("1", "1", true);
        1: 1618:    compare_from_string("1", "1", false);
        1: 1619:    compare_from_string("0.0001", "0.0001", true);
        1: 1620:    compare_from_string("0.0001", "0.0001", false);
        1: 1621:    compare_from_string("1", "2", true);
        1: 1622:    compare_from_string("1", "2", false);
        1: 1623:    compare_from_string("true", "true", true);
        1: 1624:    compare_from_string("true", "true", false);
        1: 1625:    compare_from_string("false", "false", true);
        1: 1626:    compare_from_string("false", "false", false);
        -: 1627://
        1: 1628:    compare_from_string("true", "true", true);
        1: 1629:    compare_from_string("true", "true", false);
        1: 1630:    compare_from_string("false", "false", true);
        1: 1631:    compare_from_string("false", "false", false);
        -: 1632:
        1: 1633:    compare_from_string("null", "null", true);
        1: 1634:    compare_from_string("null", "null", false);
        -: 1635:
        1: 1636:    compare_from_string("null", "true", true);
        1: 1637:    compare_from_string("null", "true", false);
        -: 1638://
        1: 1639:    reset(invalid);
        1: 1640:    memset(invalid, '\0', sizeof(invalid));
        -: 1641:
        1: 1642:    invalid->type = cJSON_Number | cJSON_String;
        -: 1643:
        1: 1644:    cJSON_Compare(invalid, invalid, true);
        1: 1645:    cJSON_Compare(invalid, invalid, false);
        -: 1646://
        1: 1647:    compare_from_string("\"abcdefg\"", "\"abcdefg\"", true);
        1: 1648:    compare_from_string("\"abcdefg\"", "\"abcdefg\"", false);
        -: 1649:
        1: 1650:    compare_from_string("\"ABCDEFG\"", "\"abcdefg\"", true);
        1: 1651:    compare_from_string("\"ABCDEFG\"", "\"abcdefg\"", false);
        -: 1652://
        1: 1653:    cJSON *raw1 = NULL;
        1: 1654:    cJSON *raw2 = NULL;
        -: 1655:
        1: 1656:    raw1 = cJSON_Parse("\"[true, false]\"");
        -: 1657://    TEST_ASSERT_NOT_NULL(raw1);
        1: 1658:    raw2 = cJSON_Parse("\"[true, false]\"");
        -: 1659://    TEST_ASSERT_NOT_NULL(raw2);
        -: 1660:
        1: 1661:    raw1->type = cJSON_Raw;
        1: 1662:    raw2->type = cJSON_Raw;
        -: 1663:
        1: 1664:    cJSON_Compare(raw1, raw2, true);
        1: 1665:    cJSON_Compare(raw1, raw2, false);
        -: 1666:
        1: 1667:    cJSON_Delete(raw1);
        1: 1668:    cJSON_Delete(raw2);
        -: 1669://
        1: 1670:    compare_from_string("[]", "[]", true);
        1: 1671:    compare_from_string("[]", "[]", false);
        1: 1672:    compare_from_string("[false,true,null,42,\"string\",[],{}]", "[false, true, null, 42, \"string\", [], {}]", true);
        1: 1673:    compare_from_string("[false,true,null,42,\"string\",[],{}]", "[false, true, null, 42, \"string\", [], {}]", false);
        1: 1674:    compare_from_string("[[[1], 2]]", "[[[1], 2]]", true);
        1: 1675:    compare_from_string("[[[1], 2]]", "[[[1], 2]]", false);
        -: 1676:
        1: 1677:    ASSERT_FALSE(compare_from_string("[true,null,42,\"string\",[],{}]", "[false, true, null, 42, \"string\", [], {}]", true));
        1: 1678:    ASSERT_FALSE(compare_from_string("[true,null,42,\"string\",[],{}]", "[false, true, null, 42, \"string\", [], {}]", false));
        -: 1679:
        1: 1680:    ASSERT_FALSE(compare_from_string("[1,2,3]", "[1,2]", true));
        1: 1681:    ASSERT_FALSE(compare_from_string("[1,2,3]", "[1,2]", false));
        -: 1682:
        1: 1683:    ASSERT_TRUE(compare_from_string("{}", "{}", true));
        1: 1684:    ASSERT_TRUE(compare_from_string("{}", "{}", false));
        1: 1685:    ASSERT_TRUE(compare_from_string(
        -: 1686:            "{\"false\": false, \"true\": true, \"null\": null, \"number\": 42, \"string\": \"string\", \"array\": [], \"object\": {}}",
        -: 1687:            "{\"true\": true, \"false\": false, \"null\": null, \"number\": 42, \"string\": \"string\", \"array\": [], \"object\": {}}",
        -: 1688:            true));
        1: 1689:    ASSERT_FALSE(compare_from_string(
        -: 1690:            "{\"False\": false, \"true\": true, \"null\": null, \"number\": 42, \"string\": \"string\", \"array\": [], \"object\": {}}",
        -: 1691:            "{\"true\": true, \"false\": false, \"null\": null, \"number\": 42, \"string\": \"string\", \"array\": [], \"object\": {}}",
        -: 1692:            true));
        1: 1693:    ASSERT_TRUE(compare_from_string(
        -: 1694:            "{\"False\": false, \"true\": true, \"null\": null, \"number\": 42, \"string\": \"string\", \"array\": [], \"object\": {}}",
        -: 1695:            "{\"true\": true, \"false\": false, \"null\": null, \"number\": 42, \"string\": \"string\", \"array\": [], \"object\": {}}",
        -: 1696:            false));
        1: 1697:    ASSERT_FALSE(compare_from_string(
        -: 1698:            "{\"Flse\": false, \"true\": true, \"null\": null, \"number\": 42, \"string\": \"string\", \"array\": [], \"object\": {}}",
        -: 1699:            "{\"true\": true, \"false\": false, \"null\": null, \"number\": 42, \"string\": \"string\", \"array\": [], \"object\": {}}",
        -: 1700:            false));
        1: 1701:    ASSERT_FALSE(compare_from_string(
        -: 1702:            "{\"one\": 1, \"two\": 2}",
        -: 1703:            "{\"one\": 1, \"two\": 2, \"three\": 3}",
        -: 1704:            true));
        1: 1705:    ASSERT_FALSE(compare_from_string(
        -: 1706:            "{\"one\": 1, \"two\": 2}",
        -: 1707:            "{\"one\": 1, \"two\": 2, \"three\": 3}",
        -: 1708:            false));
        -: 1709:}
        -: 1710:
        5: 1711:TEST(CjsonFixture2, assert_cJSON_free)
        -: 1712:{
        -: 1713://    cJSON *array = NULL;
        -: 1714://    array = cJSON_CreateArray();
        -: 1715://    cJSON_free(array);
        -: 1716:
        1: 1717:    parse_buffer buffer = { 0, 0, 0, 0, { 0, 0, 0 } };
        1: 1718:    buffer.content = (const unsigned char*)"[]";
        1: 1719:    buffer.length = strlen("[]") + sizeof("");
        1: 1720:    buffer.hooks = global_hooks;
        -: 1721:
        1: 1722:    cJSON *new_item =  cJSON_New_Item(&(buffer.hooks));
        -: 1723:
        1: 1724:    ASSERT_TRUE(new_item!=NULL);
        -: 1725:
        1: 1726:    cJSON *raw1 = NULL;
        1: 1727:    cJSON *raw2 = NULL;
        -: 1728:
        1: 1729:    raw1 = cJSON_Parse("\"[true, false]\"");
        -: 1730:
        1: 1731:    ASSERT_TRUE(raw1!=NULL);
        -: 1732:}
        -: 1733:
    #####: 1734:static void * CJSON_CDECL failing_malloc(size_t size)
        -: 1735:{
        -: 1736:    (void)size;
    #####: 1737:    return NULL;
        -: 1738:}
        -: 1739://
        -: 1740:///* work around MSVC error C2322: '...' address of dillimport '...' is not static */
    #####: 1741:static void CJSON_CDECL normal_free(void *pointer)
        -: 1742:{
    #####: 1743:    free(pointer);
    #####: 1744:}
        -: 1745:static cJSON_Hooks failing_hooks={
        -: 1746:        failing_malloc,
        -: 1747:        normal_free
        -: 1748:};
        -: 1749://
        -: 1750:
        5: 1751:TEST(CjsonFixture, assert_cJSON_InitHooks)
        -: 1752:{
        1: 1753:    cJSON_InitHooks(&failing_hooks);
        1: 1754:    cJSON_InitHooks(NULL);
        -: 1755:
        1: 1756:    failing_hooks.malloc_fn=NULL;
        1: 1757:    cJSON_InitHooks(&failing_hooks);
        1: 1758:    failing_hooks.free_fn =NULL;
        1: 1759:    global_hooks.deallocate=NULL;
        1: 1760:    cJSON_InitHooks(&failing_hooks);
        1: 1761:    failing_hooks.free_fn =NULL;
        1: 1762:    global_hooks.allocate=NULL;
        1: 1763:    cJSON_InitHooks(&failing_hooks);
        -: 1764:
        1: 1765:    global_hooks.deallocate=free;
        1: 1766:    cJSON_InitHooks(&failing_hooks);
        1: 1767:    global_hooks.allocate=malloc;
        1: 1768:}
        -: 1769:
        5: 1770:static void assert_parse_string(const char *string, const char *expected)
        -: 1771:{
        5: 1772:    parse_buffer buffer = { 0, 0, 0, 0, { 0, 0, 0 } };
        5: 1773:    buffer.content = (const unsigned char*)string;
        5: 1774:    buffer.length = strlen(string) + sizeof("");
        5: 1775:    buffer.hooks = global_hooks;
        -: 1776:
        5: 1777:    ASSERT_TRUE(parse_string(item, &buffer));
        5: 1778:    global_hooks.deallocate(item->valuestring);
        5: 1779:    item->valuestring = NULL;
        -: 1780:}
        -: 1781:
        5: 1782:static void assert_not_parse_string(const char * const string)
        -: 1783:{
        5: 1784:    parse_buffer buffer = { 0, 0, 0, 0, { 0, 0, 0 } };
        5: 1785:    buffer.content = (const unsigned char*)string;
        5: 1786:    buffer.length = strlen(string) + sizeof("");
        5: 1787:    buffer.hooks = global_hooks;
        -: 1788:
        5: 1789:    parse_string(item, &buffer);
        5: 1790:}
        -: 1791:
        5: 1792:TEST(CjsonFixture, parse_string){
        1: 1793:    assert_not_parse_string("this\" is not a string\"");
        1: 1794:    reset(item);
        1: 1795:    assert_not_parse_string("");
        1: 1796:    reset(item);
        1: 1797:    assert_not_parse_string("Abcdef\\123");
        1: 1798:    reset(item);
        1: 1799:    assert_not_parse_string("Abcdef\\e23");
        1: 1800:    reset(item);
        1: 1801:    assert_not_parse_string("\"000000000000000000\\");
        1: 1802:    reset(item);
        -: 1803:
        1: 1804:    assert_parse_string("\"\"", "");
        1: 1805:    assert_parse_string(
        -: 1806:            "\" !\\\"#$%&'()*+,-./\\/0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_'abcdefghijklmnopqrstuvwxyz{|}~\"",
        -: 1807:            " !\"#$%&'()*+,-.//0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_'abcdefghijklmnopqrstuvwxyz{|}~");
        1: 1808:    assert_parse_string(
        -: 1809:            "\"\\\"\\\\\\/\\b\\f\\n\\r\\t\\u20AC\\u732b\"",
        -: 1810:            "\"\\/\b\f\n\r\t€猫");
        1: 1811:    reset(item);
        1: 1812:    assert_parse_string("\"\b\f\n\r\t\"", "\b\f\n\r\t");
        1: 1813:    reset(item);
        -: 1814:
        1: 1815:    assert_parse_string("\"\\uD83D\\udc31\"", "🐱");
        1: 1816:    reset(item);
        1: 1817:}
        5: 1818:TEST(CjsonFixture, parse_hex4){
        1: 1819:    unsigned int number = 0;
        -: 1820:    unsigned char digits_lower[6];
        -: 1821:    unsigned char digits_upper[6];
        -: 1822:    /* test all combinations */
    65537: 1823:    for (number = 0; number <= 0xFFFF; number++)
        -: 1824:    {
    65536: 1825:        sprintf((char*)digits_lower, "%.4x", number);
    65536: 1826:        sprintf((char*)digits_upper, "%.4X", number);
        -: 1827:
    65536: 1828:        ASSERT_EQ(parse_hex4(digits_lower),number);
    65536: 1829:        ASSERT_EQ(parse_hex4(digits_upper),number);
        -: 1830:    }
        -: 1831:
        1: 1832:    parse_hex4((const unsigned char*)"beef");
        1: 1833:    parse_hex4((const unsigned char*)"wbeef");
        3: 1834:}
