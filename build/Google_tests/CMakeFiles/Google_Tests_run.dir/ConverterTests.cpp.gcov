        -:    0:Source:/mnt/d/CLionProjects/Cjson_withTests/Google_tests/ConverterTests.cpp
        -:    0:Graph:ConverterTests.cpp.gcno
        -:    0:Data:ConverterTests.cpp.gcda
        -:    0:Runs:4
        -:    0:Programs:1
        -:    1:#include "gtest/gtest.h"
        -:    2:#include "cJSON.h"
        -:    3:#include "../Cjson_lib/cJSON.c"
        -:    4:
        -:    5:static cJSON item[1];
       88:    6:void reset(cJSON *item) {
       88:    7:    if ((item != NULL) && (item->child != NULL))
        -:    8:    {
       48:    9:        cJSON_Delete(item->child);
        -:   10:    }
       88:   11:    if ((item->valuestring != NULL) && !(item->type & cJSON_IsReference))
        -:   12:    {
    #####:   13:        global_hooks.deallocate(item->valuestring);
        -:   14:    }
       88:   15:    if ((item->string != NULL) && !(item->type & cJSON_StringIsConst))
        -:   16:    {
    #####:   17:        global_hooks.deallocate(item->string);
        -:   18:    }
        -:   19:
       88:   20:    memset(item, 0, sizeof(cJSON));
       88:   21:}
        -:   22:
        -:   23:
       80:   24:class CjsonFixture : public ::testing::Test {
        -:   25:
        -:   26:protected:
       40:   27:    virtual void SetUp()
        -:   28:    {
       40:   29:        memset(item, 0, sizeof(cJSON));
        -:   30://        gregDate = new GregorianDate();
        -:   31://        julDate = new JulianDate();
       40:   32:    }
        -:   33:
       40:   34:    virtual void TearDown() {
        -:   35://        delete gregDate;
        -:   36://        delete julDate;
       40:   37:        reset(item);
       40:   38:    }
        -:   39:
        -:   40://    GregorianDate * gregDate;
        -:   41://    JulianDate * julDate;
        -:   42:};
        -:   43:
       32:   44:static void assert_not_in_list(cJSON *object_item){
       32:   45:    ASSERT_TRUE(object_item->next==NULL);
       32:   46:    ASSERT_TRUE(object_item->prev==NULL);
        -:   47:}
       56:   48:static void assert_has_type(cJSON *object_item, int expect_type){
       56:   49:    ASSERT_TRUE((0xff & (object_item->type))==(0xff & expect_type));
        -:   50:}
       32:   51:static void assert_has_no_reference(cJSON *object_item){
       32:   52:    ASSERT_TRUE((cJSON_IsReference & (object_item->type))==(cJSON_IsReference & 0));
        -:   53:}
       32:   54:static void assert_has_no_const_string(cJSON *object_item){
       32:   55:    ASSERT_TRUE((cJSON_StringIsConst & (object_item->type))==(cJSON_StringIsConst & 0));
        -:   56:}
       32:   57:static void assert_is_object(cJSON *object_item)
        -:   58:{
        -:   59://    TEST_ASSERT_NOT_NULL_MESSAGE(object_item, "Item is NULL.");
       32:   60:    ASSERT_TRUE(object_item!=NULL);
        -:   61:
       32:   62:    assert_not_in_list(object_item);
       32:   63:    assert_has_type(object_item, cJSON_Object);
       32:   64:    assert_has_no_reference(object_item);
       32:   65:    assert_has_no_const_string(object_item);
        -:   66://    assert_has_no_valuestring(object_item);
        -:   67://    assert_has_no_string(object_item);
        -:   68:}
        -:   69:
       32:   70:static void assert_parse_object(const char *json)
        -:   71:{
       32:   72:    parse_buffer parsebuffer = { 0, 0, 0, 0, { 0, 0, 0 } };
       32:   73:    parsebuffer.content = (const unsigned char*)json;
       32:   74:    parsebuffer.length = strlen(json) + sizeof("");
       32:   75:    parsebuffer.hooks = global_hooks;
        -:   76:
       32:   77:    ASSERT_TRUE(parse_object(item, &parsebuffer));
       32:   78:    assert_is_object(item);
        -:   79:}
        -:   80:
       20:   81:TEST_F(CjsonFixture, parse_empty_objects){
        4:   82:    assert_parse_object("{}");
        4:   83:    assert_parse_object("{\n\t}");
        4:   84:}
        -:   85:
       20:   86:TEST_F(CjsonFixture, parse_object_should_parse_objects_with_one_element){
        4:   87:    assert_parse_object("{\"one\":1}");
        -:   88://    assert_is_child(item->child, "one", cJSON_Number);
        4:   89:    reset(item);
        -:   90:
        4:   91:    assert_parse_object("{\"hello\":\"world!\"}");
        -:   92://    assert_is_child(item->child, "hello", cJSON_String);
        4:   93:    reset(item);
        -:   94:
        4:   95:    assert_parse_object("{\"array\":[]}");
        -:   96://    assert_is_child(item->child, "array", cJSON_Array);
        4:   97:    reset(item);
        -:   98:
        4:   99:    assert_parse_object("{\"null\":null}");
        -:  100://    assert_is_child(item->child, "null", cJSON_NULL);
        4:  101:    reset(item);
        4:  102:}
       20:  103:TEST_F(CjsonFixture, parse_object_should_parse_objects_with_multiple_elements)
        -:  104:{
        4:  105:    assert_parse_object("{\"one\":1\t,\t\"two\"\n:2, \"three\":3}");
        -:  106://    assert_is_child(item->child, "one", cJSON_Number);
        -:  107://    assert_is_child(item->child->next, "two", cJSON_Number);
        -:  108://    assert_is_child(item->child->next->next, "three", cJSON_Number);
        4:  109:    reset(item);
        -:  110:
        -:  111:    {
        4:  112:        size_t i = 0;
        4:  113:        cJSON *node = NULL;
        4:  114:        int expected_types[7] =
        -:  115:                {
        -:  116:                        cJSON_Number,
        -:  117:                        cJSON_NULL,
        -:  118:                        cJSON_True,
        -:  119:                        cJSON_False,
        -:  120:                        cJSON_Array,
        -:  121:                        cJSON_String,
        -:  122:                        cJSON_Object
        -:  123:                };
        4:  124:        const char *expected_names[7] =
        -:  125:                {
        -:  126:                        "one",
        -:  127:                        "NULL",
        -:  128:                        "TRUE",
        -:  129:                        "FALSE",
        -:  130:                        "array",
        -:  131:                        "world",
        -:  132:                        "object"
        -:  133:                };
        4:  134:        assert_parse_object("{\"one\":1, \"NULL\":null, \"TRUE\":true, \"FALSE\":false, \"array\":[], \"world\":\"hello\", \"object\":{}}");
        -:  135:
        4:  136:        node = item->child;
       28:  137:        for (
        4:  138:                i = 0;
        -:  139:                (i < (sizeof(expected_types)/sizeof(int)))
       32:  140:                && (node != NULL);
       28:  141:                (void)i++, node = node->next)
        -:  142:        {
        -:  143://            assert_is_child(node, expected_names[i], expected_types[i]);
        -:  144:        }
        -:  145://        TEST_ASSERT_EQUAL_INT(i, 7);
        4:  146:        reset(item);
        -:  147:    }
        4:  148:}
        -:  149:
       32:  150:static void assert_parse_array(const char *json)
        -:  151:{
       32:  152:    parse_buffer buffer = { 0, 0, 0, 0, { 0, 0, 0 } };
       32:  153:    buffer.content = (const unsigned char*)json;
       32:  154:    buffer.length = strlen(json) + sizeof("");
       32:  155:    buffer.hooks = global_hooks;
        -:  156:
       32:  157:    ASSERT_TRUE(parse_array(item, &buffer));
        -:  158://    assert_is_array(item);
        -:  159:}
        -:  160:
       20:  161:TEST_F(CjsonFixture, parse_array_should_parse_empty_arrays)
        -:  162://static void parse_array_should_parse_empty_arrays(void)
        -:  163:{
        4:  164:    assert_parse_array("[]");
        -:  165://    assert_has_no_child(item);
        -:  166:
        4:  167:    assert_parse_array("[\n\t]");
        -:  168://    assert_has_no_child(item);
        4:  169:}
       20:  170:TEST_F(CjsonFixture, parse_array_should_parse_arrays_with_one_element)
        -:  171:{
        -:  172:
        4:  173:    assert_parse_array("[1]");
        -:  174://    assert_has_child(item);
        4:  175:    assert_has_type(item->child, cJSON_Number);
        4:  176:    reset(item);
        -:  177:
        4:  178:    assert_parse_array("[\"hello!\"]");
        -:  179://    assert_has_child(item);
        4:  180:    assert_has_type(item->child, cJSON_String);
        4:  181:    ASSERT_STREQ("hello!", item->child->valuestring);
        4:  182:    reset(item);
        -:  183:
        4:  184:    assert_parse_array("[[]]");
        -:  185://    assert_has_child(item);
        -:  186://    assert_is_array(item->child);
        -:  187://    assert_has_no_child(item->child);
        4:  188:    reset(item);
        -:  189:
        4:  190:    assert_parse_array("[null]");
        -:  191://    assert_has_child(item);
        4:  192:    assert_has_type(item->child, cJSON_NULL);
        4:  193:    reset(item);
        -:  194:}
       20:  195:TEST_F(CjsonFixture, parse_array_should_parse_arrays_with_multiple_elements)
        -:  196:{
        4:  197:    assert_parse_array("[1\t,\n2, 3]");
        -:  198://    assert_has_child(item);
        -:  199://    TEST_ASSERT_NOT_NULL(item->child->next);
        -:  200://    TEST_ASSERT_NOT_NULL(item->child->next->next);
        -:  201://    TEST_ASSERT_NULL(item->child->next->next->next);
        4:  202:    assert_has_type(item->child, cJSON_Number);
        4:  203:    assert_has_type(item->child->next, cJSON_Number);
        4:  204:    assert_has_type(item->child->next->next, cJSON_Number);
        4:  205:    reset(item);
        -:  206:
        -:  207:    {
        4:  208:        size_t i = 0;
        4:  209:        cJSON *node = NULL;
        4:  210:        int expected_types[7] =
        -:  211:                {
        -:  212:                        cJSON_Number,
        -:  213:                        cJSON_NULL,
        -:  214:                        cJSON_True,
        -:  215:                        cJSON_False,
        -:  216:                        cJSON_Array,
        -:  217:                        cJSON_String,
        -:  218:                        cJSON_Object
        -:  219:                };
        4:  220:        assert_parse_array("[1, null, true, false, [], \"hello\", {}]");
        -:  221:
        4:  222:        node = item->child;
       28:  223:        for (
        4:  224:                i = 0;
        -:  225:                (i < (sizeof(expected_types)/sizeof(int)))
       32:  226:                && (node != NULL);
       28:  227:                (void)i++, node = node->next)
        -:  228:        {
        -:  229://            TEST_ASSERT_BITS(0xFF, expected_types[i], node->type);
        -:  230:        }
        -:  231://        TEST_ASSERT_EQUAL_INT(i, 7);
        4:  232:        reset(item);
        -:  233:    }
        4:  234:}
        -:  235:
       72:  236:static void assert_parse_number(const char *string, int integer, double real)
        -:  237:{
       72:  238:    parse_buffer buffer = { 0, 0, 0, 0, { 0, 0, 0 } };
       72:  239:    buffer.content = (const unsigned char*)string;
       72:  240:    buffer.length = strlen(string) + sizeof("");
        -:  241:
       72:  242:    ASSERT_TRUE(parse_number(item, &buffer));
        -:  243://    assert_is_number(item);
       72:  244:    ASSERT_EQ(integer, item->valueint);
       72:  245:    ASSERT_DOUBLE_EQ(real, item->valuedouble);
        -:  246:}
       20:  247:TEST_F(CjsonFixture, parse_number_should_parse_zero)
        -:  248:{
        4:  249:    assert_parse_number("0", 0, 0);
        4:  250:    assert_parse_number("0.0", 0, 0.0);
        4:  251:    assert_parse_number("-0", 0, -0.0);
        4:  252:}
        -:  253:
       20:  254:TEST_F(CjsonFixture, parse_number_should_parse_negative_integers)
        -:  255:{
        4:  256:    assert_parse_number("-1", -1, -1);
        4:  257:    assert_parse_number("-32768", -32768, -32768.0);
        4:  258:    assert_parse_number("-2147483648", (int)-2147483648.0, -2147483648.0);
        4:  259:}
        -:  260:
    #####:  261:static void parse_number_should_parse_positive_integers(void)
        -:  262:{
    #####:  263:    assert_parse_number("1", 1, 1);
    #####:  264:    assert_parse_number("32767", 32767, 32767.0);
    #####:  265:    assert_parse_number("2147483647", (int)2147483647.0, 2147483647.0);
    #####:  266:}
       20:  267:TEST_F(CjsonFixture, parse_number_should_parse_positive_reals)
        -:  268:{
        4:  269:    assert_parse_number("0.001", 0, 0.001);
        4:  270:    assert_parse_number("10e-10", 0, 10e-10);
        4:  271:    assert_parse_number("10E-10", 0, 10e-10);
        4:  272:    assert_parse_number("10e10", INT_MAX, 10e10);
        4:  273:    assert_parse_number("123e+127", INT_MAX, 123e127);
        4:  274:    assert_parse_number("123e-128", 0, 123e-128);
        4:  275:}
       20:  276:TEST_F(CjsonFixture, parse_number_should_parse_negative_reals)
        -:  277:{
        4:  278:    assert_parse_number("-0.001", 0, -0.001);
        4:  279:    assert_parse_number("-10e-10", 0, -10e-10);
        4:  280:    assert_parse_number("-10E-10", 0, -10e-10);
        4:  281:    assert_parse_number("-10e20", INT_MIN, -10e20);
        4:  282:    assert_parse_number("-123e+127", INT_MIN, -123e127);
        4:  283:    assert_parse_number("-123e-128", 0, -123e-128);
       16:  284:}
        -:  285:
        -:  286:
