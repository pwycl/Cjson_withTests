        -:    0:Source:/mnt/d/CLionProjects/Cjson_withTests/Cjson_lib/cJSON.c
        -:    0:Graph:ConverterTests.cpp.gcno
        -:    0:Data:ConverterTests.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2:  Copyright (c) 2009-2017 Dave Gamble and cJSON contributors
        -:    3:
        -:    4:  Permission is hereby granted, free of charge, to any person obtaining a copy
        -:    5:  of this software and associated documentation files (the "Software"), to deal
        -:    6:  in the Software without restriction, including without limitation the rights
        -:    7:  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        -:    8:  copies of the Software, and to permit persons to whom the Software is
        -:    9:  furnished to do so, subject to the following conditions:
        -:   10:
        -:   11:  The above copyright notice and this permission notice shall be included in
        -:   12:  all copies or substantial portions of the Software.
        -:   13:
        -:   14:  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        -:   15:  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        -:   16:  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        -:   17:  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        -:   18:  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        -:   19:  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
        -:   20:  THE SOFTWARE.
        -:   21:*/
        -:   22:
        -:   23:/* cJSON */
        -:   24:/* JSON parser in C. */
        -:   25:
        -:   26:/* disable warnings about old C89 functions in MSVC */
        -:   27:#if !defined(_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER)
        -:   28:#define _CRT_SECURE_NO_DEPRECATE
        -:   29:#endif
        -:   30:
        -:   31:#ifdef __GNUC__
        -:   32:#pragma GCC visibility push(default)
        -:   33:#endif
        -:   34:#if defined(_MSC_VER)
        -:   35:#pragma warning (push)
        -:   36:/* disable warning about single line comments in system headers */
        -:   37:#pragma warning (disable : 4001)
        -:   38:#endif
        -:   39:
        -:   40:#include <string.h>
        -:   41:#include <stdio.h>
        -:   42:#include <math.h>
        -:   43:#include <stdlib.h>
        -:   44:#include <limits.h>
        -:   45:#include <ctype.h>
        -:   46:
        -:   47:#ifdef ENABLE_LOCALES
        -:   48:#include <locale.h>
        -:   49:#endif
        -:   50:
        -:   51:#if defined(_MSC_VER)
        -:   52:#pragma warning (pop)
        -:   53:#endif
        -:   54:#ifdef __GNUC__
        -:   55:#pragma GCC visibility pop
        -:   56:#endif
        -:   57:
        -:   58:#include "cJSON.h"
        -:   59:
        -:   60:/* define our own boolean type */
        -:   61:#ifdef true
        -:   62:#undef true
        -:   63:#endif
        -:   64:#define true ((cJSON_bool)1)
        -:   65:
        -:   66:#ifdef false
        -:   67:#undef false
        -:   68:#endif
        -:   69:#define false ((cJSON_bool)0)
        -:   70:
        -:   71:typedef struct {
        -:   72:    const unsigned char *json;
        -:   73:    size_t position;
        -:   74:} error;
        -:   75:static error global_error = { NULL, 0 };
        -:   76:
        1:   77:CJSON_PUBLIC(const char *) cJSON_GetErrorPtr(void)
        -:   78:{
        1:   79:    return (const char*) (global_error.json + global_error.position);
        -:   80:}
        -:   81:
        -:   82:/* This is a safeguard to prevent copy-pasters from using incompatible C and header files */
        -:   83:#if (CJSON_VERSION_MAJOR != 1) || (CJSON_VERSION_MINOR != 7) || (CJSON_VERSION_PATCH != 12)
        -:   84:    #error cJSON.h and cJSON.c have different versions. Make sure that both have the same.
        -:   85:#endif
        -:   86:
        1:   87:CJSON_PUBLIC(const char*) cJSON_Version(void)
        -:   88:{
        -:   89:    static char version[15];
        1:   90:    sprintf(version, "%i.%i.%i", CJSON_VERSION_MAJOR, CJSON_VERSION_MINOR, CJSON_VERSION_PATCH);
        -:   91:
        1:   92:    return version;
        -:   93:}
        -:   94:
        -:   95:/* Case insensitive string comparison, doesn't consider two NULL pointers equal though */
       74:   96:static int case_insensitive_strcmp(const unsigned char *string1, const unsigned char *string2)
        -:   97:{
       74:   98:    if ((string1 == NULL) || (string2 == NULL))
        -:   99:    {
        2:  100:        return 1;
        -:  101:    }
        -:  102:
       72:  103:    if (string1 == string2)
        -:  104:    {
        1:  105:        return 0;
        -:  106:    }
        -:  107:
      251:  108:    for(; tolower(*string1) == tolower(*string2); (void)string1++, string2++)
        -:  109:    {
      108:  110:        if (*string1 == '\0')
        -:  111:        {
       18:  112:            return 0;
        -:  113:        }
        -:  114:    }
        -:  115:
       53:  116:    return tolower(*string1) - tolower(*string2);
        -:  117:}
        -:  118:
        -:  119:typedef struct internal_hooks
        -:  120:{
        -:  121:    void *(CJSON_CDECL *allocate)(size_t size);
        -:  122:    void (CJSON_CDECL *deallocate)(void *pointer);
        -:  123:    void *(CJSON_CDECL *reallocate)(void *pointer, size_t size);
        -:  124:} internal_hooks;
        -:  125:
        -:  126:#if defined(_MSC_VER)
        -:  127:/* work around MSVC error C2322: '...' address of dllimport '...' is not static */
        -:  128:static void * CJSON_CDECL internal_malloc(size_t size)
        -:  129:{
        -:  130:    return malloc(size);
        -:  131:}
        -:  132:static void CJSON_CDECL internal_free(void *pointer)
        -:  133:{
        -:  134:    free(pointer);
        -:  135:}
        -:  136:static void * CJSON_CDECL internal_realloc(void *pointer, size_t size)
        -:  137:{
        -:  138:    return realloc(pointer, size);
        -:  139:}
        -:  140:#else
        -:  141:#define internal_malloc malloc
        -:  142:#define internal_free free
        -:  143:#define internal_realloc realloc
        -:  144:#endif
        -:  145:
        -:  146:/* strlen of character literals resolved at compile time */
        -:  147:#define static_strlen(string_literal) (sizeof(string_literal) - sizeof(""))
        -:  148:
        -:  149:static internal_hooks global_hooks = { internal_malloc, internal_free, internal_realloc };
        -:  150:
       48:  151:static unsigned char* cJSON_strdup(const unsigned char* string, const internal_hooks * const hooks)
        -:  152:{
       48:  153:    size_t length = 0;
       48:  154:    unsigned char *copy = NULL;
        -:  155:
       48:  156:    if (string == NULL)
        -:  157:    {
        1:  158:        return NULL;
        -:  159:    }
        -:  160:
       47:  161:    length = strlen((const char*)string) + sizeof("");
       47:  162:    copy = (unsigned char*)hooks->allocate(length);
        -:  163:
       47:  164:    memcpy(copy, string, length);
        -:  165:
       47:  166:    return copy;
        -:  167:}
        -:  168:
        6:  169:CJSON_PUBLIC(void) cJSON_InitHooks(cJSON_Hooks* hooks)
        -:  170:{
        6:  171:    if (hooks == NULL)
        -:  172:    {
        -:  173:        /* Reset hooks */
        1:  174:        global_hooks.allocate = malloc;
        1:  175:        global_hooks.deallocate = free;
        1:  176:        global_hooks.reallocate = realloc;
        1:  177:        return;
        -:  178:    }
        -:  179:
        5:  180:    global_hooks.allocate = malloc;
        5:  181:    if (hooks->malloc_fn != NULL)
        -:  182:    {
        1:  183:        global_hooks.allocate = hooks->malloc_fn;
        -:  184:    }
        -:  185:
        5:  186:    global_hooks.deallocate = free;
        5:  187:    if (hooks->free_fn != NULL)
        -:  188:    {
        2:  189:        global_hooks.deallocate = hooks->free_fn;
        -:  190:    }
        -:  191:
        -:  192:    /* use realloc only if both free and malloc are used */
        5:  193:    global_hooks.reallocate = NULL;
        5:  194:    if ((global_hooks.allocate == malloc) && (global_hooks.deallocate == free))
        -:  195:    {
        3:  196:        global_hooks.reallocate = realloc;
        -:  197:    }
        -:  198:}
        -:  199:
        -:  200:/* Internal constructor. */
      478:  201:static cJSON *cJSON_New_Item(const internal_hooks * const hooks)
        -:  202:{
      478:  203:    cJSON* node = (cJSON*)hooks->allocate(sizeof(cJSON));
      478:  204:    memset(node, '\0', sizeof(cJSON));
        -:  205:
      478:  206:    return node;
        -:  207:}
        -:  208:
        -:  209:/* Delete a cJSON structure. */
      177:  210:CJSON_PUBLIC(void) cJSON_Delete(cJSON *item)
        -:  211:{
      177:  212:    cJSON *next = NULL;
      791:  213:    while (item != NULL)
        -:  214:    {
      307:  215:        next = item->next;
      307:  216:        if (!(item->type & cJSON_IsReference) && (item->child != NULL))
        -:  217:        {
       38:  218:            cJSON_Delete(item->child);
        -:  219:        }
      307:  220:        if (!(item->type & cJSON_IsReference) && (item->valuestring != NULL))
        -:  221:        {
       36:  222:            global_hooks.deallocate(item->valuestring);
        -:  223:        }
      307:  224:        if (!(item->type & cJSON_StringIsConst) && (item->string != NULL))
        -:  225:        {
       82:  226:            global_hooks.deallocate(item->string);
        -:  227:        }
      307:  228:        global_hooks.deallocate(item);
      307:  229:        item = next;
        -:  230:    }
      177:  231:}
        -:  232:
        -:  233:/* get the decimal point character of the current locale */
      184:  234:static unsigned char get_decimal_point(void)
        -:  235:{
        -:  236:#ifdef ENABLE_LOCALES
        -:  237:    struct lconv *lconv = localeconv();
        -:  238:    return (unsigned char) lconv->decimal_point[0];
        -:  239:#else
      184:  240:    return '.';
        -:  241:#endif
        -:  242:}
        -:  243:
        -:  244:typedef struct
        -:  245:{
        -:  246:    const unsigned char *content;
        -:  247:    size_t length;
        -:  248:    size_t offset;
        -:  249:    size_t depth; /* How deeply nested (in arrays/objects) is the input at the current offset. */
        -:  250:    internal_hooks hooks;
        -:  251:} parse_buffer;
        -:  252:
        -:  253:/* check if the given size is left to read in a given parse buffer (starting with 1) */
        -:  254:#define can_read(buffer, size) ((buffer != NULL) && (((buffer)->offset + size) <= (buffer)->length))
        -:  255:/* check if the buffer can be accessed at the given index (starting with 0) */
        -:  256:#define can_access_at_index(buffer, index) ((buffer != NULL) && (((buffer)->offset + index) < (buffer)->length))
        -:  257:#define cannot_access_at_index(buffer, index) (!can_access_at_index(buffer, index))
        -:  258:/* get a pointer to the buffer at the position */
        -:  259:#define buffer_at_offset(buffer) ((buffer)->content + (buffer)->offset)
        -:  260:
        -:  261:/* Parse the input text to generate a number, and populate the result into item. */
      124:  262:static cJSON_bool parse_number(cJSON * const item, parse_buffer * const input_buffer)
        -:  263:{
      124:  264:    double number = 0;
      124:  265:    unsigned char *after_end = NULL;
        -:  266:    unsigned char number_c_string[64];
      124:  267:    unsigned char decimal_point = get_decimal_point();
      124:  268:    size_t i = 0;
        -:  269:
      124:  270:    if ((input_buffer == NULL) || (input_buffer->content == NULL))
        -:  271:    {
       36:  272:        return false;
        -:  273:    }
        -:  274:
        -:  275:    /* copy the number into a temporary buffer and replace '.' with the decimal point
        -:  276:     * of the current locale (for strtod)
        -:  277:     * This also takes care of '\0' not necessarily being available for marking the end of the input */
      602:  278:    for (i = 0; (i < (sizeof(number_c_string) - 1)) && can_access_at_index(input_buffer, i); i++)
        -:  279:    {
      301:  280:        switch (buffer_at_offset(input_buffer)[i])
        -:  281:        {
      206:  282:            case '0':
        -:  283:            case '1':
        -:  284:            case '2':
        -:  285:            case '3':
        -:  286:            case '4':
        -:  287:            case '5':
        -:  288:            case '6':
        -:  289:            case '7':
        -:  290:            case '8':
        -:  291:            case '9':
        -:  292:            case '+':
        -:  293:            case '-':
        -:  294:            case 'e':
        -:  295:            case 'E':
      206:  296:                number_c_string[i] = buffer_at_offset(input_buffer)[i];
      206:  297:                break;
        -:  298:
        7:  299:            case '.':
        7:  300:                number_c_string[i] = decimal_point;
        7:  301:                break;
        -:  302:
       88:  303:            default:
       88:  304:                goto loop_end;
        -:  305:        }
        -:  306:    }
    #####:  307:loop_end:
       88:  308:    number_c_string[i] = '\0';
        -:  309:
       88:  310:    number = strtod((const char*)number_c_string, (char**)&after_end);
        -:  311:
       88:  312:    item->valuedouble = number;
        -:  313:
        -:  314:    /* use saturation in case of overflow */
       88:  315:    if (number >= INT_MAX)
        -:  316:    {
        2:  317:        item->valueint = INT_MAX;
        -:  318:    }
       86:  319:    else if (number <= (double)INT_MIN)
        -:  320:    {
        3:  321:        item->valueint = INT_MIN;
        -:  322:    }
        -:  323:    else
        -:  324:    {
       83:  325:        item->valueint = (int)number;
        -:  326:    }
        -:  327:
       88:  328:    item->type = cJSON_Number;
        -:  329:
       88:  330:    input_buffer->offset += (size_t)(after_end - number_c_string);
       88:  331:    return true;
        -:  332:}
        -:  333:
        -:  334:/* don't ask me, but the original cJSON_SetNumberValue returns an integer or double */
       21:  335:CJSON_PUBLIC(double) cJSON_SetNumberHelper(cJSON *object, double number)
        -:  336:{
       21:  337:    if (number >= INT_MAX)
        -:  338:    {
        4:  339:        object->valueint = INT_MAX;
        -:  340:    }
       17:  341:    else if (number <= (double)INT_MIN)
        -:  342:    {
        4:  343:        object->valueint = INT_MIN;
        -:  344:    }
        -:  345:    else
        -:  346:    {
       13:  347:        object->valueint = (int)number;
        -:  348:    }
        -:  349:
       21:  350:    return object->valuedouble = number;
        -:  351:}
        -:  352:
        -:  353:typedef struct
        -:  354:{
        -:  355:    unsigned char *buffer;
        -:  356:    size_t length;
        -:  357:    size_t offset;
        -:  358:    size_t depth; /* current nesting depth (for formatted printing) */
        -:  359:    cJSON_bool noalloc;
        -:  360:    cJSON_bool format; /* is this print a formatted print */
        -:  361:    internal_hooks hooks;
        -:  362:} printbuffer;
        -:  363:
        -:  364:/* realloc printbuffer if necessary to have at least "needed" bytes more */
      478:  365:static unsigned char* ensure(printbuffer * const p, size_t needed)
        -:  366:{
      478:  367:    unsigned char *newbuffer = NULL;
      478:  368:    size_t newsize = 0;
        -:  369:
      478:  370:    if ((p == NULL) || (p->buffer == NULL))
        -:  371:    {
        3:  372:        return NULL;
        -:  373:    }
        -:  374:
      475:  375:    if(p->offset >= p->length)
        -:  376:    {
        -:  377:        /* make sure that offset is valid */
        1:  378:        return NULL;
        -:  379:    }
        -:  380:
        -:  381:
      474:  382:    if (needed > INT_MAX)
        -:  383:    {
        -:  384:        /* sizes bigger than INT_MAX are currently not supported */
        1:  385:        return NULL;
        -:  386:    }
        -:  387:
      473:  388:    needed += p->offset + 1;
      473:  389:    if (needed <= p->length)
        -:  390:    {
      469:  391:        return p->buffer + p->offset;
        -:  392:    }
        -:  393:
        4:  394:    if (p->noalloc) {
        1:  395:        return NULL;
        -:  396:    }
        -:  397:
        -:  398:    /* calculate new buffer size */
        3:  399:    if (needed > (INT_MAX / 2))
        -:  400:    {
        -:  401:        /* overflow of int, use INT_MAX if possible */
        1:  402:        newsize = INT_MAX;
        -:  403:    }
        -:  404:    else
        -:  405:    {
        2:  406:        newsize = needed * 2;
        -:  407:    }
        -:  408:
        3:  409:    if (p->hooks.reallocate != NULL)
        -:  410:    {
        -:  411:        /* reallocate with realloc if available */
        2:  412:        newbuffer = (unsigned char*)p->hooks.reallocate(p->buffer, newsize);
        -:  413:    }
        -:  414:    else
        -:  415:    {
        -:  416:        /* otherwise reallocate manually */
        1:  417:        newbuffer = (unsigned char*)p->hooks.allocate(newsize);
        1:  418:        memcpy(newbuffer, p->buffer, p->offset + 1);
        1:  419:        p->hooks.deallocate(p->buffer);
        -:  420:    }
        3:  421:    p->length = newsize;
        3:  422:    p->buffer = newbuffer;
        -:  423:
        3:  424:    return newbuffer + p->offset;
        -:  425:}
        -:  426:
        -:  427:/* calculate the new length of the string in a printbuffer and update the offset */
      193:  428:static void update_offset(printbuffer * const buffer)
        -:  429:{
      193:  430:    const unsigned char *buffer_pointer = NULL;
      193:  431:    if ((buffer == NULL) || (buffer->buffer == NULL))
        -:  432:    {
        2:  433:        return;
        -:  434:    }
      191:  435:    buffer_pointer = buffer->buffer + buffer->offset;
        -:  436:
      191:  437:    buffer->offset += strlen((const char*)buffer_pointer);
        -:  438:}
        -:  439:
        -:  440:/* securely comparison of floating-point variables */
       70:  441:static cJSON_bool compare_double(double a, double b)
        -:  442:{
       70:  443:    return (fabs(a - b) <= CJSON_DOUBLE_PRECISION);
        -:  444:}
        -:  445:
        -:  446:/* Render the number nicely from the given item into a string. */
       60:  447:static cJSON_bool print_number(const cJSON * const item, printbuffer * const output_buffer)
        -:  448:{
       60:  449:    unsigned char *output_pointer = NULL;
       60:  450:    double d = item->valuedouble;
       60:  451:    int length = 0;
       60:  452:    size_t i = 0;
       60:  453:    unsigned char number_buffer[26] = {0}; /* temporary buffer to print the number into */
       60:  454:    unsigned char decimal_point = get_decimal_point();
       60:  455:    double test = 0.0;
        -:  456:
       60:  457:    if (output_buffer == NULL)
        -:  458:    {
       18:  459:        return false;
        -:  460:    }
        -:  461:
        -:  462:    /* This checks for NaN and Infinity */
        -:  463:
        -:  464:    /* Try 15 decimal places of precision to avoid nonsignificant nonzero digits */
       42:  465:    length = sprintf((char*)number_buffer, "%1.15g", d);
        -:  466:
        -:  467:    /* Check whether the original double can be recovered */
       42:  468:    if(!compare_double((double)test, d)){
       39:  469:        length = sprintf((char*)number_buffer, "%1.17g", d);
        -:  470:    }
        -:  471:
        -:  472:    /* sprintf failed or buffer overrun occurred */
        -:  473:
        -:  474:    /* reserve appropriate space in the output */
       42:  475:    output_pointer = ensure(output_buffer, (size_t)length + sizeof(""));
        -:  476:
        -:  477:    /* copy the printed number to the output and replace locale
        -:  478:     * dependent decimal point with '.' */
      234:  479:    for (i = 0; i < ((size_t)length); i++)
        -:  480:    {
      201:  481:        if (number_buffer[i] == decimal_point)
        -:  482:        {
        9:  483:            output_pointer[i] = '.';
        9:  484:            continue;
        -:  485:        }
        -:  486:
      183:  487:        output_pointer[i] = number_buffer[i];
        -:  488:    }
       42:  489:    output_pointer[i] = '\0';
        -:  490:
       42:  491:    output_buffer->offset += (size_t)length;
        -:  492:
       42:  493:    return true;
        -:  494:}
        -:  495:
        -:  496:/* parse 4 digit hexadecimal number */
   131078:  497:static unsigned parse_hex4(const unsigned char * const input)
        -:  498:{
   131078:  499:    unsigned int h = 0;
   131078:  500:    size_t i = 0;
        -:  501:
   655386:  502:    for (i = 0; i < 4; i++)
        -:  503:    {
        -:  504:        /* parse digit */
   524309:  505:        if ((input[i] >= '0') && (input[i] <= '9'))
        -:  506:        {
   327689:  507:            h += (unsigned int) input[i] - '0';
        -:  508:        }
   196620:  509:        else if ((input[i] >= 'A') && (input[i] <= 'F'))
        -:  510:        {
    98308:  511:            h += (unsigned int) 10 + input[i] - 'A';
        -:  512:        }
    98312:  513:        else if ((input[i] >= 'a') && (input[i] <= 'f'))
        -:  514:        {
    98311:  515:            h += (unsigned int) 10 + input[i] - 'a';
        -:  516:        }
        -:  517:        else /* invalid */
        -:  518:        {
        1:  519:            return 0;
        -:  520:        }
        -:  521:
   524308:  522:        if (i < 3)
        -:  523:        {
        -:  524:            /* shift left to make place for the next nibble */
   393231:  525:            h = h << 4;
        -:  526:        }
        -:  527:    }
        -:  528:
   131077:  529:    return h;
        -:  530:}
        -:  531:
        -:  532:/* converts a UTF-16 literal to UTF-8
        -:  533: * A literal can be one or two sequences of the form \uXXXX */
        3:  534:static unsigned char utf16_literal_to_utf8(const unsigned char * const input_pointer, const unsigned char * const input_end, unsigned char **output_pointer)
        -:  535:{
        3:  536:    long unsigned int codepoint = 0;
        3:  537:    unsigned int first_code = 0;
        3:  538:    const unsigned char *first_sequence = input_pointer;
        3:  539:    unsigned char utf8_length = 0;
        3:  540:    unsigned char utf8_position = 0;
        3:  541:    unsigned char sequence_length = 0;
        3:  542:    unsigned char first_byte_mark = 0;
        -:  543:
        -:  544:    /* get the first utf16 sequence */
        3:  545:    first_code = parse_hex4(first_sequence + 2);
        -:  546:
        -:  547:    /* UTF16 surrogate pair */
        3:  548:    if ((first_code >= 0xD800) && (first_code <= 0xDBFF))
        -:  549:    {
        1:  550:        const unsigned char *second_sequence = first_sequence + 6;
        1:  551:        unsigned int second_code = 0;
        1:  552:        sequence_length = 12; /* \uXXXX\uXXXX */
        -:  553:
        -:  554:        /* get the second utf16 sequence */
        1:  555:        second_code = parse_hex4(second_sequence + 2);
        -:  556:        /* check that the code is valid */
        -:  557:
        -:  558:        /* calculate the unicode codepoint from the surrogate pair */
        1:  559:        codepoint = 0x10000 + (((first_code & 0x3FF) << 10) | (second_code & 0x3FF));
        -:  560:    }
        -:  561:    else
        -:  562:    {
        2:  563:        sequence_length = 6; /* \uXXXX */
        2:  564:        codepoint = first_code;
        -:  565:    }
        -:  566:
        -:  567:    /* encode as UTF-8
        -:  568:     * takes at maximum 4 bytes to encode:
        -:  569:     * 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx */
        3:  570:    if (codepoint < 0x10000)
        -:  571:    {
        -:  572:        /* three bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx */
        2:  573:        utf8_length = 3;
        2:  574:        first_byte_mark = 0xE0; /* 11100000 */
        -:  575:    }
        1:  576:    else if (codepoint <= 0x10FFFF)
        -:  577:    {
        -:  578:        /* four bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx 10xxxxxx */
        1:  579:        utf8_length = 4;
        1:  580:        first_byte_mark = 0xF0; /* 11110000 */
        -:  581:    }
        -:  582:    else
        -:  583:    {
        -:  584:        /* invalid unicode codepoint */
    #####:  585:        goto fail;
        -:  586:    }
        -:  587:
        -:  588:    /* encode as utf8 */
       10:  589:    for (utf8_position = (unsigned char)(utf8_length - 1); utf8_position > 0; utf8_position--)
        -:  590:    {
        -:  591:        /* 10xxxxxx */
        7:  592:        (*output_pointer)[utf8_position] = (unsigned char)((codepoint | 0x80) & 0xBF);
        7:  593:        codepoint >>= 6;
        -:  594:    }
        -:  595:    /* encode first byte */
        3:  596:    (*output_pointer)[0] = (unsigned char)((codepoint | first_byte_mark) & 0xFF);
        -:  597:
        3:  598:    *output_pointer += utf8_length;
        -:  599:
        3:  600:    return sequence_length;
        -:  601:
    #####:  602:fail:
    #####:  603:    return 0;
        -:  604:}
        -:  605:
        -:  606:/* Parse the input text into an unescaped cinput, and populate item. */
      179:  607:static cJSON_bool parse_string(cJSON * const item, parse_buffer * const input_buffer)
        -:  608:{
      179:  609:    const unsigned char *input_pointer = buffer_at_offset(input_buffer) + 1;
      179:  610:    const unsigned char *input_end = buffer_at_offset(input_buffer) + 1;
      179:  611:    unsigned char *output_pointer = NULL;
      179:  612:    unsigned char *output = NULL;
        -:  613:
        -:  614:    /* not a string */
      179:  615:    if (buffer_at_offset(input_buffer)[0] != '\"')
        -:  616:    {
        5:  617:        goto fail;
        -:  618:    }
        -:  619:
        -:  620:    {
        -:  621:        /* calculate approximate size of the output (overestimate) */
      174:  622:        size_t allocation_length = 0;
      174:  623:        size_t skipped_bytes = 0;
     1820:  624:        while (((size_t)(input_end - input_buffer->content) < input_buffer->length) && (*input_end != '\"'))
        -:  625:        {
        -:  626:            /* is escape sequence */
      823:  627:            if (input_end[0] == '\\')
        -:  628:            {
       16:  629:                skipped_bytes++;
       16:  630:                input_end++;
        -:  631:            }
      823:  632:            input_end++;
        -:  633:        }
      174:  634:        if (((size_t)(input_end - input_buffer->content) >= input_buffer->length))
        -:  635:        {
        1:  636:            goto fail; /* string ended unexpectedly */
        -:  637:        }
      173:  638:        if((*input_end != '\"')){
    #####:  639:            goto fail; /* string ended unexpectedly */
        -:  640:        }
        -:  641:
        -:  642:        /* This is at most how much we need for the output */
      173:  643:        allocation_length = (size_t) (input_end - buffer_at_offset(input_buffer)) - skipped_bytes;
      173:  644:        output = (unsigned char*)input_buffer->hooks.allocate(allocation_length + sizeof(""));
        -:  645:    }
        -:  646:
      173:  647:    output_pointer = output;
        -:  648:    /* loop through the string literal */
     1747:  649:    while (input_pointer < input_end)
        -:  650:    {
      787:  651:        if (*input_pointer != '\\')
        -:  652:        {
      773:  653:            *output_pointer++ = *input_pointer++;
        -:  654:        }
        -:  655:        /* escape sequence */
        -:  656:        else
        -:  657:        {
       14:  658:            unsigned char sequence_length = 2;
        -:  659:
       14:  660:            switch (input_pointer[1])
        -:  661:            {
        1:  662:                case 'b':
        1:  663:                    *output_pointer++ = '\b';
        1:  664:                    break;
        1:  665:                case 'f':
        1:  666:                    *output_pointer++ = '\f';
        1:  667:                    break;
        1:  668:                case 'n':
        1:  669:                    *output_pointer++ = '\n';
        1:  670:                    break;
        1:  671:                case 'r':
        1:  672:                    *output_pointer++ = '\r';
        1:  673:                    break;
        1:  674:                case 't':
        1:  675:                    *output_pointer++ = '\t';
        1:  676:                    break;
        6:  677:                case '\"':
        -:  678:                case '\\':
        -:  679:                case '/':
        6:  680:                    *output_pointer++ = input_pointer[1];
        6:  681:                    break;
        -:  682:
        -:  683:                /* UTF-16 literal */
        3:  684:                case 'u':
        3:  685:                    sequence_length = utf16_literal_to_utf8(input_pointer, input_end, &output_pointer);
        3:  686:                    break;
        -:  687:
    #####:  688:                default:
    #####:  689:                    goto fail;
        -:  690:            }
       14:  691:            input_pointer += sequence_length;
        -:  692:        }
        -:  693:    }
        -:  694:
        -:  695:    /* zero terminate the output */
      173:  696:    *output_pointer = '\0';
        -:  697:
      173:  698:    item->type = cJSON_String;
      173:  699:    item->valuestring = (char*)output;
        -:  700:
      173:  701:    input_buffer->offset = (size_t) (input_end - input_buffer->content);
      173:  702:    input_buffer->offset++;
        -:  703:
      173:  704:    return true;
        -:  705:
        6:  706:fail:
        6:  707:    if (input_pointer != NULL)
        -:  708:    {
        6:  709:        input_buffer->offset = (size_t)(input_pointer - input_buffer->content);
        -:  710:    }
        -:  711:
        6:  712:    return false;
        -:  713:}
        -:  714:
        -:  715:/* Render the cstring provided to an escaped version that can be printed. */
       98:  716:static cJSON_bool print_string_ptr(const unsigned char * const input, printbuffer * const output_buffer)
        -:  717:{
       98:  718:    const unsigned char *input_pointer = NULL;
       98:  719:    unsigned char *output = NULL;
       98:  720:    unsigned char *output_pointer = NULL;
       98:  721:    size_t output_length = 0;
        -:  722:    /* numbers of additional characters needed for escaping */
       98:  723:    size_t escape_characters = 0;
        -:  724:
        -:  725:    /* empty string */
       98:  726:    if (input == NULL)
        -:  727:    {
        1:  728:        output = ensure(output_buffer, sizeof("\"\""));
        1:  729:        strcpy((char*)output, "\"\"");
        -:  730:
        1:  731:        return true;
        -:  732:    }
        -:  733:
        -:  734:    /* set "flag" to 1 if something needs to be escaped */
      489:  735:    for (input_pointer = input; *input_pointer; input_pointer++)
        -:  736:    {
      392:  737:        switch (*input_pointer)
        -:  738:        {
        7:  739:            case '\"':
        -:  740:            case '\\':
        -:  741:            case '\b':
        -:  742:            case '\f':
        -:  743:            case '\n':
        -:  744:            case '\r':
        -:  745:            case '\t':
        -:  746:                /* one character escape sequence */
        7:  747:                escape_characters++;
        7:  748:                break;
      385:  749:            default:
      385:  750:                if (*input_pointer < 32)
        -:  751:                {
        -:  752:                    /* UTF-16 escape sequence uXXXX */
       26:  753:                    escape_characters += 5;
        -:  754:                }
      385:  755:                break;
        -:  756:        }
        -:  757:    }
       97:  758:    output_length = (size_t)(input_pointer - input) + escape_characters;
        -:  759:
       97:  760:    output = ensure(output_buffer, output_length + sizeof("\"\""));
        -:  761:
        -:  762:    /* no characters have to be escaped */
       97:  763:    if (escape_characters == 0)
        -:  764:    {
       96:  765:        output[0] = '\"';
       96:  766:        memcpy(output + 1, input, output_length);
       96:  767:        output[output_length + 1] = '\"';
       96:  768:        output[output_length + 2] = '\0';
        -:  769:
       96:  770:        return true;
        -:  771:    }
        -:  772:
        1:  773:    output[0] = '\"';
        1:  774:    output_pointer = output + 1;
        -:  775:    /* copy the string */
      127:  776:    for (input_pointer = input; *input_pointer != '\0'; (void)input_pointer++, output_pointer++)
        -:  777:    {
      126:  778:        if ((*input_pointer > 31) && (*input_pointer != '\"') && (*input_pointer != '\\'))
        -:  779:        {
        -:  780:            /* normal character, copy */
       93:  781:            *output_pointer = *input_pointer;
        -:  782:        }
        -:  783:        else
        -:  784:        {
        -:  785:            /* character needs to be escaped */
       33:  786:            *output_pointer++ = '\\';
       33:  787:            switch (*input_pointer)
        -:  788:            {
        1:  789:                case '\\':
        1:  790:                    *output_pointer = '\\';
        1:  791:                    break;
        1:  792:                case '\"':
        1:  793:                    *output_pointer = '\"';
        1:  794:                    break;
        1:  795:                case '\b':
        1:  796:                    *output_pointer = 'b';
        1:  797:                    break;
        1:  798:                case '\f':
        1:  799:                    *output_pointer = 'f';
        1:  800:                    break;
        1:  801:                case '\n':
        1:  802:                    *output_pointer = 'n';
        1:  803:                    break;
        1:  804:                case '\r':
        1:  805:                    *output_pointer = 'r';
        1:  806:                    break;
        1:  807:                case '\t':
        1:  808:                    *output_pointer = 't';
        1:  809:                    break;
       26:  810:                default:
        -:  811:                    /* escape and print as unicode codepoint */
       26:  812:                    sprintf((char*)output_pointer, "u%04x", *input_pointer);
       26:  813:                    output_pointer += 4;
       26:  814:                    break;
        -:  815:            }
        -:  816:        }
        -:  817:    }
        1:  818:    output[output_length + 1] = '\"';
        1:  819:    output[output_length + 2] = '\0';
        -:  820:
        1:  821:    return true;
        -:  822:}
        -:  823:
        -:  824:/* Invoke print_string_ptr (which is useful) on an item. */
       35:  825:static cJSON_bool print_string(const cJSON * const item, printbuffer * const p)
        -:  826:{
       35:  827:    return print_string_ptr((unsigned char*)item->valuestring, p);
        -:  828:}
        -:  829:
        -:  830:/* Predeclare these prototypes. */
        -:  831:static cJSON_bool parse_value(cJSON * const item, parse_buffer * const input_buffer);
        -:  832:static cJSON_bool print_value(const cJSON * const item, printbuffer * const output_buffer);
        -:  833:static cJSON_bool parse_array(cJSON * const item, parse_buffer * const input_buffer);
        -:  834:static cJSON_bool print_array(const cJSON * const item, printbuffer * const output_buffer);
        -:  835:static cJSON_bool parse_object(cJSON * const item, parse_buffer * const input_buffer);
        -:  836:static cJSON_bool print_object(const cJSON * const item, printbuffer * const output_buffer);
        -:  837:
        -:  838:/* Utility to jump whitespace and cr/lf */
      936:  839:static parse_buffer *buffer_skip_whitespace(parse_buffer * const buffer)
        -:  840:{
      936:  841:    if ((buffer == NULL) || (buffer->content == NULL))
        -:  842:    {
        2:  843:        return NULL;
        -:  844:    }
        -:  845:
     1260:  846:    while (can_access_at_index(buffer, 0) && (buffer_at_offset(buffer)[0] <= 32))
        -:  847:    {
      163:  848:       buffer->offset++;
        -:  849:    }
        -:  850:
      934:  851:    if (buffer->offset == buffer->length)
        -:  852:    {
        9:  853:        buffer->offset--;
        -:  854:    }
        -:  855:
      934:  856:    return buffer;
        -:  857:}
        -:  858:
        -:  859:/* skip the UTF-8 BOM (byte order mark) if it is at the beginning of a buffer */
      129:  860:static parse_buffer *skip_utf8_bom(parse_buffer * const buffer)
        -:  861:{
      129:  862:    if ((buffer == NULL) || (buffer->content == NULL) || (buffer->offset != 0))
        -:  863:    {
        3:  864:        return NULL;
        -:  865:    }
        -:  866:
      126:  867:    if (can_access_at_index(buffer, 4) && (strncmp((const char*)buffer_at_offset(buffer), "\xEF\xBB\xBF", 3) == 0))
        -:  868:    {
        1:  869:        buffer->offset += 3;
        -:  870:    }
        -:  871:
      126:  872:    return buffer;
        -:  873:}
        -:  874:
        -:  875:/* Parse an object - create a new root, and populate. */
      128:  876:CJSON_PUBLIC(cJSON *) cJSON_ParseWithOpts(const char *value, const char **return_parse_end, cJSON_bool require_null_terminated)
        -:  877:{
      128:  878:    parse_buffer buffer = { 0, 0, 0, 0, { 0, 0, 0 } };
      128:  879:    cJSON *item = NULL;
        -:  880:
        -:  881:    /* reset error position */
      128:  882:    global_error.json = NULL;
      128:  883:    global_error.position = 0;
        -:  884:
      128:  885:    if (value == NULL)
        -:  886:    {
        2:  887:        goto fail;
        -:  888:    }
        -:  889:
      126:  890:    buffer.content = (const unsigned char*)value;
      126:  891:    buffer.length = strlen((const char*)value) + sizeof("");
      126:  892:    buffer.offset = 0;
      126:  893:    buffer.hooks = global_hooks;
        -:  894:
      126:  895:    item = cJSON_New_Item(&(buffer.hooks));
        -:  896:
      126:  897:    if (!parse_value(item, buffer_skip_whitespace(skip_utf8_bom(&buffer))))
        -:  898:    {
        -:  899:        /* parse failure. ep is set. */
        4:  900:        goto fail;
        -:  901:    }
        -:  902:
        -:  903:    /* if we require null-terminated JSON without appended garbage, skip and then check for a null terminator */
      122:  904:    if (require_null_terminated)
        -:  905:    {
        5:  906:        buffer_skip_whitespace(&buffer);
        5:  907:        if(buffer_at_offset(&buffer)[0] != '\0'){
        1:  908:            goto fail;
        -:  909:        }
        -:  910:    }
      121:  911:    if (return_parse_end)
        -:  912:    {
        1:  913:        *return_parse_end = (const char*)buffer_at_offset(&buffer);
        -:  914:    }
        -:  915:
      121:  916:    return item;
        -:  917:
        7:  918:fail:
        7:  919:    if (item != NULL)
        -:  920:    {
        5:  921:        cJSON_Delete(item);
        -:  922:    }
        -:  923:
        7:  924:    if (value != NULL)
        -:  925:    {
        -:  926:        error local_error;
        5:  927:        local_error.json = (const unsigned char*)value;
        5:  928:        local_error.position = 0;
        -:  929:
        5:  930:        if (buffer.offset < buffer.length)
        -:  931:        {
        4:  932:            local_error.position = buffer.offset;
        -:  933:        }
        -:  934:        else
        -:  935:        {
        1:  936:            local_error.position = buffer.length - 1;
        -:  937:        }
        -:  938:
        5:  939:        if (return_parse_end != NULL)
        -:  940:        {
        2:  941:            *return_parse_end = (const char*)local_error.json + local_error.position;
        -:  942:        }
        -:  943:
        5:  944:        global_error = local_error;
        -:  945:    }
        -:  946:
        7:  947:    return NULL;
        -:  948:}
        -:  949:
        -:  950:/* Default options for cJSON_Parse */
      115:  951:CJSON_PUBLIC(cJSON *) cJSON_Parse(const char *value)
        -:  952:{
      115:  953:    return cJSON_ParseWithOpts(value, 0, 0);
        -:  954:}
        -:  955:
        -:  956:#define cjson_min(a, b) ((a < b) ? a : b)
        -:  957:
       34:  958:static unsigned char *print(const cJSON * const item, cJSON_bool format, const internal_hooks * const hooks)
        -:  959:{
        -:  960:    static const size_t default_buffer_size = 256;
        -:  961:    printbuffer buffer[1];
       34:  962:    unsigned char *printed = NULL;
        -:  963:
       34:  964:    memset(buffer, 0, sizeof(buffer));
        -:  965:
        -:  966:    /* create buffer */
       34:  967:    buffer->buffer = (unsigned char*) hooks->allocate(default_buffer_size);
       34:  968:    buffer->length = default_buffer_size;
       34:  969:    buffer->format = format;
       34:  970:    buffer->hooks = *hooks;
        -:  971:
        -:  972:    /* print the value */
       34:  973:    if (!print_value(item, buffer))
        -:  974:    {
        1:  975:        goto fail;
        -:  976:    }
       33:  977:    update_offset(buffer);
        -:  978:
        -:  979:    /* check if reallocate is available */
       33:  980:    if (hooks->reallocate != NULL)
        -:  981:    {
       32:  982:        printed = (unsigned char*) hooks->reallocate(buffer->buffer, buffer->offset + 1);
       32:  983:        buffer->buffer = NULL;
        -:  984:    }
        -:  985:    else /* otherwise copy the JSON over to a new buffer */
        -:  986:    {
        1:  987:        printed = (unsigned char*) hooks->allocate(buffer->offset + 1);
        1:  988:        if (printed == NULL)
        -:  989:        {
    #####:  990:            goto fail;
        -:  991:        }
        1:  992:        memcpy(printed, buffer->buffer, cjson_min(buffer->length, buffer->offset + 1));
        1:  993:        printed[buffer->offset] = '\0'; /* just to be sure */
        -:  994:
        -:  995:        /* free the buffer */
        1:  996:        hooks->deallocate(buffer->buffer);
        -:  997:    }
        -:  998:
       33:  999:    return printed;
        -: 1000:
        1: 1001:fail:
        1: 1002:    if (buffer->buffer != NULL)
        -: 1003:    {
        1: 1004:        hooks->deallocate(buffer->buffer);
        -: 1005:    }
        -: 1006:
        1: 1007:    if (printed != NULL)
        -: 1008:    {
    #####: 1009:        hooks->deallocate(printed);
        -: 1010:    }
        -: 1011:
        1: 1012:    return NULL;
        -: 1013:}
        -: 1014:
        -: 1015:/* Render a cJSON item/entity/structure to text. */
        4: 1016:CJSON_PUBLIC(char *) cJSON_Print(const cJSON *item)
        -: 1017:{
        4: 1018:    return (char*)print(item, true, &global_hooks);
        -: 1019:}
        -: 1020:
       30: 1021:CJSON_PUBLIC(char *) cJSON_PrintUnformatted(const cJSON *item)
        -: 1022:{
       30: 1023:    return (char*)print(item, false, &global_hooks);
        -: 1024:}
        -: 1025:
        1: 1026:CJSON_PUBLIC(char *) cJSON_PrintBuffered(const cJSON *item, int prebuffer, cJSON_bool fmt)
        -: 1027:{
        1: 1028:    printbuffer p = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };
        -: 1029:
        1: 1030:    if (prebuffer < 0)
        -: 1031:    {
    #####: 1032:        return NULL;
        -: 1033:    }
        -: 1034:
        1: 1035:    p.buffer = (unsigned char*)global_hooks.allocate((size_t)prebuffer);
        1: 1036:    if (!p.buffer)
        -: 1037:    {
    #####: 1038:        return NULL;
        -: 1039:    }
        -: 1040:
        1: 1041:    p.length = (size_t)prebuffer;
        1: 1042:    p.offset = 0;
        1: 1043:    p.noalloc = false;
        1: 1044:    p.format = fmt;
        1: 1045:    p.hooks = global_hooks;
        -: 1046:
        1: 1047:    if (!print_value(item, &p))
        -: 1048:    {
        1: 1049:        global_hooks.deallocate(p.buffer);
        1: 1050:        return NULL;
        -: 1051:    }
        -: 1052:
    #####: 1053:    return (char*)p.buffer;
        -: 1054:}
        -: 1055:
        2: 1056:CJSON_PUBLIC(cJSON_bool) cJSON_PrintPreallocated(cJSON *item, char *buffer, const int length, const cJSON_bool format)
        -: 1057:{
        2: 1058:    printbuffer p = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };
        -: 1059:
        2: 1060:    if ((length < 0) || (buffer == NULL))
        -: 1061:    {
        1: 1062:        return false;
        -: 1063:    }
        -: 1064:
        1: 1065:    p.buffer = (unsigned char*)buffer;
        1: 1066:    p.length = (size_t)length;
        1: 1067:    p.offset = 0;
        1: 1068:    p.noalloc = true;
        1: 1069:    p.format = format;
        1: 1070:    p.hooks = global_hooks;
        -: 1071:
        1: 1072:    return print_value(item, &p);
        -: 1073:}
        -: 1074:
        -: 1075:/* Parser core - when encountering text, process appropriately. */
      343: 1076:static cJSON_bool parse_value(cJSON * const item, parse_buffer * const input_buffer)
        -: 1077:{
      343: 1078:    if ((input_buffer == NULL) || (input_buffer->content == NULL))
        -: 1079:    {
    #####: 1080:        return false; /* no input */
        -: 1081:    }
        -: 1082:
        -: 1083:    /* parse the different types of values */
        -: 1084:    /* null */
      343: 1085:    if (can_read(input_buffer, 4) && (strncmp((const char*)buffer_at_offset(input_buffer), "null", 4) == 0))
        -: 1086:    {
       33: 1087:        item->type = cJSON_NULL;
       33: 1088:        input_buffer->offset += 4;
       33: 1089:        return true;
        -: 1090:    }
        -: 1091:    /* false */
      310: 1092:    if (can_read(input_buffer, 5) && (strncmp((const char*)buffer_at_offset(input_buffer), "false", 5) == 0))
        -: 1093:    {
       24: 1094:        item->type = cJSON_False;
       24: 1095:        input_buffer->offset += 5;
       24: 1096:        return true;
        -: 1097:    }
        -: 1098:    /* true */
      286: 1099:    if (can_read(input_buffer, 4) && (strncmp((const char*)buffer_at_offset(input_buffer), "true", 4) == 0))
        -: 1100:    {
       28: 1101:        item->type = cJSON_True;
       28: 1102:        item->valueint = 1;
       28: 1103:        input_buffer->offset += 4;
       28: 1104:        return true;
        -: 1105:    }
        -: 1106:    /* string */
      258: 1107:    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '\"'))
        -: 1108:    {
       56: 1109:        return parse_string(item, input_buffer);
        -: 1110:    }
        -: 1111:    /* number */
      202: 1112:    if (can_access_at_index(input_buffer, 0) && ((buffer_at_offset(input_buffer)[0] == '-') || ((buffer_at_offset(input_buffer)[0] >= '0') && (buffer_at_offset(input_buffer)[0] <= '9'))))
        -: 1113:    {
       70: 1114:        return parse_number(item, input_buffer);
        -: 1115:    }
        -: 1116:    /* array */
      132: 1117:    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '['))
        -: 1118:    {
       57: 1119:        return parse_array(item, input_buffer);
        -: 1120:    }
        -: 1121:    /* object */
       75: 1122:    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '{'))
        -: 1123:    {
       72: 1124:        return parse_object(item, input_buffer);
        -: 1125:    }
        -: 1126:
        3: 1127:    return false;
        -: 1128:}
        -: 1129:
        -: 1130:/* Render a value to text. */
      134: 1131:static cJSON_bool print_value(const cJSON * const item, printbuffer * const output_buffer)
        -: 1132:{
      134: 1133:    unsigned char *output = NULL;
        -: 1134:
      134: 1135:    if ((item == NULL) || (output_buffer == NULL))
        -: 1136:    {
        3: 1137:        return false;
        -: 1138:    }
        -: 1139:
      131: 1140:    switch ((item->type) & 0xFF)
        -: 1141:    {
       15: 1142:        case cJSON_NULL:
       15: 1143:            output = ensure(output_buffer, 5);
       15: 1144:            if (output == NULL)
        -: 1145:            {
    #####: 1146:                return false;
        -: 1147:            }
       15: 1148:            strcpy((char*)output, "null");
       15: 1149:            return true;
        -: 1150:
        4: 1151:        case cJSON_False:
        4: 1152:            output = ensure(output_buffer, 6);
        4: 1153:            if (output == NULL)
        -: 1154:            {
    #####: 1155:                return false;
        -: 1156:            }
        4: 1157:            strcpy((char*)output, "false");
        4: 1158:            return true;
        -: 1159:
        4: 1160:        case cJSON_True:
        4: 1161:            output = ensure(output_buffer, 5);
        4: 1162:            if (output == NULL)
        -: 1163:            {
    #####: 1164:                return false;
        -: 1165:            }
        4: 1166:            strcpy((char*)output, "true");
        4: 1167:            return true;
        -: 1168:
       24: 1169:        case cJSON_Number:
       24: 1170:            return print_number(item, output_buffer);
        -: 1171:
    #####: 1172:        case cJSON_Raw:
        -: 1173:        {
    #####: 1174:            size_t raw_length = 0;
    #####: 1175:            if (item->valuestring == NULL)
        -: 1176:            {
    #####: 1177:                return false;
        -: 1178:            }
        -: 1179:
    #####: 1180:            raw_length = strlen(item->valuestring) + sizeof("");
    #####: 1181:            output = ensure(output_buffer, raw_length);
    #####: 1182:            if (output == NULL)
        -: 1183:            {
    #####: 1184:                return false;
        -: 1185:            }
    #####: 1186:            memcpy(output, item->valuestring, raw_length);
    #####: 1187:            return true;
        -: 1188:        }
        -: 1189:
       35: 1190:        case cJSON_String:
       35: 1191:            return print_string(item, output_buffer);
        -: 1192:
       16: 1193:        case cJSON_Array:
       16: 1194:            return print_array(item, output_buffer);
        -: 1195:
       33: 1196:        case cJSON_Object:
       33: 1197:            return print_object(item, output_buffer);
        -: 1198:
    #####: 1199:        default:
    #####: 1200:            return false;
        -: 1201:    }
        -: 1202:}
        -: 1203:
        -: 1204:/* Build an array from input text. */
       64: 1205:static cJSON_bool parse_array(cJSON * const item, parse_buffer * const input_buffer)
        -: 1206:{
       64: 1207:    cJSON *head = NULL; /* head of the linked list */
       64: 1208:    cJSON *current_item = NULL;
        -: 1209:
       64: 1210:    if (input_buffer->depth >= CJSON_NESTING_LIMIT)
        -: 1211:    {
    #####: 1212:        return false; /* to deeply nested */
        -: 1213:    }
       64: 1214:    input_buffer->depth++;
        -: 1215:
       64: 1216:    if (buffer_at_offset(input_buffer)[0] != '[')
        -: 1217:    {
        -: 1218:        /* not an array */
    #####: 1219:        goto fail;
        -: 1220:    }
        -: 1221:
       64: 1222:    input_buffer->offset++;
       64: 1223:    buffer_skip_whitespace(input_buffer);
       64: 1224:    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ']'))
        -: 1225:    {
        -: 1226:        /* empty array */
       26: 1227:        goto success;
        -: 1228:    }
        -: 1229:
        -: 1230:    /* check if we skipped to the end of the buffer */
       38: 1231:    if (cannot_access_at_index(input_buffer, 0))
        -: 1232:    {
    #####: 1233:        input_buffer->offset--;
    #####: 1234:        goto fail;
        -: 1235:    }
        -: 1236:
        -: 1237:    /* step back to character in front of the first element */
       38: 1238:    input_buffer->offset--;
        -: 1239:    /* loop through the comma separated array elements */
       67: 1240:    do
        -: 1241:    {
        -: 1242:        /* allocate next item */
      105: 1243:        cJSON *new_item = cJSON_New_Item(&(input_buffer->hooks));
      105: 1244:        if (new_item == NULL)
        -: 1245:        {
    #####: 1246:            goto fail; /* allocation failure */
        -: 1247:        }
        -: 1248:
        -: 1249:        /* attach next item to list */
      105: 1250:        if (head == NULL)
        -: 1251:        {
        -: 1252:            /* start the linked list */
       38: 1253:            current_item = head = new_item;
        -: 1254:        }
        -: 1255:        else
        -: 1256:        {
        -: 1257:            /* add to the end and advance */
       67: 1258:            current_item->next = new_item;
       67: 1259:            new_item->prev = current_item;
       67: 1260:            current_item = new_item;
        -: 1261:        }
        -: 1262:
        -: 1263:        /* parse next value */
      105: 1264:        input_buffer->offset++;
      105: 1265:        buffer_skip_whitespace(input_buffer);
      105: 1266:        if (!parse_value(current_item, input_buffer))
        -: 1267:        {
    #####: 1268:            goto fail; /* failed to parse value */
        -: 1269:        }
      105: 1270:        buffer_skip_whitespace(input_buffer);
        -: 1271:    }
      105: 1272:    while (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ','));
        -: 1273:
       76: 1274:    if (cannot_access_at_index(input_buffer, 0) || buffer_at_offset(input_buffer)[0] != ']')
        -: 1275:    {
        -: 1276:        goto fail; /* expected end of array */
        -: 1277:    }
        -: 1278:
       38: 1279:success:
       64: 1280:    input_buffer->depth--;
        -: 1281:
       64: 1282:    item->type = cJSON_Array;
       64: 1283:    item->child = head;
        -: 1284:
       64: 1285:    input_buffer->offset++;
        -: 1286:
       64: 1287:    return true;
        -: 1288:
    #####: 1289:fail:
    #####: 1290:    if (head != NULL)
        -: 1291:    {
    #####: 1292:        cJSON_Delete(head);
        -: 1293:    }
        -: 1294:
    #####: 1295:    return false;
        -: 1296:}
        -: 1297:
        -: 1298:/* Render an array to text */
       30: 1299:static cJSON_bool print_array(const cJSON * const item, printbuffer * const output_buffer)
        -: 1300:{
       30: 1301:    unsigned char *output_pointer = NULL;
       30: 1302:    size_t length = 0;
       30: 1303:    cJSON *current_element = item->child;
        -: 1304:
       30: 1305:    if (output_buffer == NULL)
        -: 1306:    {
    #####: 1307:        return false;
        -: 1308:    }
        -: 1309:
        -: 1310:    /* Compose the output array. */
        -: 1311:    /* opening square bracket */
       30: 1312:    output_pointer = ensure(output_buffer, 1);
       30: 1313:    if (output_pointer == NULL)
        -: 1314:    {
    #####: 1315:        return false;
        -: 1316:    }
        -: 1317:
       30: 1318:    *output_pointer = '[';
       30: 1319:    output_buffer->offset++;
       30: 1320:    output_buffer->depth++;
        -: 1321:
      108: 1322:    while (current_element != NULL)
        -: 1323:    {
       39: 1324:        if (!print_value(current_element, output_buffer))
        -: 1325:        {
    #####: 1326:            return false;
        -: 1327:        }
       39: 1328:        update_offset(output_buffer);
       39: 1329:        if (current_element->next)
        -: 1330:        {
       19: 1331:            length = (size_t) (output_buffer->format ? 2 : 1);
       19: 1332:            output_pointer = ensure(output_buffer, length + 1);
       19: 1333:            if (output_pointer == NULL)
        -: 1334:            {
    #####: 1335:                return false;
        -: 1336:            }
       19: 1337:            *output_pointer++ = ',';
       19: 1338:            if(output_buffer->format)
        -: 1339:            {
        8: 1340:                *output_pointer++ = ' ';
        -: 1341:            }
       19: 1342:            *output_pointer = '\0';
       19: 1343:            output_buffer->offset += length;
        -: 1344:        }
       39: 1345:        current_element = current_element->next;
        -: 1346:    }
        -: 1347:
       30: 1348:    output_pointer = ensure(output_buffer, 2);
       30: 1349:    if (output_pointer == NULL)
        -: 1350:    {
    #####: 1351:        return false;
        -: 1352:    }
       30: 1353:    *output_pointer++ = ']';
       30: 1354:    *output_pointer = '\0';
       30: 1355:    output_buffer->depth--;
        -: 1356:
       30: 1357:    return true;
        -: 1358:}
        -: 1359:
        -: 1360:/* Build an object from the text. */
       81: 1361:static cJSON_bool parse_object(cJSON * const item, parse_buffer * const input_buffer)
        -: 1362:{
       81: 1363:    cJSON *head = NULL; /* linked list head */
       81: 1364:    cJSON *current_item = NULL;
        -: 1365:
       81: 1366:    if (input_buffer->depth >= CJSON_NESTING_LIMIT)
        -: 1367:    {
    #####: 1368:        return false; /* to deeply nested */
        -: 1369:    }
       81: 1370:    input_buffer->depth++;
        -: 1371:
      162: 1372:    if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != '{'))
        -: 1373:    {
        -: 1374:        goto fail; /* not an object */
        -: 1375:    }
        -: 1376:
       81: 1377:    input_buffer->offset++;
       81: 1378:    buffer_skip_whitespace(input_buffer);
       81: 1379:    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '}'))
        -: 1380:    {
       33: 1381:        goto success; /* empty object */
        -: 1382:    }
        -: 1383:
        -: 1384:    /* check if we skipped to the end of the buffer */
       48: 1385:    if (cannot_access_at_index(input_buffer, 0))
        -: 1386:    {
    #####: 1387:        input_buffer->offset--;
    #####: 1388:        goto fail;
        -: 1389:    }
        -: 1390:
        -: 1391:    /* step back to character in front of the first element */
       48: 1392:    input_buffer->offset--;
        -: 1393:    /* loop through the comma separated array elements */
       65: 1394:    do
        -: 1395:    {
        -: 1396:        /* allocate next item */
      113: 1397:        cJSON *new_item = cJSON_New_Item(&(input_buffer->hooks));
      113: 1398:        if (new_item == NULL)
        -: 1399:        {
    #####: 1400:            goto fail; /* allocation failure */
        -: 1401:        }
        -: 1402:
        -: 1403:        /* attach next item to list */
      113: 1404:        if (head == NULL)
        -: 1405:        {
        -: 1406:            /* start the linked list */
       48: 1407:            current_item = head = new_item;
        -: 1408:        }
        -: 1409:        else
        -: 1410:        {
        -: 1411:            /* add to the end and advance */
       65: 1412:            current_item->next = new_item;
       65: 1413:            new_item->prev = current_item;
       65: 1414:            current_item = new_item;
        -: 1415:        }
        -: 1416:
        -: 1417:        /* parse the name of the child */
      113: 1418:        input_buffer->offset++;
      113: 1419:        buffer_skip_whitespace(input_buffer);
      113: 1420:        if (!parse_string(current_item, input_buffer))
        -: 1421:        {
        1: 1422:            goto fail; /* failed to parse name */
        -: 1423:        }
      112: 1424:        buffer_skip_whitespace(input_buffer);
        -: 1425:
        -: 1426:        /* swap valuestring and string, because we parsed the name */
      112: 1427:        current_item->string = current_item->valuestring;
      112: 1428:        current_item->valuestring = NULL;
        -: 1429:
      336: 1430:        if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != ':'))
        -: 1431:        {
        -: 1432:            goto fail; /* invalid object */
        -: 1433:        }
        -: 1434:
        -: 1435:        /* parse the value */
      112: 1436:        input_buffer->offset++;
      112: 1437:        buffer_skip_whitespace(input_buffer);
      112: 1438:        if (!parse_value(current_item, input_buffer))
        -: 1439:        {
        1: 1440:            goto fail; /* failed to parse value */
        -: 1441:        }
      111: 1442:        buffer_skip_whitespace(input_buffer);
        -: 1443:    }
      111: 1444:    while (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ','));
        -: 1445:
      138: 1446:    if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != '}'))
        -: 1447:    {
        -: 1448:        goto fail; /* expected end of object */
        -: 1449:    }
        -: 1450:
       46: 1451:success:
       79: 1452:    input_buffer->depth--;
        -: 1453:
       79: 1454:    item->type = cJSON_Object;
       79: 1455:    item->child = head;
        -: 1456:
       79: 1457:    input_buffer->offset++;
       79: 1458:    return true;
        -: 1459:
    #####: 1460:fail:
        2: 1461:    if (head != NULL)
        -: 1462:    {
        2: 1463:        cJSON_Delete(head);
        -: 1464:    }
        -: 1465:
        2: 1466:    return false;
        -: 1467:}
        -: 1468:
        -: 1469:/* Render an object to text. */
       47: 1470:static cJSON_bool print_object(const cJSON * const item, printbuffer * const output_buffer)
        -: 1471:{
       47: 1472:    unsigned char *output_pointer = NULL;
       47: 1473:    size_t length = 0;
       47: 1474:    cJSON *current_item = item->child;
        -: 1475:
       47: 1476:    if (output_buffer == NULL)
        -: 1477:    {
    #####: 1478:        return false;
        -: 1479:    }
        -: 1480:
        -: 1481:    /* Compose the output: */
       47: 1482:    length = (size_t) (output_buffer->format ? 2 : 1); /* fmt: {\n */
       47: 1483:    output_pointer = ensure(output_buffer, length + 1);
       47: 1484:    if (output_pointer == NULL)
        -: 1485:    {
    #####: 1486:        return false;
        -: 1487:    }
        -: 1488:
       47: 1489:    *output_pointer++ = '{';
       47: 1490:    output_buffer->depth++;
       47: 1491:    if (output_buffer->format)
        -: 1492:    {
        9: 1493:        *output_pointer++ = '\n';
        -: 1494:    }
       47: 1495:    output_buffer->offset += length;
        -: 1496:
      165: 1497:    while (current_item)
        -: 1498:    {
       59: 1499:        if (output_buffer->format)
        -: 1500:        {
        -: 1501:            size_t i;
       14: 1502:            output_pointer = ensure(output_buffer, output_buffer->depth);
       14: 1503:            if (output_pointer == NULL)
        -: 1504:            {
    #####: 1505:                return false;
        -: 1506:            }
       28: 1507:            for (i = 0; i < output_buffer->depth; i++)
        -: 1508:            {
       14: 1509:                *output_pointer++ = '\t';
        -: 1510:            }
       14: 1511:            output_buffer->offset += output_buffer->depth;
        -: 1512:        }
        -: 1513:
        -: 1514:        /* print key */
       59: 1515:        if (!print_string_ptr((unsigned char*)current_item->string, output_buffer))
        -: 1516:        {
    #####: 1517:            return false;
        -: 1518:        }
       59: 1519:        update_offset(output_buffer);
        -: 1520:
       59: 1521:        length = (size_t) (output_buffer->format ? 2 : 1);
       59: 1522:        output_pointer = ensure(output_buffer, length);
       59: 1523:        if (output_pointer == NULL)
        -: 1524:        {
    #####: 1525:            return false;
        -: 1526:        }
       59: 1527:        *output_pointer++ = ':';
       59: 1528:        if (output_buffer->format)
        -: 1529:        {
       14: 1530:            *output_pointer++ = '\t';
        -: 1531:        }
       59: 1532:        output_buffer->offset += length;
        -: 1533:
        -: 1534:        /* print value */
       59: 1535:        if (!print_value(current_item, output_buffer))
        -: 1536:        {
    #####: 1537:            return false;
        -: 1538:        }
       59: 1539:        update_offset(output_buffer);
        -: 1540:
        -: 1541:        /* print comma if not last */
       59: 1542:        length = ((size_t)(output_buffer->format ? 1 : 0) + (size_t)(current_item->next ? 1 : 0));
       59: 1543:        output_pointer = ensure(output_buffer, length + 1);
       59: 1544:        if (output_pointer == NULL)
        -: 1545:        {
    #####: 1546:            return false;
        -: 1547:        }
       59: 1548:        if (current_item->next)
        -: 1549:        {
       19: 1550:            *output_pointer++ = ',';
        -: 1551:        }
        -: 1552:
       59: 1553:        if (output_buffer->format)
        -: 1554:        {
       14: 1555:            *output_pointer++ = '\n';
        -: 1556:        }
       59: 1557:        *output_pointer = '\0';
       59: 1558:        output_buffer->offset += length;
        -: 1559:
       59: 1560:        current_item = current_item->next;
        -: 1561:    }
        -: 1562:
       47: 1563:    output_pointer = ensure(output_buffer, output_buffer->format ? (output_buffer->depth + 1) : 2);
       47: 1564:    if (output_pointer == NULL)
        -: 1565:    {
    #####: 1566:        return false;
        -: 1567:    }
       47: 1568:    if (output_buffer->format)
        -: 1569:    {
        -: 1570:        size_t i;
       11: 1571:        for (i = 0; i < (output_buffer->depth - 1); i++)
        -: 1572:        {
        2: 1573:            *output_pointer++ = '\t';
        -: 1574:        }
        -: 1575:    }
       47: 1576:    *output_pointer++ = '}';
       47: 1577:    *output_pointer = '\0';
       47: 1578:    output_buffer->depth--;
        -: 1579:
       47: 1580:    return true;
        -: 1581:}
        -: 1582:
        -: 1583:/* Get Array size/item / object item. */
        8: 1584:CJSON_PUBLIC(int) cJSON_GetArraySize(const cJSON *array)
        -: 1585:{
        8: 1586:    cJSON *child = NULL;
        8: 1587:    size_t size = 0;
        -: 1588:
        8: 1589:    if (array == NULL)
        -: 1590:    {
        1: 1591:        return 0;
        -: 1592:    }
        -: 1593:
        7: 1594:    child = array->child;
        -: 1595:
       35: 1596:    while(child != NULL)
        -: 1597:    {
       14: 1598:        size++;
       14: 1599:        child = child->next;
        -: 1600:    }
        -: 1601:
        -: 1602:    /* FIXME: Can overflow here. Cannot be fixed without breaking the API */
        -: 1603:
        7: 1604:    return (int)size;
        -: 1605:}
        -: 1606:
        9: 1607:static cJSON* get_array_item(const cJSON *array, size_t index)
        -: 1608:{
        9: 1609:    cJSON *current_child = NULL;
        -: 1610:
        9: 1611:    if (array == NULL)
        -: 1612:    {
        4: 1613:        return NULL;
        -: 1614:    }
        -: 1615:
        5: 1616:    current_child = array->child;
       17: 1617:    while ((current_child != NULL) && (index > 0))
        -: 1618:    {
        6: 1619:        index--;
        6: 1620:        current_child = current_child->next;
        -: 1621:    }
        -: 1622:
        5: 1623:    return current_child;
        -: 1624:}
        -: 1625:
        1: 1626:CJSON_PUBLIC(cJSON *) cJSON_GetArrayItem(const cJSON *array, int index)
        -: 1627:{
        1: 1628:    if (index < 0)
        -: 1629:    {
    #####: 1630:        return NULL;
        -: 1631:    }
        -: 1632:
        1: 1633:    return get_array_item(array, (size_t)index);
        -: 1634:}
        -: 1635:
       53: 1636:static cJSON *get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)
        -: 1637:{
       53: 1638:    cJSON *current_element = NULL;
        -: 1639:
       53: 1640:    if ((object == NULL) || (name == NULL))
        -: 1641:    {
       13: 1642:        return NULL;
        -: 1643:    }
        -: 1644:
       40: 1645:    current_element = object->child;
       40: 1646:    if (case_sensitive)
        -: 1647:    {
      126: 1648:        while ((current_element != NULL) && (current_element->string != NULL) && (strcmp(name, current_element->string) != 0))
        -: 1649:        {
       53: 1650:            current_element = current_element->next;
        -: 1651:        }
        -: 1652:    }
        -: 1653:    else
        -: 1654:    {
      126: 1655:        while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))
        -: 1656:        {
       53: 1657:            current_element = current_element->next;
        -: 1658:        }
        -: 1659:    }
        -: 1660:
       40: 1661:    if ((current_element == NULL) || (current_element->string == NULL)) {
        4: 1662:        return NULL;
        -: 1663:    }
        -: 1664:
       36: 1665:    return current_element;
        -: 1666:}
        -: 1667:
        6: 1668:CJSON_PUBLIC(cJSON *) cJSON_GetObjectItem(const cJSON * const object, const char * const string)
        -: 1669:{
        6: 1670:    return get_object_item(object, string, false);
        -: 1671:}
        -: 1672:
        5: 1673:CJSON_PUBLIC(cJSON *) cJSON_GetObjectItemCaseSensitive(const cJSON * const object, const char * const string)
        -: 1674:{
        5: 1675:    return get_object_item(object, string, true);
        -: 1676:}
        -: 1677:
        1: 1678:CJSON_PUBLIC(cJSON_bool) cJSON_HasObjectItem(const cJSON *object, const char *string)
        -: 1679:{
        1: 1680:    return cJSON_GetObjectItem(object, string) ? 1 : 0;
        -: 1681:}
        -: 1682:
        -: 1683:/* Utility for array list handling. */
       47: 1684:static void suffix_object(cJSON *prev, cJSON *item)
        -: 1685:{
       47: 1686:    prev->next = item;
       47: 1687:    item->prev = prev;
       47: 1688:}
        -: 1689:
        -: 1690:/* Utility for handling references. */
        3: 1691:static cJSON *create_reference(const cJSON *item, const internal_hooks * const hooks)
        -: 1692:{
        3: 1693:    cJSON *reference = NULL;
        3: 1694:    if (item == NULL)
        -: 1695:    {
        2: 1696:        return NULL;
        -: 1697:    }
        -: 1698:
        1: 1699:    reference = cJSON_New_Item(hooks);
        1: 1700:    if (reference == NULL)
        -: 1701:    {
    #####: 1702:        return NULL;
        -: 1703:    }
        -: 1704:
        1: 1705:    memcpy(reference, item, sizeof(cJSON));
        1: 1706:    reference->string = NULL;
        1: 1707:    reference->type |= cJSON_IsReference;
        1: 1708:    reference->next = reference->prev = NULL;
        1: 1709:    return reference;
        -: 1710:}
        -: 1711:
       27: 1712:static cJSON_bool add_item_to_array(cJSON *array, cJSON *item)
        -: 1713:{
       27: 1714:    cJSON *child = NULL;
        -: 1715:
       27: 1716:    if ((item == NULL) || (array == NULL))
        -: 1717:    {
        3: 1718:        return false;
        -: 1719:    }
        -: 1720:
       24: 1721:    child = array->child;
        -: 1722:
       24: 1723:    if (child == NULL)
        -: 1724:    {
        -: 1725:        /* list is empty, start new one */
       16: 1726:        array->child = item;
        -: 1727:    }
        -: 1728:    else
        -: 1729:    {
        -: 1730:        /* append to the end */
       14: 1731:        while (child->next)
        -: 1732:        {
        3: 1733:            child = child->next;
        -: 1734:        }
        8: 1735:        suffix_object(child, item);
        -: 1736:    }
        -: 1737:
       24: 1738:    return true;
        -: 1739:}
        -: 1740:
        -: 1741:/* Add item to array/object. */
        7: 1742:CJSON_PUBLIC(void) cJSON_AddItemToArray(cJSON *array, cJSON *item)
        -: 1743:{
        7: 1744:    add_item_to_array(array, item);
        7: 1745:}
        -: 1746:
        -: 1747:#if defined(__clang__) || (defined(__GNUC__)  && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 5))))
        -: 1748:    #pragma GCC diagnostic push
        -: 1749:#endif
        -: 1750:#ifdef __GNUC__
        -: 1751:#pragma GCC diagnostic ignored "-Wcast-qual"
        -: 1752:#endif
        -: 1753:/* helper function to cast away const */
        4: 1754:static void* cast_away_const(const void* string)
        -: 1755:{
        4: 1756:    return (void*)string;
        -: 1757:}
        -: 1758:#if defined(__clang__) || (defined(__GNUC__)  && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 5))))
        -: 1759:    #pragma GCC diagnostic pop
        -: 1760:#endif
        -: 1761:
        -: 1762:
       40: 1763:static cJSON_bool add_item_to_object(cJSON * const object, const char * const string, cJSON * const item, const internal_hooks * const hooks, const cJSON_bool constant_key)
        -: 1764:{
       40: 1765:    char *new_key = NULL;
       40: 1766:    int new_type = cJSON_Invalid;
        -: 1767:
       40: 1768:    if ((object == NULL) || (string == NULL) || (item == NULL))
        -: 1769:    {
       25: 1770:        return false;
        -: 1771:    }
        -: 1772:
       15: 1773:    if (constant_key)
        -: 1774:    {
        1: 1775:        new_key = (char*)cast_away_const(string);
        1: 1776:        new_type = item->type | cJSON_StringIsConst;
        -: 1777:    }
        -: 1778:    else
        -: 1779:    {
       14: 1780:        new_key = (char*)cJSON_strdup((const unsigned char*)string, hooks);
       14: 1781:        if (new_key == NULL)
        -: 1782:        {
    #####: 1783:            return false;
        -: 1784:        }
        -: 1785:
       14: 1786:        new_type = item->type & ~cJSON_StringIsConst;
        -: 1787:    }
        -: 1788:
       15: 1789:    if (!(item->type & cJSON_StringIsConst) && (item->string != NULL))
        -: 1790:    {
    #####: 1791:        hooks->deallocate(item->string);
        -: 1792:    }
        -: 1793:
       15: 1794:    item->string = new_key;
       15: 1795:    item->type = new_type;
        -: 1796:
       15: 1797:    return add_item_to_array(object, item);
        -: 1798:}
        -: 1799:
        1: 1800:CJSON_PUBLIC(void) cJSON_AddItemToObject(cJSON *object, const char *string, cJSON *item)
        -: 1801:{
        1: 1802:    add_item_to_object(object, string, item, &global_hooks, false);
        1: 1803:}
        -: 1804:
        -: 1805:/* Add an item to an object with constant string as key */
        1: 1806:CJSON_PUBLIC(void) cJSON_AddItemToObjectCS(cJSON *object, const char *string, cJSON *item)
        -: 1807:{
        1: 1808:    add_item_to_object(object, string, item, &global_hooks, true);
        1: 1809:}
        -: 1810:
        3: 1811:CJSON_PUBLIC(void) cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)
        -: 1812:{
        3: 1813:    if (array == NULL)
        -: 1814:    {
        1: 1815:        return;
        -: 1816:    }
        -: 1817:
        2: 1818:    add_item_to_array(array, create_reference(item, &global_hooks));
        -: 1819:}
        -: 1820:
        3: 1821:CJSON_PUBLIC(void) cJSON_AddItemReferenceToObject(cJSON *object, const char *string, cJSON *item)
        -: 1822:{
        3: 1823:    if ((object == NULL) || (string == NULL))
        -: 1824:    {
        2: 1825:        return;
        -: 1826:    }
        -: 1827:
        1: 1828:    add_item_to_object(object, string, create_reference(item, &global_hooks), &global_hooks, false);
        -: 1829:}
        -: 1830:
        2: 1831:CJSON_PUBLIC(cJSON*) cJSON_AddNullToObject(cJSON * const object, const char * const name)
        -: 1832:{
        2: 1833:    cJSON *null = cJSON_CreateNull();
        2: 1834:    if (add_item_to_object(object, name, null, &global_hooks, false))
        -: 1835:    {
        1: 1836:        return null;
        -: 1837:    }
        -: 1838:
        1: 1839:    cJSON_Delete(null);
        1: 1840:    return NULL;
        -: 1841:}
        -: 1842:
        3: 1843:CJSON_PUBLIC(cJSON*) cJSON_AddTrueToObject(cJSON * const object, const char * const name)
        -: 1844:{
        3: 1845:    cJSON *true_item = cJSON_CreateTrue();
        3: 1846:    if (add_item_to_object(object, name, true_item, &global_hooks, false))
        -: 1847:    {
        1: 1848:        return true_item;
        -: 1849:    }
        -: 1850:
        2: 1851:    cJSON_Delete(true_item);
        2: 1852:    return NULL;
        -: 1853:}
        -: 1854:
        4: 1855:CJSON_PUBLIC(cJSON*) cJSON_AddFalseToObject(cJSON * const object, const char * const name)
        -: 1856:{
        4: 1857:    cJSON *false_item = cJSON_CreateFalse();
        4: 1858:    if (add_item_to_object(object, name, false_item, &global_hooks, false))
        -: 1859:    {
        1: 1860:        return false_item;
        -: 1861:    }
        -: 1862:
        3: 1863:    cJSON_Delete(false_item);
        3: 1864:    return NULL;
        -: 1865:}
        -: 1866:
        5: 1867:CJSON_PUBLIC(cJSON*) cJSON_AddBoolToObject(cJSON * const object, const char * const name, const cJSON_bool boolean)
        -: 1868:{
        5: 1869:    cJSON *bool_item = cJSON_CreateBool(boolean);
        5: 1870:    if (add_item_to_object(object, name, bool_item, &global_hooks, false))
        -: 1871:    {
        3: 1872:        return bool_item;
        -: 1873:    }
        -: 1874:
        2: 1875:    cJSON_Delete(bool_item);
        2: 1876:    return NULL;
        -: 1877:}
        -: 1878:
        6: 1879:CJSON_PUBLIC(cJSON*) cJSON_AddNumberToObject(cJSON * const object, const char * const name, const double number)
        -: 1880:{
        6: 1881:    cJSON *number_item = cJSON_CreateNumber(number);
        6: 1882:    if (add_item_to_object(object, name, number_item, &global_hooks, false))
        -: 1883:    {
    #####: 1884:        return number_item;
        -: 1885:    }
        -: 1886:
        6: 1887:    cJSON_Delete(number_item);
        6: 1888:    return NULL;
        -: 1889:}
        -: 1890:
        4: 1891:CJSON_PUBLIC(cJSON*) cJSON_AddStringToObject(cJSON * const object, const char * const name, const char * const string)
        -: 1892:{
        4: 1893:    cJSON *string_item = cJSON_CreateString(string);
        4: 1894:    if (add_item_to_object(object, name, string_item, &global_hooks, false))
        -: 1895:    {
    #####: 1896:        return string_item;
        -: 1897:    }
        -: 1898:
        4: 1899:    cJSON_Delete(string_item);
        4: 1900:    return NULL;
        -: 1901:}
        -: 1902:
        4: 1903:CJSON_PUBLIC(cJSON*) cJSON_AddRawToObject(cJSON * const object, const char * const name, const char * const raw)
        -: 1904:{
        4: 1905:    cJSON *raw_item = cJSON_CreateRaw(raw);
        4: 1906:    if (add_item_to_object(object, name, raw_item, &global_hooks, false))
        -: 1907:    {
        2: 1908:        return raw_item;
        -: 1909:    }
        -: 1910:
        2: 1911:    cJSON_Delete(raw_item);
        2: 1912:    return NULL;
        -: 1913:}
        -: 1914:
        3: 1915:CJSON_PUBLIC(cJSON*) cJSON_AddObjectToObject(cJSON * const object, const char * const name)
        -: 1916:{
        3: 1917:    cJSON *object_item = cJSON_CreateObject();
        3: 1918:    if (add_item_to_object(object, name, object_item, &global_hooks, false))
        -: 1919:    {
        1: 1920:        return object_item;
        -: 1921:    }
        -: 1922:
        2: 1923:    cJSON_Delete(object_item);
        2: 1924:    return NULL;
        -: 1925:}
        -: 1926:
        6: 1927:CJSON_PUBLIC(cJSON*) cJSON_AddArrayToObject(cJSON * const object, const char * const name)
        -: 1928:{
        6: 1929:    cJSON *array = cJSON_CreateArray();
        6: 1930:    if (add_item_to_object(object, name, array, &global_hooks, false))
        -: 1931:    {
        4: 1932:        return array;
        -: 1933:    }
        -: 1934:
        2: 1935:    cJSON_Delete(array);
        2: 1936:    return NULL;
        -: 1937:}
        -: 1938:
       12: 1939:CJSON_PUBLIC(cJSON *) cJSON_DetachItemViaPointer(cJSON *parent, cJSON * const item)
        -: 1940:{
       12: 1941:    if ((parent == NULL) || (item == NULL))
        -: 1942:    {
       10: 1943:        return NULL;
        -: 1944:    }
        -: 1945:
        2: 1946:    if (item->prev != NULL)
        -: 1947:    {
        -: 1948:        /* not the first element */
        2: 1949:        item->prev->next = item->next;
        -: 1950:    }
        2: 1951:    if (item->next != NULL)
        -: 1952:    {
        -: 1953:        /* not the last element */
        2: 1954:        item->next->prev = item->prev;
        -: 1955:    }
        -: 1956:
        2: 1957:    if (item == parent->child)
        -: 1958:    {
        -: 1959:        /* first element */
        1: 1960:        parent->child = item->next;
        -: 1961:    }
        -: 1962:    /* make sure the detached item doesn't point anywhere anymore */
        2: 1963:    item->prev = NULL;
        2: 1964:    item->next = NULL;
        -: 1965:
        2: 1966:    return item;
        -: 1967:}
        -: 1968:
        3: 1969:CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromArray(cJSON *array, int which)
        -: 1970:{
        3: 1971:    if (which < 0)
        -: 1972:    {
        1: 1973:        return NULL;
        -: 1974:    }
        -: 1975:
        2: 1976:    return cJSON_DetachItemViaPointer(array, get_array_item(array, (size_t)which));
        -: 1977:}
        -: 1978:
        1: 1979:CJSON_PUBLIC(void) cJSON_DeleteItemFromArray(cJSON *array, int which)
        -: 1980:{
        1: 1981:    cJSON_Delete(cJSON_DetachItemFromArray(array, which));
        1: 1982:}
        -: 1983:
        4: 1984:CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObject(cJSON *object, const char *string)
        -: 1985:{
        4: 1986:    cJSON *to_detach = cJSON_GetObjectItem(object, string);
        -: 1987:
        4: 1988:    return cJSON_DetachItemViaPointer(object, to_detach);
        -: 1989:}
        -: 1990:
        4: 1991:CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObjectCaseSensitive(cJSON *object, const char *string)
        -: 1992:{
        4: 1993:    cJSON *to_detach = cJSON_GetObjectItemCaseSensitive(object, string);
        -: 1994:
        4: 1995:    return cJSON_DetachItemViaPointer(object, to_detach);
        -: 1996:}
        -: 1997:
        2: 1998:CJSON_PUBLIC(void) cJSON_DeleteItemFromObject(cJSON *object, const char *string)
        -: 1999:{
        2: 2000:    cJSON_Delete(cJSON_DetachItemFromObject(object, string));
        2: 2001:}
        -: 2002:
        2: 2003:CJSON_PUBLIC(void) cJSON_DeleteItemFromObjectCaseSensitive(cJSON *object, const char *string)
        -: 2004:{
        2: 2005:    cJSON_Delete(cJSON_DetachItemFromObjectCaseSensitive(object, string));
        2: 2006:}
        -: 2007:
        -: 2008:/* Replace array/object items with new ones. */
        4: 2009:CJSON_PUBLIC(void) cJSON_InsertItemInArray(cJSON *array, int which, cJSON *newitem)
        -: 2010:{
        4: 2011:    cJSON *after_inserted = NULL;
        -: 2012:
        4: 2013:    if (which < 0)
        -: 2014:    {
        1: 2015:        return;
        -: 2016:    }
        -: 2017:
        3: 2018:    after_inserted = get_array_item(array, (size_t)which);
        3: 2019:    if (after_inserted == NULL)
        -: 2020:    {
        3: 2021:        add_item_to_array(array, newitem);
        3: 2022:        return;
        -: 2023:    }
        -: 2024:
    #####: 2025:    newitem->next = after_inserted;
    #####: 2026:    newitem->prev = after_inserted->prev;
    #####: 2027:    after_inserted->prev = newitem;
    #####: 2028:    if (after_inserted == array->child)
        -: 2029:    {
    #####: 2030:        array->child = newitem;
        -: 2031:    }
        -: 2032:    else
        -: 2033:    {
    #####: 2034:        newitem->prev->next = newitem;
        -: 2035:    }
        -: 2036:}
        -: 2037:
       11: 2038:CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemViaPointer(cJSON * const parent, cJSON * const item, cJSON * replacement)
        -: 2039:{
       11: 2040:    if ((parent == NULL) || (replacement == NULL) || (item == NULL))
        -: 2041:    {
        8: 2042:        return false;
        -: 2043:    }
        -: 2044:
        3: 2045:    if (replacement == item)
        -: 2046:    {
        1: 2047:        return true;
        -: 2048:    }
        -: 2049:
        2: 2050:    replacement->next = item->next;
        2: 2051:    replacement->prev = item->prev;
        -: 2052:
        2: 2053:    if (replacement->next != NULL)
        -: 2054:    {
        1: 2055:        replacement->next->prev = replacement;
        -: 2056:    }
        2: 2057:    if (replacement->prev != NULL)
        -: 2058:    {
        2: 2059:        replacement->prev->next = replacement;
        -: 2060:    }
        2: 2061:    if (parent->child == item)
        -: 2062:    {
    #####: 2063:        parent->child = replacement;
        -: 2064:    }
        -: 2065:
        2: 2066:    item->next = NULL;
        2: 2067:    item->prev = NULL;
        2: 2068:    cJSON_Delete(item);
        -: 2069:
        2: 2070:    return true;
        -: 2071:}
        -: 2072:
        4: 2073:CJSON_PUBLIC(void) cJSON_ReplaceItemInArray(cJSON *array, int which, cJSON *newitem)
        -: 2074:{
        4: 2075:    if (which < 0)
        -: 2076:    {
        1: 2077:        return;
        -: 2078:    }
        -: 2079:
        3: 2080:    cJSON_ReplaceItemViaPointer(array, get_array_item(array, (size_t)which), newitem);
        -: 2081:}
        -: 2082:
        7: 2083:static cJSON_bool replace_item_in_object(cJSON *object, const char *string, cJSON *replacement, cJSON_bool case_sensitive)
        -: 2084:{
        7: 2085:    if ((replacement == NULL) || (string == NULL))
        -: 2086:    {
        5: 2087:        return false;
        -: 2088:    }
        -: 2089:
        -: 2090:    /* replace the name in the replacement */
        2: 2091:    if (!(replacement->type & cJSON_StringIsConst) && (replacement->string != NULL))
        -: 2092:    {
        1: 2093:        cJSON_free(replacement->string);
        -: 2094:    }
        2: 2095:    replacement->string = (char*)cJSON_strdup((const unsigned char*)string, &global_hooks);
        2: 2096:    replacement->type &= ~cJSON_StringIsConst;
        -: 2097:
        2: 2098:    cJSON_ReplaceItemViaPointer(object, get_object_item(object, string, case_sensitive), replacement);
        -: 2099:
        2: 2100:    return true;
        -: 2101:}
        -: 2102:
        4: 2103:CJSON_PUBLIC(void) cJSON_ReplaceItemInObject(cJSON *object, const char *string, cJSON *newitem)
        -: 2104:{
        4: 2105:    replace_item_in_object(object, string, newitem, false);
        4: 2106:}
        -: 2107:
        3: 2108:CJSON_PUBLIC(void) cJSON_ReplaceItemInObjectCaseSensitive(cJSON *object, const char *string, cJSON *newitem)
        -: 2109:{
        3: 2110:    replace_item_in_object(object, string, newitem, true);
        3: 2111:}
        -: 2112:
        -: 2113:/* Create basic types: */
        8: 2114:CJSON_PUBLIC(cJSON *) cJSON_CreateNull(void)
        -: 2115:{
        8: 2116:    cJSON *item = cJSON_New_Item(&global_hooks);
        8: 2117:    if(item)
        -: 2118:    {
        8: 2119:        item->type = cJSON_NULL;
        -: 2120:    }
        -: 2121:
        8: 2122:    return item;
        -: 2123:}
        -: 2124:
        3: 2125:CJSON_PUBLIC(cJSON *) cJSON_CreateTrue(void)
        -: 2126:{
        3: 2127:    cJSON *item = cJSON_New_Item(&global_hooks);
        3: 2128:    if(item)
        -: 2129:    {
        3: 2130:        item->type = cJSON_True;
        -: 2131:    }
        -: 2132:
        3: 2133:    return item;
        -: 2134:}
        -: 2135:
        4: 2136:CJSON_PUBLIC(cJSON *) cJSON_CreateFalse(void)
        -: 2137:{
        4: 2138:    cJSON *item = cJSON_New_Item(&global_hooks);
        4: 2139:    if(item)
        -: 2140:    {
        4: 2141:        item->type = cJSON_False;
        -: 2142:    }
        -: 2143:
        4: 2144:    return item;
        -: 2145:}
        -: 2146:
        5: 2147:CJSON_PUBLIC(cJSON *) cJSON_CreateBool(cJSON_bool boolean)
        -: 2148:{
        5: 2149:    cJSON *item = cJSON_New_Item(&global_hooks);
        5: 2150:    if(item)
        -: 2151:    {
        5: 2152:        item->type = boolean ? cJSON_True : cJSON_False;
        -: 2153:    }
        -: 2154:
        5: 2155:    return item;
        -: 2156:}
        -: 2157:
       46: 2158:CJSON_PUBLIC(cJSON *) cJSON_CreateNumber(double num)
        -: 2159:{
       46: 2160:    cJSON *item = cJSON_New_Item(&global_hooks);
       46: 2161:    if(item)
        -: 2162:    {
       46: 2163:        item->type = cJSON_Number;
       46: 2164:        item->valuedouble = num;
        -: 2165:
        -: 2166:        /* use saturation in case of overflow */
       46: 2167:        if (num >= INT_MAX)
        -: 2168:        {
    #####: 2169:            item->valueint = INT_MAX;
        -: 2170:        }
       46: 2171:        else if (num <= (double)INT_MIN)
        -: 2172:        {
        2: 2173:            item->valueint = INT_MIN;
        -: 2174:        }
        -: 2175:        else
        -: 2176:        {
       44: 2177:            item->valueint = (int)num;
        -: 2178:        }
        -: 2179:    }
        -: 2180:
       46: 2181:    return item;
        -: 2182:}
        -: 2183:
       25: 2184:CJSON_PUBLIC(cJSON *) cJSON_CreateString(const char *string)
        -: 2185:{
       25: 2186:    cJSON *item = cJSON_New_Item(&global_hooks);
       25: 2187:    if(item)
        -: 2188:    {
       25: 2189:        item->type = cJSON_String;
       25: 2190:        item->valuestring = (char*)cJSON_strdup((const unsigned char*)string, &global_hooks);
       25: 2191:        if(!item->valuestring)
        -: 2192:        {
    #####: 2193:            cJSON_Delete(item);
    #####: 2194:            return NULL;
        -: 2195:        }
        -: 2196:    }
        -: 2197:
       25: 2198:    return item;
        -: 2199:}
        -: 2200:
        1: 2201:CJSON_PUBLIC(cJSON *) cJSON_CreateStringReference(const char *string)
        -: 2202:{
        1: 2203:    cJSON *item = cJSON_New_Item(&global_hooks);
        1: 2204:    if (item != NULL)
        -: 2205:    {
        1: 2206:        item->type = cJSON_String | cJSON_IsReference;
        1: 2207:        item->valuestring = (char*)cast_away_const(string);
        -: 2208:    }
        -: 2209:
        1: 2210:    return item;
        -: 2211:}
        -: 2212:
        1: 2213:CJSON_PUBLIC(cJSON *) cJSON_CreateObjectReference(const cJSON *child)
        -: 2214:{
        1: 2215:    cJSON *item = cJSON_New_Item(&global_hooks);
        1: 2216:    if (item != NULL) {
        1: 2217:        item->type = cJSON_Object | cJSON_IsReference;
        1: 2218:        item->child = (cJSON*)cast_away_const(child);
        -: 2219:    }
        -: 2220:
        1: 2221:    return item;
        -: 2222:}
        -: 2223:
        1: 2224:CJSON_PUBLIC(cJSON *) cJSON_CreateArrayReference(const cJSON *child) {
        1: 2225:    cJSON *item = cJSON_New_Item(&global_hooks);
        1: 2226:    if (item != NULL) {
        1: 2227:        item->type = cJSON_Array | cJSON_IsReference;
        1: 2228:        item->child = (cJSON*)cast_away_const(child);
        -: 2229:    }
        -: 2230:
        1: 2231:    return item;
        -: 2232:}
        -: 2233:
        4: 2234:CJSON_PUBLIC(cJSON *) cJSON_CreateRaw(const char *raw)
        -: 2235:{
        4: 2236:    cJSON *item = cJSON_New_Item(&global_hooks);
        4: 2237:    if(item)
        -: 2238:    {
        4: 2239:        item->type = cJSON_Raw;
        4: 2240:        item->valuestring = (char*)cJSON_strdup((const unsigned char*)raw, &global_hooks);
        4: 2241:        if(!item->valuestring)
        -: 2242:        {
    #####: 2243:            cJSON_Delete(item);
    #####: 2244:            return NULL;
        -: 2245:        }
        -: 2246:    }
        -: 2247:
        4: 2248:    return item;
        -: 2249:}
        -: 2250:
       18: 2251:CJSON_PUBLIC(cJSON *) cJSON_CreateArray(void)
        -: 2252:{
       18: 2253:    cJSON *item = cJSON_New_Item(&global_hooks);
       18: 2254:    if(item)
        -: 2255:    {
       18: 2256:        item->type=cJSON_Array;
        -: 2257:    }
        -: 2258:
       18: 2259:    return item;
        -: 2260:}
        -: 2261:
       13: 2262:CJSON_PUBLIC(cJSON *) cJSON_CreateObject(void)
        -: 2263:{
       13: 2264:    cJSON *item = cJSON_New_Item(&global_hooks);
       13: 2265:    if (item)
        -: 2266:    {
       13: 2267:        item->type = cJSON_Object;
        -: 2268:    }
        -: 2269:
       13: 2270:    return item;
        -: 2271:}
        -: 2272:
        -: 2273:/* Create Arrays: */
        5: 2274:CJSON_PUBLIC(cJSON *) cJSON_CreateIntArray(const int *numbers, int count)
        -: 2275:{
        5: 2276:    size_t i = 0;
        5: 2277:    cJSON *n = NULL;
        5: 2278:    cJSON *p = NULL;
        5: 2279:    cJSON *a = NULL;
        -: 2280:
        5: 2281:    if ((count < 0) || (numbers == NULL))
        -: 2282:    {
        1: 2283:        return NULL;
        -: 2284:    }
        -: 2285:
        4: 2286:    a = cJSON_CreateArray();
       23: 2287:    for(i = 0; a && (i < (size_t)count); i++)
        -: 2288:    {
       19: 2289:        n = cJSON_CreateNumber(numbers[i]);
       19: 2290:        if (!n)
        -: 2291:        {
    #####: 2292:            cJSON_Delete(a);
    #####: 2293:            return NULL;
        -: 2294:        }
       19: 2295:        if(!i)
        -: 2296:        {
        4: 2297:            a->child = n;
        -: 2298:        }
        -: 2299:        else
        -: 2300:        {
       15: 2301:            suffix_object(p, n);
        -: 2302:        }
       19: 2303:        p = n;
        -: 2304:    }
        -: 2305:
        4: 2306:    return a;
        -: 2307:}
        -: 2308:
        2: 2309:CJSON_PUBLIC(cJSON *) cJSON_CreateFloatArray(const float *numbers, int count)
        -: 2310:{
        2: 2311:    size_t i = 0;
        2: 2312:    cJSON *n = NULL;
        2: 2313:    cJSON *p = NULL;
        2: 2314:    cJSON *a = NULL;
        -: 2315:
        2: 2316:    if ((count < 0) || (numbers == NULL))
        -: 2317:    {
        1: 2318:        return NULL;
        -: 2319:    }
        -: 2320:
        1: 2321:    a = cJSON_CreateArray();
        -: 2322:
       11: 2323:    for(i = 0; a && (i < (size_t)count); i++)
        -: 2324:    {
       10: 2325:        n = cJSON_CreateNumber((double)numbers[i]);
       10: 2326:        if(!n)
        -: 2327:        {
    #####: 2328:            cJSON_Delete(a);
    #####: 2329:            return NULL;
        -: 2330:        }
       10: 2331:        if(!i)
        -: 2332:        {
        1: 2333:            a->child = n;
        -: 2334:        }
        -: 2335:        else
        -: 2336:        {
        9: 2337:            suffix_object(p, n);
        -: 2338:        }
       10: 2339:        p = n;
        -: 2340:    }
        -: 2341:
        1: 2342:    return a;
        -: 2343:}
        -: 2344:
        2: 2345:CJSON_PUBLIC(cJSON *) cJSON_CreateDoubleArray(const double *numbers, int count)
        -: 2346:{
        2: 2347:    size_t i = 0;
        2: 2348:    cJSON *n = NULL;
        2: 2349:    cJSON *p = NULL;
        2: 2350:    cJSON *a = NULL;
        -: 2351:
        2: 2352:    if ((count < 0) || (numbers == NULL))
        -: 2353:    {
        1: 2354:        return NULL;
        -: 2355:    }
        -: 2356:
        1: 2357:    a = cJSON_CreateArray();
        -: 2358:
       11: 2359:    for(i = 0;a && (i < (size_t)count); i++)
        -: 2360:    {
       10: 2361:        n = cJSON_CreateNumber(numbers[i]);
       10: 2362:        if(!n)
        -: 2363:        {
    #####: 2364:            cJSON_Delete(a);
    #####: 2365:            return NULL;
        -: 2366:        }
       10: 2367:        if(!i)
        -: 2368:        {
        1: 2369:            a->child = n;
        -: 2370:        }
        -: 2371:        else
        -: 2372:        {
        9: 2373:            suffix_object(p, n);
        -: 2374:        }
       10: 2375:        p = n;
        -: 2376:    }
        -: 2377:
        1: 2378:    return a;
        -: 2379:}
        -: 2380:
        2: 2381:CJSON_PUBLIC(cJSON *) cJSON_CreateStringArray(const char *const *strings, int count)
        -: 2382:{
        2: 2383:    size_t i = 0;
        2: 2384:    cJSON *n = NULL;
        2: 2385:    cJSON *p = NULL;
        2: 2386:    cJSON *a = NULL;
        -: 2387:
        2: 2388:    if ((count < 0) || (strings == NULL))
        -: 2389:    {
        1: 2390:        return NULL;
        -: 2391:    }
        -: 2392:
        1: 2393:    a = cJSON_CreateArray();
        -: 2394:
        8: 2395:    for (i = 0; a && (i < (size_t)count); i++)
        -: 2396:    {
        7: 2397:        n = cJSON_CreateString(strings[i]);
        7: 2398:        if(!n)
        -: 2399:        {
    #####: 2400:            cJSON_Delete(a);
    #####: 2401:            return NULL;
        -: 2402:        }
        7: 2403:        if(!i)
        -: 2404:        {
        1: 2405:            a->child = n;
        -: 2406:        }
        -: 2407:        else
        -: 2408:        {
        6: 2409:            suffix_object(p,n);
        -: 2410:        }
        7: 2411:        p = n;
        -: 2412:    }
        -: 2413:
        1: 2414:    return a;
        -: 2415:}
        -: 2416:
        -: 2417:/* Duplication */
        4: 2418:CJSON_PUBLIC(cJSON *) cJSON_Duplicate(const cJSON *item, cJSON_bool recurse)
        -: 2419:{
        4: 2420:    cJSON *newitem = NULL;
        4: 2421:    cJSON *child = NULL;
        4: 2422:    cJSON *next = NULL;
        4: 2423:    cJSON *newchild = NULL;
        -: 2424:
        -: 2425:    /* Bail on bad ptr */
        4: 2426:    if (!item)
        -: 2427:    {
        1: 2428:        goto fail;
        -: 2429:    }
        -: 2430:    /* Create new item */
        3: 2431:    newitem = cJSON_New_Item(&global_hooks);
        3: 2432:    if (!newitem)
        -: 2433:    {
    #####: 2434:        goto fail;
        -: 2435:    }
        -: 2436:    /* Copy over all vars */
        3: 2437:    newitem->type = item->type & (~cJSON_IsReference);
        3: 2438:    newitem->valueint = item->valueint;
        3: 2439:    newitem->valuedouble = item->valuedouble;
        3: 2440:    if (item->valuestring)
        -: 2441:    {
        2: 2442:        newitem->valuestring = (char*)cJSON_strdup((unsigned char*)item->valuestring, &global_hooks);
        2: 2443:        if (!newitem->valuestring)
        -: 2444:        {
    #####: 2445:            goto fail;
        -: 2446:        }
        -: 2447:    }
        3: 2448:    if (item->string)
        -: 2449:    {
    #####: 2450:        newitem->string = (item->type&cJSON_StringIsConst) ? item->string : (char*)cJSON_strdup((unsigned char*)item->string, &global_hooks);
    #####: 2451:        if (!newitem->string)
        -: 2452:        {
    #####: 2453:            goto fail;
        -: 2454:        }
        -: 2455:    }
        -: 2456:    /* If non-recursive, then we're done! */
        3: 2457:    if (!recurse)
        -: 2458:    {
    #####: 2459:        return newitem;
        -: 2460:    }
        -: 2461:    /* Walk the ->next chain for the child. */
        3: 2462:    child = item->child;
        5: 2463:    while (child != NULL)
        -: 2464:    {
        1: 2465:        newchild = cJSON_Duplicate(child, true); /* Duplicate (with recurse) each item in the ->next chain */
        1: 2466:        if (!newchild)
        -: 2467:        {
    #####: 2468:            goto fail;
        -: 2469:        }
        1: 2470:        if (next != NULL)
        -: 2471:        {
        -: 2472:            /* If newitem->child already set, then crosswire ->prev and ->next and move on */
    #####: 2473:            next->next = newchild;
    #####: 2474:            newchild->prev = next;
    #####: 2475:            next = newchild;
        -: 2476:        }
        -: 2477:        else
        -: 2478:        {
        -: 2479:            /* Set newitem->child and move to it */
        1: 2480:            newitem->child = newchild;
        1: 2481:            next = newchild;
        -: 2482:        }
        1: 2483:        child = child->next;
        -: 2484:    }
        -: 2485:
        3: 2486:    return newitem;
        -: 2487:
        1: 2488:fail:
        1: 2489:    if (newitem != NULL)
        -: 2490:    {
    #####: 2491:        cJSON_Delete(newitem);
        -: 2492:    }
        -: 2493:
        1: 2494:    return NULL;
        -: 2495:}
        -: 2496:
        1: 2497:static void skip_oneline_comment(char **input)
        -: 2498:{
        1: 2499:    *input += static_strlen("//");
        -: 2500:
      111: 2501:    for (; (*input)[0] != '\0'; ++(*input))
        -: 2502:    {
       56: 2503:        if ((*input)[0] == '\n') {
        1: 2504:            *input += static_strlen("\n");
        1: 2505:            return;
        -: 2506:        }
        -: 2507:    }
        -: 2508:}
        -: 2509:
    #####: 2510:static void skip_multiline_comment(char **input)
        -: 2511:{
    #####: 2512:    *input += static_strlen("/*");
        -: 2513:
    #####: 2514:    for (; (*input)[0] != '\0'; ++(*input))
        -: 2515:    {
    #####: 2516:        if (((*input)[0] == '*') && ((*input)[1] == '/'))
        -: 2517:        {
    #####: 2518:            *input += static_strlen("*/");
    #####: 2519:            return;
        -: 2520:        }
        -: 2521:    }
        -: 2522:}
        -: 2523:
        2: 2524:static void minify_string(char **input, char **output) {
        2: 2525:    (*output)[0] = (*input)[0];
        2: 2526:    *input += static_strlen("\"");
        2: 2527:    *output += static_strlen("\"");
        -: 2528:
        -: 2529:
       18: 2530:    for (; (*input)[0] != '\0'; (void)++(*input), ++(*output)) {
        8: 2531:        (*output)[0] = (*input)[0];
        -: 2532:
        8: 2533:        if ((*input)[0] == '\"') {
    #####: 2534:            (*output)[0] = '\"';
    #####: 2535:            *input += static_strlen("\"");
    #####: 2536:            *output += static_strlen("\"");
    #####: 2537:            return;
        8: 2538:        } else if (((*input)[0] == '\\') && ((*input)[1] == '\"')) {
    #####: 2539:            (*output)[1] = (*input)[1];
    #####: 2540:            *input += static_strlen("\"");
    #####: 2541:            *output += static_strlen("\"");
        -: 2542:        }
        -: 2543:    }
        -: 2544:}
        -: 2545:
        3: 2546:CJSON_PUBLIC(void) cJSON_Minify(char *json)
        -: 2547:{
        3: 2548:    char *into = json;
        -: 2549:
        3: 2550:    if (json == NULL)
        -: 2551:    {
    #####: 2552:        return;
        -: 2553:    }
        -: 2554:
       13: 2555:    while (json[0] != '\0')
        -: 2556:    {
        5: 2557:        switch (json[0])
        -: 2558:        {
    #####: 2559:            case ' ':
        -: 2560:            case '\t':
        -: 2561:            case '\r':
        -: 2562:            case '\n':
    #####: 2563:                json++;
    #####: 2564:                break;
        -: 2565:
        1: 2566:            case '/':
        1: 2567:                if (json[1] == '/')
        -: 2568:                {
        1: 2569:                    skip_oneline_comment(&json);
        -: 2570:                }
    #####: 2571:                else if (json[1] == '*')
        -: 2572:                {
    #####: 2573:                    skip_multiline_comment(&json);
        -: 2574:                } else {
    #####: 2575:                    json++;
        -: 2576:                }
        1: 2577:                break;
        -: 2578:
        2: 2579:            case '\"':
        2: 2580:                minify_string(&json, (char**)&into);
        2: 2581:                break;
        -: 2582:
        2: 2583:            default:
        2: 2584:                into[0] = json[0];
        2: 2585:                json++;
        2: 2586:                into++;
        -: 2587:        }
        -: 2588:    }
        -: 2589:
        -: 2590:    /* and null-terminate. */
        3: 2591:    *into = '\0';
        -: 2592:}
        -: 2593:
      109: 2594:CJSON_PUBLIC(cJSON_bool) cJSON_IsInvalid(const cJSON * const item)
        -: 2595:{
      109: 2596:    if (item == NULL)
        -: 2597:    {
        1: 2598:        return false;
        -: 2599:    }
        -: 2600:
      108: 2601:    return (item->type & 0xFF) == cJSON_Invalid;
        -: 2602:}
        -: 2603:
        3: 2604:CJSON_PUBLIC(cJSON_bool) cJSON_IsFalse(const cJSON * const item)
        -: 2605:{
        3: 2606:    if (item == NULL)
        -: 2607:    {
        1: 2608:        return false;
        -: 2609:    }
        -: 2610:
        2: 2611:    return (item->type & 0xFF) == cJSON_False;
        -: 2612:}
        -: 2613:
        3: 2614:CJSON_PUBLIC(cJSON_bool) cJSON_IsTrue(const cJSON * const item)
        -: 2615:{
        3: 2616:    if (item == NULL)
        -: 2617:    {
        1: 2618:        return false;
        -: 2619:    }
        -: 2620:
        2: 2621:    return (item->type & 0xff) == cJSON_True;
        -: 2622:}
        -: 2623:
        -: 2624:
        2: 2625:CJSON_PUBLIC(cJSON_bool) cJSON_IsBool(const cJSON * const item)
        -: 2626:{
        2: 2627:    if (item == NULL)
        -: 2628:    {
        1: 2629:        return false;
        -: 2630:    }
        -: 2631:
        1: 2632:    return (item->type & (cJSON_True | cJSON_False)) != 0;
        -: 2633:}
        2: 2634:CJSON_PUBLIC(cJSON_bool) cJSON_IsNull(const cJSON * const item)
        -: 2635:{
        2: 2636:    if (item == NULL)
        -: 2637:    {
        1: 2638:        return false;
        -: 2639:    }
        -: 2640:
        1: 2641:    return (item->type & 0xFF) == cJSON_NULL;
        -: 2642:}
        -: 2643:
        3: 2644:CJSON_PUBLIC(cJSON_bool) cJSON_IsNumber(const cJSON * const item)
        -: 2645:{
        3: 2646:    if (item == NULL)
        -: 2647:    {
        1: 2648:        return false;
        -: 2649:    }
        -: 2650:
        2: 2651:    return (item->type & 0xFF) == cJSON_Number;
        -: 2652:}
        -: 2653:
        3: 2654:CJSON_PUBLIC(cJSON_bool) cJSON_IsString(const cJSON * const item)
        -: 2655:{
        3: 2656:    if (item == NULL)
        -: 2657:    {
        1: 2658:        return false;
        -: 2659:    }
        -: 2660:
        2: 2661:    return (item->type & 0xFF) == cJSON_String;
        -: 2662:}
        -: 2663:
        3: 2664:CJSON_PUBLIC(cJSON_bool) cJSON_IsArray(const cJSON * const item)
        -: 2665:{
        3: 2666:    if (item == NULL)
        -: 2667:    {
        1: 2668:        return false;
        -: 2669:    }
        -: 2670:
        2: 2671:    return (item->type & 0xFF) == cJSON_Array;
        -: 2672:}
        -: 2673:
        3: 2674:CJSON_PUBLIC(cJSON_bool) cJSON_IsObject(const cJSON * const item)
        -: 2675:{
        3: 2676:    if (item == NULL)
        -: 2677:    {
        1: 2678:        return false;
        -: 2679:    }
        -: 2680:
        2: 2681:    return (item->type & 0xFF) == cJSON_Object;
        -: 2682:}
        -: 2683:
        3: 2684:CJSON_PUBLIC(cJSON_bool) cJSON_IsRaw(const cJSON * const item)
        -: 2685:{
        3: 2686:    if (item == NULL)
        -: 2687:    {
        1: 2688:        return false;
        -: 2689:    }
        -: 2690:
        2: 2691:    return (item->type & 0xFF) == cJSON_Raw;
        -: 2692:}
        -: 2693:
      113: 2694:CJSON_PUBLIC(cJSON_bool) cJSON_Compare(const cJSON * const a, const cJSON * const b, const cJSON_bool case_sensitive)
        -: 2695:{
      113: 2696:    if ((a == NULL) || (b == NULL) || ((a->type & 0xFF) != (b->type & 0xFF)) || cJSON_IsInvalid(a))
        -: 2697:    {
        8: 2698:        return false;
        -: 2699:    }
        -: 2700:
        -: 2701:    /* check if type is valid */
      105: 2702:    switch (a->type & 0xFF)
        -: 2703:    {
      103: 2704:        case cJSON_False:
        -: 2705:        case cJSON_True:
        -: 2706:        case cJSON_NULL:
        -: 2707:        case cJSON_Number:
        -: 2708:        case cJSON_String:
        -: 2709:        case cJSON_Raw:
        -: 2710:        case cJSON_Array:
        -: 2711:        case cJSON_Object:
      103: 2712:            break;
        -: 2713:
        2: 2714:        default:
        2: 2715:            return false;
        -: 2716:    }
        -: 2717:
        -: 2718:    /* identical objects are equal */
      103: 2719:    if (a == b)
        -: 2720:    {
    #####: 2721:        return true;
        -: 2722:    }
        -: 2723:
      103: 2724:    switch (a->type & 0xFF)
        -: 2725:    {
        -: 2726:        /* in these cases and equal type is enough */
       28: 2727:        case cJSON_False:
        -: 2728:        case cJSON_True:
        -: 2729:        case cJSON_NULL:
       28: 2730:            return true;
        -: 2731:
       28: 2732:        case cJSON_Number:
       28: 2733:            if (compare_double(a->valuedouble, b->valuedouble))
        -: 2734:            {
       26: 2735:                return true;
        -: 2736:            }
        2: 2737:            return false;
        -: 2738:
       12: 2739:        case cJSON_String:
        -: 2740:        case cJSON_Raw:
       12: 2741:            if ((a->valuestring == NULL) || (b->valuestring == NULL))
        -: 2742:            {
    #####: 2743:                return false;
        -: 2744:            }
       12: 2745:            if (strcmp(a->valuestring, b->valuestring) == 0)
        -: 2746:            {
       10: 2747:                return true;
        -: 2748:            }
        -: 2749:
        2: 2750:            return false;
        -: 2751:
       20: 2752:        case cJSON_Array:
        -: 2753:        {
       20: 2754:            cJSON *a_element = a->child;
       20: 2755:            cJSON *b_element = b->child;
        -: 2756:
       72: 2757:            for (; (a_element != NULL) && (b_element != NULL);)
        -: 2758:            {
       28: 2759:                if (!cJSON_Compare(a_element, b_element, case_sensitive))
        -: 2760:                {
        2: 2761:                    return false;
        -: 2762:                }
        -: 2763:
       26: 2764:                a_element = a_element->next;
       26: 2765:                b_element = b_element->next;
        -: 2766:            }
        -: 2767:
        -: 2768:            /* one of the arrays is longer than the other */
       18: 2769:            if (a_element != b_element) {
        2: 2770:                return false;
        -: 2771:            }
        -: 2772:
       16: 2773:            return true;
        -: 2774:        }
        -: 2775:
       15: 2776:        case cJSON_Object:
        -: 2777:        {
       15: 2778:            cJSON *a_element = NULL;
       15: 2779:            cJSON *b_element = NULL;
       33: 2780:            cJSON_ArrayForEach(a_element, a)
        -: 2781:            {
        -: 2782:                /* TODO This has O(n^2) runtime, which is horrible! */
       20: 2783:                b_element = get_object_item(b, a_element->string, case_sensitive);
       20: 2784:                if (b_element == NULL)
        -: 2785:                {
        2: 2786:                    return false;
        -: 2787:                }
        -: 2788:
       18: 2789:                if (!cJSON_Compare(a_element, b_element, case_sensitive))
        -: 2790:                {
    #####: 2791:                    return false;
        -: 2792:                }
        -: 2793:            }
        -: 2794:
        -: 2795:            /* doing this twice, once on a and b to prevent true comparison if a subset of b
        -: 2796:             * TODO: Do this the proper way, this is just a fix for now */
       31: 2797:            cJSON_ArrayForEach(b_element, b)
        -: 2798:            {
       20: 2799:                a_element = get_object_item(a, b_element->string, case_sensitive);
       20: 2800:                if (a_element == NULL)
        -: 2801:                {
        2: 2802:                    return false;
        -: 2803:                }
        -: 2804:
       18: 2805:                if (!cJSON_Compare(b_element, a_element, case_sensitive))
        -: 2806:                {
    #####: 2807:                    return false;
        -: 2808:                }
        -: 2809:            }
        -: 2810:
       11: 2811:            return true;
        -: 2812:        }
        -: 2813:
    #####: 2814:        default:
    #####: 2815:            return false;
        -: 2816:    }
        -: 2817:}
        -: 2818:
    #####: 2819:CJSON_PUBLIC(void *) cJSON_malloc(size_t size)
        -: 2820:{
    #####: 2821:    return global_hooks.allocate(size);
        -: 2822:}
        -: 2823:
        1: 2824:CJSON_PUBLIC(void) cJSON_free(void *object)
        -: 2825:{
        1: 2826:    global_hooks.deallocate(object);
        1: 2827:}
