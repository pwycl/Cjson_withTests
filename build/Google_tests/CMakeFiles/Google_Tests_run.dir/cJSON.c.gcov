        -:    0:Source:/mnt/d/CLionProjects/Cjson_withTests/Cjson_lib/cJSON.c
        -:    0:Graph:ConverterTests.cpp.gcno
        -:    0:Data:ConverterTests.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2:  Copyright (c) 2009-2017 Dave Gamble and cJSON contributors
        -:    3:
        -:    4:  Permission is hereby granted, free of charge, to any person obtaining a copy
        -:    5:  of this software and associated documentation files (the "Software"), to deal
        -:    6:  in the Software without restriction, including without limitation the rights
        -:    7:  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        -:    8:  copies of the Software, and to permit persons to whom the Software is
        -:    9:  furnished to do so, subject to the following conditions:
        -:   10:
        -:   11:  The above copyright notice and this permission notice shall be included in
        -:   12:  all copies or substantial portions of the Software.
        -:   13:
        -:   14:  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        -:   15:  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        -:   16:  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        -:   17:  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        -:   18:  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        -:   19:  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
        -:   20:  THE SOFTWARE.
        -:   21:*/
        -:   22:
        -:   23:/* cJSON */
        -:   24:/* JSON parser in C. */
        -:   25:
        -:   26:/* disable warnings about old C89 functions in MSVC */
        -:   27:#if !defined(_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER)
        -:   28:#define _CRT_SECURE_NO_DEPRECATE
        -:   29:#endif
        -:   30:
        -:   31:#ifdef __GNUC__
        -:   32:#pragma GCC visibility push(default)
        -:   33:#endif
        -:   34:#if defined(_MSC_VER)
        -:   35:#pragma warning (push)
        -:   36:/* disable warning about single line comments in system headers */
        -:   37:#pragma warning (disable : 4001)
        -:   38:#endif
        -:   39:
        -:   40:#include <string.h>
        -:   41:#include <stdio.h>
        -:   42:#include <math.h>
        -:   43:#include <stdlib.h>
        -:   44:#include <limits.h>
        -:   45:#include <ctype.h>
        -:   46:
        -:   47:#ifdef ENABLE_LOCALES
        -:   48:#include <locale.h>
        -:   49:#endif
        -:   50:
        -:   51:#if defined(_MSC_VER)
        -:   52:#pragma warning (pop)
        -:   53:#endif
        -:   54:#ifdef __GNUC__
        -:   55:#pragma GCC visibility pop
        -:   56:#endif
        -:   57:
        -:   58:#include "cJSON.h"
        -:   59:
        -:   60:/* define our own boolean type */
        -:   61:#ifdef true
        -:   62:#undef true
        -:   63:#endif
        -:   64:#define true ((cJSON_bool)1)
        -:   65:
        -:   66:#ifdef false
        -:   67:#undef false
        -:   68:#endif
        -:   69:#define false ((cJSON_bool)0)
        -:   70:
        -:   71:typedef struct {
        -:   72:    const unsigned char *json;
        -:   73:    size_t position;
        -:   74:} error;
        -:   75:static error global_error = { NULL, 0 };
        -:   76:
        1:   77:CJSON_PUBLIC(const char *) cJSON_GetErrorPtr(void)
        -:   78:{
        1:   79:    return (const char*) (global_error.json + global_error.position);
        -:   80:}
        -:   81:
        -:   82:/* This is a safeguard to prevent copy-pasters from using incompatible C and header files */
        -:   83:#if (CJSON_VERSION_MAJOR != 1) || (CJSON_VERSION_MINOR != 7) || (CJSON_VERSION_PATCH != 12)
        -:   84:    #error cJSON.h and cJSON.c have different versions. Make sure that both have the same.
        -:   85:#endif
        -:   86:
        1:   87:CJSON_PUBLIC(const char*) cJSON_Version(void)
        -:   88:{
        -:   89:    static char version[15];
        1:   90:    sprintf(version, "%i.%i.%i", CJSON_VERSION_MAJOR, CJSON_VERSION_MINOR, CJSON_VERSION_PATCH);
        -:   91:
        1:   92:    return version;
        -:   93:}
        -:   94:
        -:   95:/* Case insensitive string comparison, doesn't consider two NULL pointers equal though */
       74:   96:static int case_insensitive_strcmp(const unsigned char *string1, const unsigned char *string2)
        -:   97:{
       74:   98:    if ((string1 == NULL) || (string2 == NULL))
        -:   99:    {
        2:  100:        return 1;
        -:  101:    }
        -:  102:
       72:  103:    if (string1 == string2)
        -:  104:    {
        1:  105:        return 0;
        -:  106:    }
        -:  107:
      251:  108:    for(; tolower(*string1) == tolower(*string2); (void)string1++, string2++)
        -:  109:    {
      108:  110:        if (*string1 == '\0')
        -:  111:        {
       18:  112:            return 0;
        -:  113:        }
        -:  114:    }
        -:  115:
       53:  116:    return tolower(*string1) - tolower(*string2);
        -:  117:}
        -:  118:
        -:  119:typedef struct internal_hooks
        -:  120:{
        -:  121:    void *(CJSON_CDECL *allocate)(size_t size);
        -:  122:    void (CJSON_CDECL *deallocate)(void *pointer);
        -:  123:    void *(CJSON_CDECL *reallocate)(void *pointer, size_t size);
        -:  124:} internal_hooks;
        -:  125:
        -:  126:#if defined(_MSC_VER)
        -:  127:/* work around MSVC error C2322: '...' address of dllimport '...' is not static */
        -:  128:static void * CJSON_CDECL internal_malloc(size_t size)
        -:  129:{
        -:  130:    return malloc(size);
        -:  131:}
        -:  132:static void CJSON_CDECL internal_free(void *pointer)
        -:  133:{
        -:  134:    free(pointer);
        -:  135:}
        -:  136:static void * CJSON_CDECL internal_realloc(void *pointer, size_t size)
        -:  137:{
        -:  138:    return realloc(pointer, size);
        -:  139:}
        -:  140:#else
        -:  141:#define internal_malloc malloc
        -:  142:#define internal_free free
        -:  143:#define internal_realloc realloc
        -:  144:#endif
        -:  145:
        -:  146:/* strlen of character literals resolved at compile time */
        -:  147:#define static_strlen(string_literal) (sizeof(string_literal) - sizeof(""))
        -:  148:
        -:  149:static internal_hooks global_hooks = { internal_malloc, internal_free, internal_realloc };
        -:  150:
      338:  151:static unsigned char* cJSON_strdup(const unsigned char* string, const internal_hooks * const hooks)
        -:  152:{
      338:  153:    size_t length = 0;
      338:  154:    unsigned char *copy = NULL;
        -:  155:
      338:  156:    if (string == NULL)
        -:  157:    {
        1:  158:        return NULL;
        -:  159:    }
        -:  160:
      337:  161:    length = strlen((const char*)string) + sizeof("");
      337:  162:    copy = (unsigned char*)hooks->allocate(length);
        -:  163:
      337:  164:    memcpy(copy, string, length);
        -:  165:
      337:  166:    return copy;
        -:  167:}
        -:  168:
        6:  169:CJSON_PUBLIC(void) cJSON_InitHooks(cJSON_Hooks* hooks)
        -:  170:{
        6:  171:    if (hooks == NULL)
        -:  172:    {
        -:  173:        /* Reset hooks */
        1:  174:        global_hooks.allocate = malloc;
        1:  175:        global_hooks.deallocate = free;
        1:  176:        global_hooks.reallocate = realloc;
        1:  177:        return;
        -:  178:    }
        -:  179:
        5:  180:    global_hooks.allocate = malloc;
        5:  181:    if (hooks->malloc_fn != NULL)
        -:  182:    {
        1:  183:        global_hooks.allocate = hooks->malloc_fn;
        -:  184:    }
        -:  185:
        5:  186:    global_hooks.deallocate = free;
        5:  187:    if (hooks->free_fn != NULL)
        -:  188:    {
        2:  189:        global_hooks.deallocate = hooks->free_fn;
        -:  190:    }
        -:  191:
        -:  192:    /* use realloc only if both free and malloc are used */
        5:  193:    global_hooks.reallocate = NULL;
        5:  194:    if ((global_hooks.allocate == malloc) && (global_hooks.deallocate == free))
        -:  195:    {
        3:  196:        global_hooks.reallocate = realloc;
        -:  197:    }
        -:  198:}
        -:  199:
        -:  200:/* Internal constructor. */
     2239:  201:static cJSON *cJSON_New_Item(const internal_hooks * const hooks)
        -:  202:{
     2239:  203:    cJSON* node = (cJSON*)hooks->allocate(sizeof(cJSON));
     2239:  204:    memset(node, '\0', sizeof(cJSON));
        -:  205:
     2239:  206:    return node;
        -:  207:}
        -:  208:
        -:  209:/* Delete a cJSON structure. */
     1019:  210:CJSON_PUBLIC(void) cJSON_Delete(cJSON *item)
        -:  211:{
     1019:  212:    cJSON *next = NULL;
     5143:  213:    while (item != NULL)
        -:  214:    {
     2062:  215:        next = item->next;
     2062:  216:        if (!(item->type & cJSON_IsReference) && (item->child != NULL))
        -:  217:        {
      763:  218:            cJSON_Delete(item->child);
        -:  219:        }
     2062:  220:        if (!(item->type & cJSON_IsReference) && (item->valuestring != NULL))
        -:  221:        {
      661:  222:            global_hooks.deallocate(item->valuestring);
        -:  223:        }
     2062:  224:        if (!(item->type & cJSON_StringIsConst) && (item->string != NULL))
        -:  225:        {
     1267:  226:            global_hooks.deallocate(item->string);
        -:  227:        }
     2062:  228:        global_hooks.deallocate(item);
     2062:  229:        item = next;
        -:  230:    }
     1019:  231:}
        -:  232:
        -:  233:/* get the decimal point character of the current locale */
      403:  234:static unsigned char get_decimal_point(void)
        -:  235:{
        -:  236:#ifdef ENABLE_LOCALES
        -:  237:    struct lconv *lconv = localeconv();
        -:  238:    return (unsigned char) lconv->decimal_point[0];
        -:  239:#else
      403:  240:    return '.';
        -:  241:#endif
        -:  242:}
        -:  243:
        -:  244:typedef struct
        -:  245:{
        -:  246:    const unsigned char *content;
        -:  247:    size_t length;
        -:  248:    size_t offset;
        -:  249:    size_t depth; /* How deeply nested (in arrays/objects) is the input at the current offset. */
        -:  250:    internal_hooks hooks;
        -:  251:} parse_buffer;
        -:  252:
        -:  253:/* check if the given size is left to read in a given parse buffer (starting with 1) */
        -:  254:#define can_read(buffer, size) ((buffer != NULL) && (((buffer)->offset + size) <= (buffer)->length))
        -:  255:/* check if the buffer can be accessed at the given index (starting with 0) */
        -:  256:#define can_access_at_index(buffer, index) ((buffer != NULL) && (((buffer)->offset + index) < (buffer)->length))
        -:  257:#define cannot_access_at_index(buffer, index) (!can_access_at_index(buffer, index))
        -:  258:/* get a pointer to the buffer at the position */
        -:  259:#define buffer_at_offset(buffer) ((buffer)->content + (buffer)->offset)
        -:  260:
        -:  261:/* Parse the input text to generate a number, and populate the result into item. */
      342:  262:static cJSON_bool parse_number(cJSON * const item, parse_buffer * const input_buffer)
        -:  263:{
      342:  264:    double number = 0;
      342:  265:    unsigned char *after_end = NULL;
        -:  266:    unsigned char number_c_string[64];
      342:  267:    unsigned char decimal_point = get_decimal_point();
      342:  268:    size_t i = 0;
        -:  269:
      342:  270:    if ((input_buffer == NULL) || (input_buffer->content == NULL))
        -:  271:    {
       36:  272:        return false;
        -:  273:    }
        -:  274:
        -:  275:    /* copy the number into a temporary buffer and replace '.' with the decimal point
        -:  276:     * of the current locale (for strtod)
        -:  277:     * This also takes care of '\0' not necessarily being available for marking the end of the input */
     1496:  278:    for (i = 0; (i < (sizeof(number_c_string) - 1)) && can_access_at_index(input_buffer, i); i++)
        -:  279:    {
      748:  280:        switch (buffer_at_offset(input_buffer)[i])
        -:  281:        {
      433:  282:            case '0':
        -:  283:            case '1':
        -:  284:            case '2':
        -:  285:            case '3':
        -:  286:            case '4':
        -:  287:            case '5':
        -:  288:            case '6':
        -:  289:            case '7':
        -:  290:            case '8':
        -:  291:            case '9':
        -:  292:            case '+':
        -:  293:            case '-':
        -:  294:            case 'e':
        -:  295:            case 'E':
      433:  296:                number_c_string[i] = buffer_at_offset(input_buffer)[i];
      433:  297:                break;
        -:  298:
        9:  299:            case '.':
        9:  300:                number_c_string[i] = decimal_point;
        9:  301:                break;
        -:  302:
      306:  303:            default:
      306:  304:                goto loop_end;
        -:  305:        }
        -:  306:    }
    #####:  307:loop_end:
      306:  308:    number_c_string[i] = '\0';
        -:  309:
      306:  310:    number = strtod((const char*)number_c_string, (char**)&after_end);
        -:  311:
      306:  312:    item->valuedouble = number;
        -:  313:
        -:  314:    /* use saturation in case of overflow */
      306:  315:    if (number >= INT_MAX)
        -:  316:    {
        2:  317:        item->valueint = INT_MAX;
        -:  318:    }
      304:  319:    else if (number <= (double)INT_MIN)
        -:  320:    {
        3:  321:        item->valueint = INT_MIN;
        -:  322:    }
        -:  323:    else
        -:  324:    {
      301:  325:        item->valueint = (int)number;
        -:  326:    }
        -:  327:
      306:  328:    item->type = cJSON_Number;
        -:  329:
      306:  330:    input_buffer->offset += (size_t)(after_end - number_c_string);
      306:  331:    return true;
        -:  332:}
        -:  333:
        -:  334:/* don't ask me, but the original cJSON_SetNumberValue returns an integer or double */
       21:  335:CJSON_PUBLIC(double) cJSON_SetNumberHelper(cJSON *object, double number)
        -:  336:{
       21:  337:    if (number >= INT_MAX)
        -:  338:    {
        4:  339:        object->valueint = INT_MAX;
        -:  340:    }
       17:  341:    else if (number <= (double)INT_MIN)
        -:  342:    {
        4:  343:        object->valueint = INT_MIN;
        -:  344:    }
        -:  345:    else
        -:  346:    {
       13:  347:        object->valueint = (int)number;
        -:  348:    }
        -:  349:
       21:  350:    return object->valuedouble = number;
        -:  351:}
        -:  352:
        -:  353:typedef struct
        -:  354:{
        -:  355:    unsigned char *buffer;
        -:  356:    size_t length;
        -:  357:    size_t offset;
        -:  358:    size_t depth; /* current nesting depth (for formatted printing) */
        -:  359:    cJSON_bool noalloc;
        -:  360:    cJSON_bool format; /* is this print a formatted print */
        -:  361:    internal_hooks hooks;
        -:  362:} printbuffer;
        -:  363:
        -:  364:/* realloc printbuffer if necessary to have at least "needed" bytes more */
      489:  365:static unsigned char* ensure(printbuffer * const p, size_t needed)
        -:  366:{
      489:  367:    unsigned char *newbuffer = NULL;
      489:  368:    size_t newsize = 0;
        -:  369:
      489:  370:    if ((p == NULL) || (p->buffer == NULL))
        -:  371:    {
        3:  372:        return NULL;
        -:  373:    }
        -:  374:
      486:  375:    if(p->offset >= p->length)
        -:  376:    {
        -:  377:        /* make sure that offset is valid */
        1:  378:        return NULL;
        -:  379:    }
        -:  380:
        -:  381:
      485:  382:    if (needed > INT_MAX)
        -:  383:    {
        -:  384:        /* sizes bigger than INT_MAX are currently not supported */
        1:  385:        return NULL;
        -:  386:    }
        -:  387:
      484:  388:    needed += p->offset + 1;
      484:  389:    if (needed <= p->length)
        -:  390:    {
      480:  391:        return p->buffer + p->offset;
        -:  392:    }
        -:  393:
        4:  394:    if (p->noalloc) {
        1:  395:        return NULL;
        -:  396:    }
        -:  397:
        -:  398:    /* calculate new buffer size */
        3:  399:    if (needed > (INT_MAX / 2))
        -:  400:    {
        -:  401:        /* overflow of int, use INT_MAX if possible */
        1:  402:        newsize = INT_MAX;
        -:  403:    }
        -:  404:    else
        -:  405:    {
        2:  406:        newsize = needed * 2;
        -:  407:    }
        -:  408:
        3:  409:    if (p->hooks.reallocate != NULL)
        -:  410:    {
        -:  411:        /* reallocate with realloc if available */
        2:  412:        newbuffer = (unsigned char*)p->hooks.reallocate(p->buffer, newsize);
        -:  413:    }
        -:  414:    else
        -:  415:    {
        -:  416:        /* otherwise reallocate manually */
        1:  417:        newbuffer = (unsigned char*)p->hooks.allocate(newsize);
        1:  418:        memcpy(newbuffer, p->buffer, p->offset + 1);
        1:  419:        p->hooks.deallocate(p->buffer);
        -:  420:    }
        3:  421:    p->length = newsize;
        3:  422:    p->buffer = newbuffer;
        -:  423:
        3:  424:    return newbuffer + p->offset;
        -:  425:}
        -:  426:
        -:  427:/* calculate the new length of the string in a printbuffer and update the offset */
      193:  428:static void update_offset(printbuffer * const buffer)
        -:  429:{
      193:  430:    const unsigned char *buffer_pointer = NULL;
      193:  431:    if ((buffer == NULL) || (buffer->buffer == NULL))
        -:  432:    {
        2:  433:        return;
        -:  434:    }
      191:  435:    buffer_pointer = buffer->buffer + buffer->offset;
        -:  436:
      191:  437:    buffer->offset += strlen((const char*)buffer_pointer);
        -:  438:}
        -:  439:
        -:  440:/* securely comparison of floating-point variables */
      180:  441:static cJSON_bool compare_double(double a, double b)
        -:  442:{
      180:  443:    return (fabs(a - b) <= CJSON_DOUBLE_PRECISION);
        -:  444:}
        -:  445:
        -:  446:/* Render the number nicely from the given item into a string. */
       61:  447:static cJSON_bool print_number(const cJSON * const item, printbuffer * const output_buffer)
        -:  448:{
       61:  449:    unsigned char *output_pointer = NULL;
       61:  450:    double d = item->valuedouble;
       61:  451:    int length = 0;
       61:  452:    size_t i = 0;
       61:  453:    unsigned char number_buffer[26] = {0}; /* temporary buffer to print the number into */
       61:  454:    unsigned char decimal_point = get_decimal_point();
       61:  455:    double test = 0.0;
        -:  456:
       61:  457:    if (output_buffer == NULL)
        -:  458:    {
       18:  459:        return false;
        -:  460:    }
        -:  461:
        -:  462:    /* This checks for NaN and Infinity */
        -:  463:
        -:  464:    /* Try 15 decimal places of precision to avoid nonsignificant nonzero digits */
       43:  465:    length = sprintf((char*)number_buffer, "%1.15g", d);
        -:  466:
        -:  467:    /* Check whether the original double can be recovered */
       43:  468:    if(!compare_double((double)test, d)){
       40:  469:        length = sprintf((char*)number_buffer, "%1.17g", d);
        -:  470:    }
        -:  471:
        -:  472:    /* sprintf failed or buffer overrun occurred */
        -:  473:
        -:  474:    /* reserve appropriate space in the output */
       43:  475:    output_pointer = ensure(output_buffer, (size_t)length + sizeof(""));
        -:  476:
        -:  477:    /* copy the printed number to the output and replace locale
        -:  478:     * dependent decimal point with '.' */
      238:  479:    for (i = 0; i < ((size_t)length); i++)
        -:  480:    {
      205:  481:        if (number_buffer[i] == decimal_point)
        -:  482:        {
       10:  483:            output_pointer[i] = '.';
       10:  484:            continue;
        -:  485:        }
        -:  486:
      185:  487:        output_pointer[i] = number_buffer[i];
        -:  488:    }
       43:  489:    output_pointer[i] = '\0';
        -:  490:
       43:  491:    output_buffer->offset += (size_t)length;
        -:  492:
       43:  493:    return true;
        -:  494:}
        -:  495:
        -:  496:/* parse 4 digit hexadecimal number */
   131078:  497:static unsigned parse_hex4(const unsigned char * const input)
        -:  498:{
   131078:  499:    unsigned int h = 0;
   131078:  500:    size_t i = 0;
        -:  501:
   655386:  502:    for (i = 0; i < 4; i++)
        -:  503:    {
        -:  504:        /* parse digit */
   524309:  505:        if ((input[i] >= '0') && (input[i] <= '9'))
        -:  506:        {
   327689:  507:            h += (unsigned int) input[i] - '0';
        -:  508:        }
   196620:  509:        else if ((input[i] >= 'A') && (input[i] <= 'F'))
        -:  510:        {
    98308:  511:            h += (unsigned int) 10 + input[i] - 'A';
        -:  512:        }
    98312:  513:        else if ((input[i] >= 'a') && (input[i] <= 'f'))
        -:  514:        {
    98311:  515:            h += (unsigned int) 10 + input[i] - 'a';
        -:  516:        }
        -:  517:        else /* invalid */
        -:  518:        {
        1:  519:            return 0;
        -:  520:        }
        -:  521:
   524308:  522:        if (i < 3)
        -:  523:        {
        -:  524:            /* shift left to make place for the next nibble */
   393231:  525:            h = h << 4;
        -:  526:        }
        -:  527:    }
        -:  528:
   131077:  529:    return h;
        -:  530:}
        -:  531:
        -:  532:/* converts a UTF-16 literal to UTF-8
        -:  533: * A literal can be one or two sequences of the form \uXXXX */
        3:  534:static unsigned char utf16_literal_to_utf8(const unsigned char * const input_pointer, const unsigned char * const input_end, unsigned char **output_pointer)
        -:  535:{
        3:  536:    long unsigned int codepoint = 0;
        3:  537:    unsigned int first_code = 0;
        3:  538:    const unsigned char *first_sequence = input_pointer;
        3:  539:    unsigned char utf8_length = 0;
        3:  540:    unsigned char utf8_position = 0;
        3:  541:    unsigned char sequence_length = 0;
        3:  542:    unsigned char first_byte_mark = 0;
        -:  543:
        -:  544:    /* get the first utf16 sequence */
        3:  545:    first_code = parse_hex4(first_sequence + 2);
        -:  546:
        -:  547:    /* UTF16 surrogate pair */
        3:  548:    if ((first_code >= 0xD800) && (first_code <= 0xDBFF))
        -:  549:    {
        1:  550:        const unsigned char *second_sequence = first_sequence + 6;
        1:  551:        unsigned int second_code = 0;
        1:  552:        sequence_length = 12; /* \uXXXX\uXXXX */
        -:  553:
        -:  554:        /* get the second utf16 sequence */
        1:  555:        second_code = parse_hex4(second_sequence + 2);
        -:  556:        /* check that the code is valid */
        -:  557:
        -:  558:        /* calculate the unicode codepoint from the surrogate pair */
        1:  559:        codepoint = 0x10000 + (((first_code & 0x3FF) << 10) | (second_code & 0x3FF));
        -:  560:    }
        -:  561:    else
        -:  562:    {
        2:  563:        sequence_length = 6; /* \uXXXX */
        2:  564:        codepoint = first_code;
        -:  565:    }
        -:  566:
        -:  567:    /* encode as UTF-8
        -:  568:     * takes at maximum 4 bytes to encode:
        -:  569:     * 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx */
        3:  570:    if (codepoint < 0x10000)
        -:  571:    {
        -:  572:        /* three bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx */
        2:  573:        utf8_length = 3;
        2:  574:        first_byte_mark = 0xE0; /* 11100000 */
        -:  575:    }
        1:  576:    else if (codepoint <= 0x10FFFF)
        -:  577:    {
        -:  578:        /* four bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx 10xxxxxx */
        1:  579:        utf8_length = 4;
        1:  580:        first_byte_mark = 0xF0; /* 11110000 */
        -:  581:    }
        -:  582:    else
        -:  583:    {
        -:  584:        /* invalid unicode codepoint */
    #####:  585:        goto fail;
        -:  586:    }
        -:  587:
        -:  588:    /* encode as utf8 */
       10:  589:    for (utf8_position = (unsigned char)(utf8_length - 1); utf8_position > 0; utf8_position--)
        -:  590:    {
        -:  591:        /* 10xxxxxx */
        7:  592:        (*output_pointer)[utf8_position] = (unsigned char)((codepoint | 0x80) & 0xBF);
        7:  593:        codepoint >>= 6;
        -:  594:    }
        -:  595:    /* encode first byte */
        3:  596:    (*output_pointer)[0] = (unsigned char)((codepoint | first_byte_mark) & 0xFF);
        -:  597:
        3:  598:    *output_pointer += utf8_length;
        -:  599:
        3:  600:    return sequence_length;
        -:  601:
    #####:  602:fail:
    #####:  603:    return 0;
        -:  604:}
        -:  605:
        -:  606:/* Parse the input text into an unescaped cinput, and populate item. */
     1707:  607:static cJSON_bool parse_string(cJSON * const item, parse_buffer * const input_buffer)
        -:  608:{
     1707:  609:    const unsigned char *input_pointer = buffer_at_offset(input_buffer) + 1;
     1707:  610:    const unsigned char *input_end = buffer_at_offset(input_buffer) + 1;
     1707:  611:    unsigned char *output_pointer = NULL;
     1707:  612:    unsigned char *output = NULL;
        -:  613:
        -:  614:    /* not a string */
     1707:  615:    if (buffer_at_offset(input_buffer)[0] != '\"')
        -:  616:    {
        5:  617:        goto fail;
        -:  618:    }
        -:  619:
        -:  620:    {
        -:  621:        /* calculate approximate size of the output (overestimate) */
     1702:  622:        size_t allocation_length = 0;
     1702:  623:        size_t skipped_bytes = 0;
    22766:  624:        while (((size_t)(input_end - input_buffer->content) < input_buffer->length) && (*input_end != '\"'))
        -:  625:        {
        -:  626:            /* is escape sequence */
    10532:  627:            if (input_end[0] == '\\')
        -:  628:            {
       26:  629:                skipped_bytes++;
       26:  630:                input_end++;
        -:  631:            }
    10532:  632:            input_end++;
        -:  633:        }
     1702:  634:        if (((size_t)(input_end - input_buffer->content) >= input_buffer->length))
        -:  635:        {
        1:  636:            goto fail; /* string ended unexpectedly */
        -:  637:        }
     1701:  638:        if((*input_end != '\"')){
    #####:  639:            goto fail; /* string ended unexpectedly */
        -:  640:        }
        -:  641:
        -:  642:        /* This is at most how much we need for the output */
     1701:  643:        allocation_length = (size_t) (input_end - buffer_at_offset(input_buffer)) - skipped_bytes;
     1701:  644:        output = (unsigned char*)input_buffer->hooks.allocate(allocation_length + sizeof(""));
        -:  645:    }
        -:  646:
     1701:  647:    output_pointer = output;
        -:  648:    /* loop through the string literal */
    22693:  649:    while (input_pointer < input_end)
        -:  650:    {
    10496:  651:        if (*input_pointer != '\\')
        -:  652:        {
    10472:  653:            *output_pointer++ = *input_pointer++;
        -:  654:        }
        -:  655:        /* escape sequence */
        -:  656:        else
        -:  657:        {
       24:  658:            unsigned char sequence_length = 2;
        -:  659:
       24:  660:            switch (input_pointer[1])
        -:  661:            {
        1:  662:                case 'b':
        1:  663:                    *output_pointer++ = '\b';
        1:  664:                    break;
        1:  665:                case 'f':
        1:  666:                    *output_pointer++ = '\f';
        1:  667:                    break;
        1:  668:                case 'n':
        1:  669:                    *output_pointer++ = '\n';
        1:  670:                    break;
        1:  671:                case 'r':
        1:  672:                    *output_pointer++ = '\r';
        1:  673:                    break;
        1:  674:                case 't':
        1:  675:                    *output_pointer++ = '\t';
        1:  676:                    break;
       16:  677:                case '\"':
        -:  678:                case '\\':
        -:  679:                case '/':
       16:  680:                    *output_pointer++ = input_pointer[1];
       16:  681:                    break;
        -:  682:
        -:  683:                /* UTF-16 literal */
        3:  684:                case 'u':
        3:  685:                    sequence_length = utf16_literal_to_utf8(input_pointer, input_end, &output_pointer);
        3:  686:                    break;
        -:  687:
    #####:  688:                default:
    #####:  689:                    goto fail;
        -:  690:            }
       24:  691:            input_pointer += sequence_length;
        -:  692:        }
        -:  693:    }
        -:  694:
        -:  695:    /* zero terminate the output */
     1701:  696:    *output_pointer = '\0';
        -:  697:
     1701:  698:    item->type = cJSON_String;
     1701:  699:    item->valuestring = (char*)output;
        -:  700:
     1701:  701:    input_buffer->offset = (size_t) (input_end - input_buffer->content);
     1701:  702:    input_buffer->offset++;
        -:  703:
     1701:  704:    return true;
        -:  705:
        6:  706:fail:
        6:  707:    if (input_pointer != NULL)
        -:  708:    {
        6:  709:        input_buffer->offset = (size_t)(input_pointer - input_buffer->content);
        -:  710:    }
        -:  711:
        6:  712:    return false;
        -:  713:}
        -:  714:
        -:  715:/* Render the cstring provided to an escaped version that can be printed. */
      101:  716:static cJSON_bool print_string_ptr(const unsigned char * const input, printbuffer * const output_buffer)
        -:  717:{
      101:  718:    const unsigned char *input_pointer = NULL;
      101:  719:    unsigned char *output = NULL;
      101:  720:    unsigned char *output_pointer = NULL;
      101:  721:    size_t output_length = 0;
        -:  722:    /* numbers of additional characters needed for escaping */
      101:  723:    size_t escape_characters = 0;
        -:  724:
        -:  725:    /* empty string */
      101:  726:    if (input == NULL)
        -:  727:    {
        1:  728:        output = ensure(output_buffer, sizeof("\"\""));
        1:  729:        strcpy((char*)output, "\"\"");
        -:  730:
        1:  731:        return true;
        -:  732:    }
        -:  733:
        -:  734:    /* set "flag" to 1 if something needs to be escaped */
      501:  735:    for (input_pointer = input; *input_pointer; input_pointer++)
        -:  736:    {
      401:  737:        switch (*input_pointer)
        -:  738:        {
        7:  739:            case '\"':
        -:  740:            case '\\':
        -:  741:            case '\b':
        -:  742:            case '\f':
        -:  743:            case '\n':
        -:  744:            case '\r':
        -:  745:            case '\t':
        -:  746:                /* one character escape sequence */
        7:  747:                escape_characters++;
        7:  748:                break;
      394:  749:            default:
      394:  750:                if (*input_pointer < 32)
        -:  751:                {
        -:  752:                    /* UTF-16 escape sequence uXXXX */
       26:  753:                    escape_characters += 5;
        -:  754:                }
      394:  755:                break;
        -:  756:        }
        -:  757:    }
      100:  758:    output_length = (size_t)(input_pointer - input) + escape_characters;
        -:  759:
      100:  760:    output = ensure(output_buffer, output_length + sizeof("\"\""));
        -:  761:
        -:  762:    /* no characters have to be escaped */
      100:  763:    if (escape_characters == 0)
        -:  764:    {
       99:  765:        output[0] = '\"';
       99:  766:        memcpy(output + 1, input, output_length);
       99:  767:        output[output_length + 1] = '\"';
       99:  768:        output[output_length + 2] = '\0';
        -:  769:
       99:  770:        return true;
        -:  771:    }
        -:  772:
        1:  773:    output[0] = '\"';
        1:  774:    output_pointer = output + 1;
        -:  775:    /* copy the string */
      127:  776:    for (input_pointer = input; *input_pointer != '\0'; (void)input_pointer++, output_pointer++)
        -:  777:    {
      126:  778:        if ((*input_pointer > 31) && (*input_pointer != '\"') && (*input_pointer != '\\'))
        -:  779:        {
        -:  780:            /* normal character, copy */
       93:  781:            *output_pointer = *input_pointer;
        -:  782:        }
        -:  783:        else
        -:  784:        {
        -:  785:            /* character needs to be escaped */
       33:  786:            *output_pointer++ = '\\';
       33:  787:            switch (*input_pointer)
        -:  788:            {
        1:  789:                case '\\':
        1:  790:                    *output_pointer = '\\';
        1:  791:                    break;
        1:  792:                case '\"':
        1:  793:                    *output_pointer = '\"';
        1:  794:                    break;
        1:  795:                case '\b':
        1:  796:                    *output_pointer = 'b';
        1:  797:                    break;
        1:  798:                case '\f':
        1:  799:                    *output_pointer = 'f';
        1:  800:                    break;
        1:  801:                case '\n':
        1:  802:                    *output_pointer = 'n';
        1:  803:                    break;
        1:  804:                case '\r':
        1:  805:                    *output_pointer = 'r';
        1:  806:                    break;
        1:  807:                case '\t':
        1:  808:                    *output_pointer = 't';
        1:  809:                    break;
       26:  810:                default:
        -:  811:                    /* escape and print as unicode codepoint */
       26:  812:                    sprintf((char*)output_pointer, "u%04x", *input_pointer);
       26:  813:                    output_pointer += 4;
       26:  814:                    break;
        -:  815:            }
        -:  816:        }
        -:  817:    }
        1:  818:    output[output_length + 1] = '\"';
        1:  819:    output[output_length + 2] = '\0';
        -:  820:
        1:  821:    return true;
        -:  822:}
        -:  823:
        -:  824:/* Invoke print_string_ptr (which is useful) on an item. */
       38:  825:static cJSON_bool print_string(const cJSON * const item, printbuffer * const p)
        -:  826:{
       38:  827:    return print_string_ptr((unsigned char*)item->valuestring, p);
        -:  828:}
        -:  829:
        -:  830:/* Predeclare these prototypes. */
        -:  831:static cJSON_bool parse_value(cJSON * const item, parse_buffer * const input_buffer);
        -:  832:static cJSON_bool print_value(const cJSON * const item, printbuffer * const output_buffer);
        -:  833:static cJSON_bool parse_array(cJSON * const item, parse_buffer * const input_buffer);
        -:  834:static cJSON_bool print_array(const cJSON * const item, printbuffer * const output_buffer);
        -:  835:static cJSON_bool parse_object(cJSON * const item, parse_buffer * const input_buffer);
        -:  836:static cJSON_bool print_object(const cJSON * const item, printbuffer * const output_buffer);
        -:  837:
        -:  838:/* Utility to jump whitespace and cr/lf */
     6376:  839:static parse_buffer *buffer_skip_whitespace(parse_buffer * const buffer)
        -:  840:{
     6376:  841:    if ((buffer == NULL) || (buffer->content == NULL))
        -:  842:    {
        2:  843:        return NULL;
        -:  844:    }
        -:  845:
    17240:  846:    while (can_access_at_index(buffer, 0) && (buffer_at_offset(buffer)[0] <= 32))
        -:  847:    {
     5433:  848:       buffer->offset++;
        -:  849:    }
        -:  850:
     6374:  851:    if (buffer->offset == buffer->length)
        -:  852:    {
       11:  853:        buffer->offset--;
        -:  854:    }
        -:  855:
     6374:  856:    return buffer;
        -:  857:}
        -:  858:
        -:  859:/* skip the UTF-8 BOM (byte order mark) if it is at the beginning of a buffer */
      131:  860:static parse_buffer *skip_utf8_bom(parse_buffer * const buffer)
        -:  861:{
      131:  862:    if ((buffer == NULL) || (buffer->content == NULL) || (buffer->offset != 0))
        -:  863:    {
        3:  864:        return NULL;
        -:  865:    }
        -:  866:
      128:  867:    if (can_access_at_index(buffer, 4) && (strncmp((const char*)buffer_at_offset(buffer), "\xEF\xBB\xBF", 3) == 0))
        -:  868:    {
        1:  869:        buffer->offset += 3;
        -:  870:    }
        -:  871:
      128:  872:    return buffer;
        -:  873:}
        -:  874:
        -:  875:/* Parse an object - create a new root, and populate. */
      130:  876:CJSON_PUBLIC(cJSON *) cJSON_ParseWithOpts(const char *value, const char **return_parse_end, cJSON_bool require_null_terminated)
        -:  877:{
      130:  878:    parse_buffer buffer = { 0, 0, 0, 0, { 0, 0, 0 } };
      130:  879:    cJSON *item = NULL;
        -:  880:
        -:  881:    /* reset error position */
      130:  882:    global_error.json = NULL;
      130:  883:    global_error.position = 0;
        -:  884:
      130:  885:    if (value == NULL)
        -:  886:    {
        2:  887:        goto fail;
        -:  888:    }
        -:  889:
      128:  890:    buffer.content = (const unsigned char*)value;
      128:  891:    buffer.length = strlen((const char*)value) + sizeof("");
      128:  892:    buffer.offset = 0;
      128:  893:    buffer.hooks = global_hooks;
        -:  894:
      128:  895:    item = cJSON_New_Item(&(buffer.hooks));
        -:  896:
      128:  897:    if (!parse_value(item, buffer_skip_whitespace(skip_utf8_bom(&buffer))))
        -:  898:    {
        -:  899:        /* parse failure. ep is set. */
        4:  900:        goto fail;
        -:  901:    }
        -:  902:
        -:  903:    /* if we require null-terminated JSON without appended garbage, skip and then check for a null terminator */
      124:  904:    if (require_null_terminated)
        -:  905:    {
        5:  906:        buffer_skip_whitespace(&buffer);
        5:  907:        if(buffer_at_offset(&buffer)[0] != '\0'){
        1:  908:            goto fail;
        -:  909:        }
        -:  910:    }
      123:  911:    if (return_parse_end)
        -:  912:    {
        1:  913:        *return_parse_end = (const char*)buffer_at_offset(&buffer);
        -:  914:    }
        -:  915:
      123:  916:    return item;
        -:  917:
        7:  918:fail:
        7:  919:    if (item != NULL)
        -:  920:    {
        5:  921:        cJSON_Delete(item);
        -:  922:    }
        -:  923:
        7:  924:    if (value != NULL)
        -:  925:    {
        -:  926:        error local_error;
        5:  927:        local_error.json = (const unsigned char*)value;
        5:  928:        local_error.position = 0;
        -:  929:
        5:  930:        if (buffer.offset < buffer.length)
        -:  931:        {
        4:  932:            local_error.position = buffer.offset;
        -:  933:        }
        -:  934:        else
        -:  935:        {
        1:  936:            local_error.position = buffer.length - 1;
        -:  937:        }
        -:  938:
        5:  939:        if (return_parse_end != NULL)
        -:  940:        {
        2:  941:            *return_parse_end = (const char*)local_error.json + local_error.position;
        -:  942:        }
        -:  943:
        5:  944:        global_error = local_error;
        -:  945:    }
        -:  946:
        7:  947:    return NULL;
        -:  948:}
        -:  949:
        -:  950:/* Default options for cJSON_Parse */
      117:  951:CJSON_PUBLIC(cJSON *) cJSON_Parse(const char *value)
        -:  952:{
      117:  953:    return cJSON_ParseWithOpts(value, 0, 0);
        -:  954:}
        -:  955:
        -:  956:#define cjson_min(a, b) ((a < b) ? a : b)
        -:  957:
       34:  958:static unsigned char *print(const cJSON * const item, cJSON_bool format, const internal_hooks * const hooks)
        -:  959:{
        -:  960:    static const size_t default_buffer_size = 256;
        -:  961:    printbuffer buffer[1];
       34:  962:    unsigned char *printed = NULL;
        -:  963:
       34:  964:    memset(buffer, 0, sizeof(buffer));
        -:  965:
        -:  966:    /* create buffer */
       34:  967:    buffer->buffer = (unsigned char*) hooks->allocate(default_buffer_size);
       34:  968:    buffer->length = default_buffer_size;
       34:  969:    buffer->format = format;
       34:  970:    buffer->hooks = *hooks;
        -:  971:
        -:  972:    /* print the value */
       34:  973:    if (!print_value(item, buffer))
        -:  974:    {
        1:  975:        goto fail;
        -:  976:    }
       33:  977:    update_offset(buffer);
        -:  978:
        -:  979:    /* check if reallocate is available */
       33:  980:    if (hooks->reallocate != NULL)
        -:  981:    {
       32:  982:        printed = (unsigned char*) hooks->reallocate(buffer->buffer, buffer->offset + 1);
       32:  983:        buffer->buffer = NULL;
        -:  984:    }
        -:  985:    else /* otherwise copy the JSON over to a new buffer */
        -:  986:    {
        1:  987:        printed = (unsigned char*) hooks->allocate(buffer->offset + 1);
        1:  988:        memcpy(printed, buffer->buffer, cjson_min(buffer->length, buffer->offset + 1));
        1:  989:        printed[buffer->offset] = '\0'; /* just to be sure */
        -:  990:
        -:  991:        /* free the buffer */
        1:  992:        hooks->deallocate(buffer->buffer);
        -:  993:    }
        -:  994:
       33:  995:    return printed;
        -:  996:
        1:  997:fail:
        1:  998:    hooks->deallocate(buffer->buffer);
        1:  999:    return NULL;
        -: 1000:}
        -: 1001:
        -: 1002:/* Render a cJSON item/entity/structure to text. */
        4: 1003:CJSON_PUBLIC(char *) cJSON_Print(const cJSON *item)
        -: 1004:{
        4: 1005:    return (char*)print(item, true, &global_hooks);
        -: 1006:}
        -: 1007:
       30: 1008:CJSON_PUBLIC(char *) cJSON_PrintUnformatted(const cJSON *item)
        -: 1009:{
       30: 1010:    return (char*)print(item, false, &global_hooks);
        -: 1011:}
        -: 1012:
        2: 1013:CJSON_PUBLIC(char *) cJSON_PrintBuffered(const cJSON *item, int prebuffer, cJSON_bool fmt)
        -: 1014:{
        2: 1015:    printbuffer p = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };
        -: 1016:
        2: 1017:    if (prebuffer < 0)
        -: 1018:    {
    #####: 1019:        return NULL;
        -: 1020:    }
        -: 1021:
        2: 1022:    p.buffer = (unsigned char*)global_hooks.allocate((size_t)prebuffer);
        2: 1023:    if (!p.buffer)
        -: 1024:    {
    #####: 1025:        return NULL;
        -: 1026:    }
        -: 1027:
        2: 1028:    p.length = (size_t)prebuffer;
        2: 1029:    p.offset = 0;
        2: 1030:    p.noalloc = false;
        2: 1031:    p.format = fmt;
        2: 1032:    p.hooks = global_hooks;
        -: 1033:
        2: 1034:    if (!print_value(item, &p))
        -: 1035:    {
        1: 1036:        global_hooks.deallocate(p.buffer);
        1: 1037:        return NULL;
        -: 1038:    }
        -: 1039:
        1: 1040:    return (char*)p.buffer;
        -: 1041:}
        -: 1042:
        4: 1043:CJSON_PUBLIC(cJSON_bool) cJSON_PrintPreallocated(cJSON *item, char *buffer, const int length, const cJSON_bool format)
        -: 1044:{
        4: 1045:    printbuffer p = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };
        -: 1046:
        4: 1047:    if ((length < 0) || (buffer == NULL))
        -: 1048:    {
        2: 1049:        return false;
        -: 1050:    }
        -: 1051:
        2: 1052:    p.buffer = (unsigned char*)buffer;
        2: 1053:    p.length = (size_t)length;
        2: 1054:    p.offset = 0;
        2: 1055:    p.noalloc = true;
        2: 1056:    p.format = format;
        2: 1057:    p.hooks = global_hooks;
        -: 1058:
        2: 1059:    return print_value(item, &p);
        -: 1060:}
        -: 1061:
        -: 1062:/* Parser core - when encountering text, process appropriately. */
     1806: 1063:static cJSON_bool parse_value(cJSON * const item, parse_buffer * const input_buffer)
        -: 1064:{
     1806: 1065:    if ((input_buffer == NULL) || (input_buffer->content == NULL))
        -: 1066:    {
       16: 1067:        return false; /* no input */
        -: 1068:    }
        -: 1069:
        -: 1070:    /* parse the different types of values */
        -: 1071:    /* null */
     1790: 1072:    if (can_read(input_buffer, 4) && (strncmp((const char*)buffer_at_offset(input_buffer), "null", 4) == 0))
        -: 1073:    {
       57: 1074:        item->type = cJSON_NULL;
       57: 1075:        input_buffer->offset += 4;
       57: 1076:        return true;
        -: 1077:    }
        -: 1078:    /* false */
     1733: 1079:    if (can_read(input_buffer, 5) && (strncmp((const char*)buffer_at_offset(input_buffer), "false", 5) == 0))
        -: 1080:    {
       35: 1081:        item->type = cJSON_False;
       35: 1082:        input_buffer->offset += 5;
       35: 1083:        return true;
        -: 1084:    }
        -: 1085:    /* true */
     1698: 1086:    if (can_read(input_buffer, 4) && (strncmp((const char*)buffer_at_offset(input_buffer), "true", 4) == 0))
        -: 1087:    {
       40: 1088:        item->type = cJSON_True;
       40: 1089:        item->valueint = 1;
       40: 1090:        input_buffer->offset += 4;
       40: 1091:        return true;
        -: 1092:    }
        -: 1093:    /* string */
     1658: 1094:    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '\"'))
        -: 1095:    {
      613: 1096:        return parse_string(item, input_buffer);
        -: 1097:    }
        -: 1098:    /* number */
     1045: 1099:    if (can_access_at_index(input_buffer, 0) && ((buffer_at_offset(input_buffer)[0] == '-') || ((buffer_at_offset(input_buffer)[0] >= '0') && (buffer_at_offset(input_buffer)[0] <= '9'))))
        -: 1100:    {
      288: 1101:        return parse_number(item, input_buffer);
        -: 1102:    }
        -: 1103:    /* array */
      757: 1104:    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '['))
        -: 1105:    {
      287: 1106:        return parse_array(item, input_buffer);
        -: 1107:    }
        -: 1108:    /* object */
      470: 1109:    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '{'))
        -: 1110:    {
      466: 1111:        return parse_object(item, input_buffer);
        -: 1112:    }
        -: 1113:
        4: 1114:    return false;
        -: 1115:}
        -: 1116:
        -: 1117:/* Render a value to text. */
      168: 1118:static cJSON_bool print_value(const cJSON * const item, printbuffer * const output_buffer)
        -: 1119:{
      168: 1120:    unsigned char *output = NULL;
        -: 1121:
      168: 1122:    if ((item == NULL) || (output_buffer == NULL))
        -: 1123:    {
       20: 1124:        return false;
        -: 1125:    }
        -: 1126:
      148: 1127:    switch ((item->type) & 0xFF)
        -: 1128:    {
       16: 1129:        case cJSON_NULL:
       16: 1130:            output = ensure(output_buffer, 5);
        -: 1131:
       16: 1132:            strcpy((char*)output, "null");
       16: 1133:            return true;
        -: 1134:
        5: 1135:        case cJSON_False:
        5: 1136:            output = ensure(output_buffer, 6);
        -: 1137:
        5: 1138:            strcpy((char*)output, "false");
        5: 1139:            return true;
        -: 1140:
        5: 1141:        case cJSON_True:
        5: 1142:            output = ensure(output_buffer, 5);
        -: 1143:
        5: 1144:            strcpy((char*)output, "true");
        5: 1145:            return true;
        -: 1146:
       25: 1147:        case cJSON_Number:
       25: 1148:            return print_number(item, output_buffer);
        -: 1149:
       38: 1150:        case cJSON_String:
       38: 1151:            return print_string(item, output_buffer);
        -: 1152:
       17: 1153:        case cJSON_Array:
       17: 1154:            return print_array(item, output_buffer);
        -: 1155:
       34: 1156:        case cJSON_Object:
       34: 1157:            return print_object(item, output_buffer);
        -: 1158:
        8: 1159:        default:
        8: 1160:            return false;
        -: 1161:    }
        -: 1162:}
        -: 1163:
        -: 1164:/* Build an array from input text. */
      317: 1165:static cJSON_bool parse_array(cJSON * const item, parse_buffer * const input_buffer)
        -: 1166:{
      317: 1167:    cJSON *head = NULL; /* head of the linked list */
      317: 1168:    cJSON *current_item = NULL;
        -: 1169:
      317: 1170:    if (input_buffer->depth >= CJSON_NESTING_LIMIT)
        -: 1171:    {
        8: 1172:        return false; /* to deeply nested */
        -: 1173:    }
      309: 1174:    input_buffer->depth++;
        -: 1175:
      309: 1176:    if (buffer_at_offset(input_buffer)[0] != '[')
        -: 1177:    {
        -: 1178:        /* not an array */
        6: 1179:        goto fail;
        -: 1180:    }
        -: 1181:
      303: 1182:    input_buffer->offset++;
      303: 1183:    buffer_skip_whitespace(input_buffer);
        -: 1184:
      303: 1185:    if (can_access_at_index(input_buffer, 0) )
        -: 1186:    {
      303: 1187:        if((buffer_at_offset(input_buffer)[0] == ']')){
        -: 1188:            /* empty array */
       45: 1189:            goto success;
        -: 1190:        }
        -: 1191:
        -: 1192:    }
        -: 1193:
        -: 1194:    /* check if we skipped to the end of the buffer */
      258: 1195:    if (cannot_access_at_index(input_buffer, 0))
        -: 1196:    {
    #####: 1197:        input_buffer->offset--;
    #####: 1198:        goto fail;
        -: 1199:    }
        -: 1200:
        -: 1201:    /* step back to character in front of the first element */
      258: 1202:    input_buffer->offset--;
        -: 1203:    /* loop through the comma separated array elements */
      305: 1204:    do
        -: 1205:    {
        -: 1206:        /* allocate next item */
      563: 1207:        cJSON *new_item = cJSON_New_Item(&(input_buffer->hooks));
        -: 1208:
        -: 1209:        /* attach next item to list */
      563: 1210:        if (head == NULL)
        -: 1211:        {
        -: 1212:            /* start the linked list */
      258: 1213:            current_item = head = new_item;
        -: 1214:        }
        -: 1215:        else
        -: 1216:        {
        -: 1217:            /* add to the end and advance */
      305: 1218:            current_item->next = new_item;
      305: 1219:            new_item->prev = current_item;
      305: 1220:            current_item = new_item;
        -: 1221:        }
        -: 1222:
        -: 1223:        /* parse next value */
      563: 1224:        input_buffer->offset++;
      563: 1225:        buffer_skip_whitespace(input_buffer);
      563: 1226:        if (!parse_value(current_item, input_buffer))
        -: 1227:        {
        1: 1228:            goto fail; /* failed to parse value */
        -: 1229:        }
      562: 1230:        buffer_skip_whitespace(input_buffer);
        -: 1231:    }
      562: 1232:    while (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ','));
        -: 1233:
      257: 1234:    if (cannot_access_at_index(input_buffer, 0) )
        -: 1235:    {
        -: 1236:        goto fail; /* expected end of array */
        -: 1237:    }
        -: 1238:
      257: 1239:    if( buffer_at_offset(input_buffer)[0] != ']'){
    #####: 1240:        goto fail;
        -: 1241:    }
        -: 1242:
      257: 1243:success:
      302: 1244:    input_buffer->depth--;
        -: 1245:
      302: 1246:    item->type = cJSON_Array;
      302: 1247:    item->child = head;
        -: 1248:
      302: 1249:    input_buffer->offset++;
        -: 1250:
      302: 1251:    return true;
        -: 1252:
    #####: 1253:fail:
        7: 1254:    if (head != NULL)
        -: 1255:    {
        1: 1256:        cJSON_Delete(head);
        -: 1257:    }
        -: 1258:
        7: 1259:    return false;
        -: 1260:}
        -: 1261:
        -: 1262:/* Render an array to text */
       38: 1263:static cJSON_bool print_array(const cJSON * const item, printbuffer * const output_buffer)
        -: 1264:{
       38: 1265:    unsigned char *output_pointer = NULL;
       38: 1266:    size_t length = 0;
       38: 1267:    cJSON *current_element = item->child;
        -: 1268:
       38: 1269:    if (output_buffer == NULL)
        -: 1270:    {
        7: 1271:        return false;
        -: 1272:    }
        -: 1273:
        -: 1274:    /* Compose the output array. */
        -: 1275:    /* opening square bracket */
       31: 1276:    output_pointer = ensure(output_buffer, 1);
       31: 1277:    if (output_pointer == NULL)
        -: 1278:    {
    #####: 1279:        return false;
        -: 1280:    }
        -: 1281:
       31: 1282:    *output_pointer = '[';
       31: 1283:    output_buffer->offset++;
       31: 1284:    output_buffer->depth++;
        -: 1285:
      109: 1286:    while (current_element != NULL)
        -: 1287:    {
       39: 1288:        if (!print_value(current_element, output_buffer))
        -: 1289:        {
    #####: 1290:            return false;
        -: 1291:        }
       39: 1292:        update_offset(output_buffer);
       39: 1293:        if (current_element->next)
        -: 1294:        {
       19: 1295:            length = (size_t) (output_buffer->format ? 2 : 1);
       19: 1296:            output_pointer = ensure(output_buffer, length + 1);
       19: 1297:            if (output_pointer == NULL)
        -: 1298:            {
    #####: 1299:                return false;
        -: 1300:            }
       19: 1301:            *output_pointer++ = ',';
       19: 1302:            if(output_buffer->format)
        -: 1303:            {
        8: 1304:                *output_pointer++ = ' ';
        -: 1305:            }
       19: 1306:            *output_pointer = '\0';
       19: 1307:            output_buffer->offset += length;
        -: 1308:        }
       39: 1309:        current_element = current_element->next;
        -: 1310:    }
        -: 1311:
       31: 1312:    output_pointer = ensure(output_buffer, 2);
       31: 1313:    if (output_pointer == NULL)
        -: 1314:    {
    #####: 1315:        return false;
        -: 1316:    }
       31: 1317:    *output_pointer++ = ']';
       31: 1318:    *output_pointer = '\0';
       31: 1319:    output_buffer->depth--;
        -: 1320:
       31: 1321:    return true;
        -: 1322:}
        -: 1323:
        -: 1324:/* Build an object from the text. */
      481: 1325:static cJSON_bool parse_object(cJSON * const item, parse_buffer * const input_buffer)
        -: 1326:{
      481: 1327:    cJSON *head = NULL; /* linked list head */
      481: 1328:    cJSON *current_item = NULL;
        -: 1329:
      481: 1330:    if (input_buffer->depth >= CJSON_NESTING_LIMIT)
        -: 1331:    {
    #####: 1332:        return false; /* to deeply nested */
        -: 1333:    }
      481: 1334:    input_buffer->depth++;
        -: 1335:
      962: 1336:    if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != '{'))
        -: 1337:    {
        -: 1338:        goto fail; /* not an object */
        -: 1339:    }
        -: 1340:
      481: 1341:    input_buffer->offset++;
      481: 1342:    buffer_skip_whitespace(input_buffer);
      481: 1343:    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '}'))
        -: 1344:    {
       51: 1345:        goto success; /* empty object */
        -: 1346:    }
        -: 1347:
        -: 1348:    /* check if we skipped to the end of the buffer */
      430: 1349:    if (cannot_access_at_index(input_buffer, 0))
        -: 1350:    {
    #####: 1351:        input_buffer->offset--;
    #####: 1352:        goto fail;
        -: 1353:    }
        -: 1354:
        -: 1355:    /* step back to character in front of the first element */
      430: 1356:    input_buffer->offset--;
        -: 1357:    /* loop through the comma separated array elements */
      654: 1358:    do
        -: 1359:    {
        -: 1360:        /* allocate next item */
     1084: 1361:        cJSON *new_item = cJSON_New_Item(&(input_buffer->hooks));
     1084: 1362:        if (new_item == NULL)
        -: 1363:        {
    #####: 1364:            goto fail; /* allocation failure */
        -: 1365:        }
        -: 1366:
        -: 1367:        /* attach next item to list */
     1084: 1368:        if (head == NULL)
        -: 1369:        {
        -: 1370:            /* start the linked list */
      430: 1371:            current_item = head = new_item;
        -: 1372:        }
        -: 1373:        else
        -: 1374:        {
        -: 1375:            /* add to the end and advance */
      654: 1376:            current_item->next = new_item;
      654: 1377:            new_item->prev = current_item;
      654: 1378:            current_item = new_item;
        -: 1379:        }
        -: 1380:
        -: 1381:        /* parse the name of the child */
     1084: 1382:        input_buffer->offset++;
     1084: 1383:        buffer_skip_whitespace(input_buffer);
     1084: 1384:        if (!parse_string(current_item, input_buffer))
        -: 1385:        {
        1: 1386:            goto fail; /* failed to parse name */
        -: 1387:        }
     1083: 1388:        buffer_skip_whitespace(input_buffer);
        -: 1389:
        -: 1390:        /* swap valuestring and string, because we parsed the name */
     1083: 1391:        current_item->string = current_item->valuestring;
     1083: 1392:        current_item->valuestring = NULL;
        -: 1393:
     3249: 1394:        if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != ':'))
        -: 1395:        {
        -: 1396:            goto fail; /* invalid object */
        -: 1397:        }
        -: 1398:
        -: 1399:        /* parse the value */
     1083: 1400:        input_buffer->offset++;
     1083: 1401:        buffer_skip_whitespace(input_buffer);
     1083: 1402:        if (!parse_value(current_item, input_buffer))
        -: 1403:        {
        1: 1404:            goto fail; /* failed to parse value */
        -: 1405:        }
     1082: 1406:        buffer_skip_whitespace(input_buffer);
        -: 1407:    }
     1082: 1408:    while (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ','));
        -: 1409:
     1284: 1410:    if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != '}'))
        -: 1411:    {
        -: 1412:        goto fail; /* expected end of object */
        -: 1413:    }
        -: 1414:
      428: 1415:success:
      479: 1416:    input_buffer->depth--;
        -: 1417:
      479: 1418:    item->type = cJSON_Object;
      479: 1419:    item->child = head;
        -: 1420:
      479: 1421:    input_buffer->offset++;
      479: 1422:    return true;
        -: 1423:
    #####: 1424:fail:
        2: 1425:    if (head != NULL)
        -: 1426:    {
        2: 1427:        cJSON_Delete(head);
        -: 1428:    }
        -: 1429:
        2: 1430:    return false;
        -: 1431:}
        -: 1432:
        -: 1433:/* Render an object to text. */
       48: 1434:static cJSON_bool print_object(const cJSON * const item, printbuffer * const output_buffer)
        -: 1435:{
       48: 1436:    unsigned char *output_pointer = NULL;
       48: 1437:    size_t length = 0;
       48: 1438:    cJSON *current_item = item->child;
        -: 1439:
       48: 1440:    if (output_buffer == NULL)
        -: 1441:    {
    #####: 1442:        return false;
        -: 1443:    }
        -: 1444:
        -: 1445:    /* Compose the output: */
       48: 1446:    length = (size_t) (output_buffer->format ? 2 : 1); /* fmt: {\n */
       48: 1447:    output_pointer = ensure(output_buffer, length + 1);
       48: 1448:    if (output_pointer == NULL)
        -: 1449:    {
    #####: 1450:        return false;
        -: 1451:    }
        -: 1452:
       48: 1453:    *output_pointer++ = '{';
       48: 1454:    output_buffer->depth++;
       48: 1455:    if (output_buffer->format)
        -: 1456:    {
        9: 1457:        *output_pointer++ = '\n';
        -: 1458:    }
       48: 1459:    output_buffer->offset += length;
        -: 1460:
      166: 1461:    while (current_item)
        -: 1462:    {
       59: 1463:        if (output_buffer->format)
        -: 1464:        {
        -: 1465:            size_t i;
       14: 1466:            output_pointer = ensure(output_buffer, output_buffer->depth);
       14: 1467:            if (output_pointer == NULL)
        -: 1468:            {
    #####: 1469:                return false;
        -: 1470:            }
       28: 1471:            for (i = 0; i < output_buffer->depth; i++)
        -: 1472:            {
       14: 1473:                *output_pointer++ = '\t';
        -: 1474:            }
       14: 1475:            output_buffer->offset += output_buffer->depth;
        -: 1476:        }
        -: 1477:
        -: 1478:        /* print key */
       59: 1479:        if (!print_string_ptr((unsigned char*)current_item->string, output_buffer))
        -: 1480:        {
    #####: 1481:            return false;
        -: 1482:        }
       59: 1483:        update_offset(output_buffer);
        -: 1484:
       59: 1485:        length = (size_t) (output_buffer->format ? 2 : 1);
       59: 1486:        output_pointer = ensure(output_buffer, length);
       59: 1487:        if (output_pointer == NULL)
        -: 1488:        {
    #####: 1489:            return false;
        -: 1490:        }
       59: 1491:        *output_pointer++ = ':';
       59: 1492:        if (output_buffer->format)
        -: 1493:        {
       14: 1494:            *output_pointer++ = '\t';
        -: 1495:        }
       59: 1496:        output_buffer->offset += length;
        -: 1497:
        -: 1498:        /* print value */
       59: 1499:        if (!print_value(current_item, output_buffer))
        -: 1500:        {
    #####: 1501:            return false;
        -: 1502:        }
       59: 1503:        update_offset(output_buffer);
        -: 1504:
        -: 1505:        /* print comma if not last */
       59: 1506:        length = ((size_t)(output_buffer->format ? 1 : 0) + (size_t)(current_item->next ? 1 : 0));
       59: 1507:        output_pointer = ensure(output_buffer, length + 1);
       59: 1508:        if (output_pointer == NULL)
        -: 1509:        {
    #####: 1510:            return false;
        -: 1511:        }
       59: 1512:        if (current_item->next)
        -: 1513:        {
       19: 1514:            *output_pointer++ = ',';
        -: 1515:        }
        -: 1516:
       59: 1517:        if (output_buffer->format)
        -: 1518:        {
       14: 1519:            *output_pointer++ = '\n';
        -: 1520:        }
       59: 1521:        *output_pointer = '\0';
       59: 1522:        output_buffer->offset += length;
        -: 1523:
       59: 1524:        current_item = current_item->next;
        -: 1525:    }
        -: 1526:
       48: 1527:    output_pointer = ensure(output_buffer, output_buffer->format ? (output_buffer->depth + 1) : 2);
       48: 1528:    if (output_pointer == NULL)
        -: 1529:    {
    #####: 1530:        return false;
        -: 1531:    }
       48: 1532:    if (output_buffer->format)
        -: 1533:    {
        -: 1534:        size_t i;
       11: 1535:        for (i = 0; i < (output_buffer->depth - 1); i++)
        -: 1536:        {
        2: 1537:            *output_pointer++ = '\t';
        -: 1538:        }
        -: 1539:    }
       48: 1540:    *output_pointer++ = '}';
       48: 1541:    *output_pointer = '\0';
       48: 1542:    output_buffer->depth--;
        -: 1543:
       48: 1544:    return true;
        -: 1545:}
        -: 1546:
        -: 1547:/* Get Array size/item / object item. */
        8: 1548:CJSON_PUBLIC(int) cJSON_GetArraySize(const cJSON *array)
        -: 1549:{
        8: 1550:    cJSON *child = NULL;
        8: 1551:    size_t size = 0;
        -: 1552:
        8: 1553:    if (array == NULL)
        -: 1554:    {
        1: 1555:        return 0;
        -: 1556:    }
        -: 1557:
        7: 1558:    child = array->child;
        -: 1559:
       35: 1560:    while(child != NULL)
        -: 1561:    {
       14: 1562:        size++;
       14: 1563:        child = child->next;
        -: 1564:    }
        -: 1565:
        -: 1566:    /* FIXME: Can overflow here. Cannot be fixed without breaking the API */
        -: 1567:
        7: 1568:    return (int)size;
        -: 1569:}
        -: 1570:
       11: 1571:static cJSON* get_array_item(const cJSON *array, size_t index)
        -: 1572:{
       11: 1573:    cJSON *current_child = NULL;
        -: 1574:
       11: 1575:    if (array == NULL)
        -: 1576:    {
        4: 1577:        return NULL;
        -: 1578:    }
        -: 1579:
        7: 1580:    current_child = array->child;
       19: 1581:    while ((current_child != NULL) && (index > 0))
        -: 1582:    {
        6: 1583:        index--;
        6: 1584:        current_child = current_child->next;
        -: 1585:    }
        -: 1586:
        7: 1587:    return current_child;
        -: 1588:}
        -: 1589:
        1: 1590:CJSON_PUBLIC(cJSON *) cJSON_GetArrayItem(const cJSON *array, int index)
        -: 1591:{
        1: 1592:    if (index < 0)
        -: 1593:    {
    #####: 1594:        return NULL;
        -: 1595:    }
        -: 1596:
        1: 1597:    return get_array_item(array, (size_t)index);
        -: 1598:}
        -: 1599:
      833: 1600:static cJSON *get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)
        -: 1601:{
      833: 1602:    cJSON *current_element = NULL;
        -: 1603:
      833: 1604:    if ((object == NULL) || (name == NULL))
        -: 1605:    {
       13: 1606:        return NULL;
        -: 1607:    }
        -: 1608:
      820: 1609:    current_element = object->child;
      820: 1610:    if (case_sensitive)
        -: 1611:    {
     3974: 1612:        while ((current_element != NULL) && (current_element->string != NULL) && (strcmp(name, current_element->string) != 0))
        -: 1613:        {
     1587: 1614:            current_element = current_element->next;
        -: 1615:        }
        -: 1616:    }
        -: 1617:    else
        -: 1618:    {
      126: 1619:        while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))
        -: 1620:        {
       53: 1621:            current_element = current_element->next;
        -: 1622:        }
        -: 1623:    }
        -: 1624:
      820: 1625:    if ((current_element == NULL) || (current_element->string == NULL)) {
      257: 1626:        return NULL;
        -: 1627:    }
        -: 1628:
      563: 1629:    return current_element;
        -: 1630:}
        -: 1631:
        6: 1632:CJSON_PUBLIC(cJSON *) cJSON_GetObjectItem(const cJSON * const object, const char * const string)
        -: 1633:{
        6: 1634:    return get_object_item(object, string, false);
        -: 1635:}
        -: 1636:
      625: 1637:CJSON_PUBLIC(cJSON *) cJSON_GetObjectItemCaseSensitive(const cJSON * const object, const char * const string)
        -: 1638:{
      625: 1639:    return get_object_item(object, string, true);
        -: 1640:}
        -: 1641:
        1: 1642:CJSON_PUBLIC(cJSON_bool) cJSON_HasObjectItem(const cJSON *object, const char *string)
        -: 1643:{
        1: 1644:    return cJSON_GetObjectItem(object, string) ? 1 : 0;
        -: 1645:}
        -: 1646:
        -: 1647:/* Utility for array list handling. */
       49: 1648:static void suffix_object(cJSON *prev, cJSON *item)
        -: 1649:{
       49: 1650:    prev->next = item;
       49: 1651:    item->prev = prev;
       49: 1652:}
        -: 1653:
        -: 1654:/* Utility for handling references. */
        3: 1655:static cJSON *create_reference(const cJSON *item, const internal_hooks * const hooks)
        -: 1656:{
        3: 1657:    cJSON *reference = NULL;
        3: 1658:    if (item == NULL)
        -: 1659:    {
        2: 1660:        return NULL;
        -: 1661:    }
        -: 1662:
        1: 1663:    reference = cJSON_New_Item(hooks);
        1: 1664:    if (reference == NULL)
        -: 1665:    {
    #####: 1666:        return NULL;
        -: 1667:    }
        -: 1668:
        1: 1669:    memcpy(reference, item, sizeof(cJSON));
        1: 1670:    reference->string = NULL;
        1: 1671:    reference->type |= cJSON_IsReference;
        1: 1672:    reference->next = reference->prev = NULL;
        1: 1673:    return reference;
        -: 1674:}
        -: 1675:
       30: 1676:static cJSON_bool add_item_to_array(cJSON *array, cJSON *item)
        -: 1677:{
       30: 1678:    cJSON *child = NULL;
        -: 1679:
       30: 1680:    if ((item == NULL) || (array == NULL))
        -: 1681:    {
        3: 1682:        return false;
        -: 1683:    }
        -: 1684:
       27: 1685:    child = array->child;
        -: 1686:
       27: 1687:    if (child == NULL)
        -: 1688:    {
        -: 1689:        /* list is empty, start new one */
       17: 1690:        array->child = item;
        -: 1691:    }
        -: 1692:    else
        -: 1693:    {
        -: 1694:        /* append to the end */
       18: 1695:        while (child->next)
        -: 1696:        {
        4: 1697:            child = child->next;
        -: 1698:        }
       10: 1699:        suffix_object(child, item);
        -: 1700:    }
        -: 1701:
       27: 1702:    return true;
        -: 1703:}
        -: 1704:
        -: 1705:/* Add item to array/object. */
       10: 1706:CJSON_PUBLIC(void) cJSON_AddItemToArray(cJSON *array, cJSON *item)
        -: 1707:{
       10: 1708:    add_item_to_array(array, item);
       10: 1709:}
        -: 1710:
        -: 1711:#if defined(__clang__) || (defined(__GNUC__)  && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 5))))
        -: 1712:    #pragma GCC diagnostic push
        -: 1713:#endif
        -: 1714:#ifdef __GNUC__
        -: 1715:#pragma GCC diagnostic ignored "-Wcast-qual"
        -: 1716:#endif
        -: 1717:/* helper function to cast away const */
        4: 1718:static void* cast_away_const(const void* string)
        -: 1719:{
        4: 1720:    return (void*)string;
        -: 1721:}
        -: 1722:#if defined(__clang__) || (defined(__GNUC__)  && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 5))))
        -: 1723:    #pragma GCC diagnostic pop
        -: 1724:#endif
        -: 1725:
        -: 1726:
       40: 1727:static cJSON_bool add_item_to_object(cJSON * const object, const char * const string, cJSON * const item, const internal_hooks * const hooks, const cJSON_bool constant_key)
        -: 1728:{
       40: 1729:    char *new_key = NULL;
       40: 1730:    int new_type = cJSON_Invalid;
        -: 1731:
       40: 1732:    if ((object == NULL) || (string == NULL) || (item == NULL))
        -: 1733:    {
       25: 1734:        return false;
        -: 1735:    }
        -: 1736:
       15: 1737:    if (constant_key)
        -: 1738:    {
        1: 1739:        new_key = (char*)cast_away_const(string);
        1: 1740:        new_type = item->type | cJSON_StringIsConst;
        -: 1741:    }
        -: 1742:    else
        -: 1743:    {
       14: 1744:        new_key = (char*)cJSON_strdup((const unsigned char*)string, hooks);
       14: 1745:        if (new_key == NULL)
        -: 1746:        {
    #####: 1747:            return false;
        -: 1748:        }
        -: 1749:
       14: 1750:        new_type = item->type & ~cJSON_StringIsConst;
        -: 1751:    }
        -: 1752:
       15: 1753:    if (!(item->type & cJSON_StringIsConst) && (item->string != NULL))
        -: 1754:    {
    #####: 1755:        hooks->deallocate(item->string);
        -: 1756:    }
        -: 1757:
       15: 1758:    item->string = new_key;
       15: 1759:    item->type = new_type;
        -: 1760:
       15: 1761:    return add_item_to_array(object, item);
        -: 1762:}
        -: 1763:
        1: 1764:CJSON_PUBLIC(void) cJSON_AddItemToObject(cJSON *object, const char *string, cJSON *item)
        -: 1765:{
        1: 1766:    add_item_to_object(object, string, item, &global_hooks, false);
        1: 1767:}
        -: 1768:
        -: 1769:/* Add an item to an object with constant string as key */
        1: 1770:CJSON_PUBLIC(void) cJSON_AddItemToObjectCS(cJSON *object, const char *string, cJSON *item)
        -: 1771:{
        1: 1772:    add_item_to_object(object, string, item, &global_hooks, true);
        1: 1773:}
        -: 1774:
        3: 1775:CJSON_PUBLIC(void) cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)
        -: 1776:{
        3: 1777:    if (array == NULL)
        -: 1778:    {
        1: 1779:        return;
        -: 1780:    }
        -: 1781:
        2: 1782:    add_item_to_array(array, create_reference(item, &global_hooks));
        -: 1783:}
        -: 1784:
        3: 1785:CJSON_PUBLIC(void) cJSON_AddItemReferenceToObject(cJSON *object, const char *string, cJSON *item)
        -: 1786:{
        3: 1787:    if ((object == NULL) || (string == NULL))
        -: 1788:    {
        2: 1789:        return;
        -: 1790:    }
        -: 1791:
        1: 1792:    add_item_to_object(object, string, create_reference(item, &global_hooks), &global_hooks, false);
        -: 1793:}
        -: 1794:
        2: 1795:CJSON_PUBLIC(cJSON*) cJSON_AddNullToObject(cJSON * const object, const char * const name)
        -: 1796:{
        2: 1797:    cJSON *null = cJSON_CreateNull();
        2: 1798:    if (add_item_to_object(object, name, null, &global_hooks, false))
        -: 1799:    {
        1: 1800:        return null;
        -: 1801:    }
        -: 1802:
        1: 1803:    cJSON_Delete(null);
        1: 1804:    return NULL;
        -: 1805:}
        -: 1806:
        3: 1807:CJSON_PUBLIC(cJSON*) cJSON_AddTrueToObject(cJSON * const object, const char * const name)
        -: 1808:{
        3: 1809:    cJSON *true_item = cJSON_CreateTrue();
        3: 1810:    if (add_item_to_object(object, name, true_item, &global_hooks, false))
        -: 1811:    {
        1: 1812:        return true_item;
        -: 1813:    }
        -: 1814:
        2: 1815:    cJSON_Delete(true_item);
        2: 1816:    return NULL;
        -: 1817:}
        -: 1818:
        4: 1819:CJSON_PUBLIC(cJSON*) cJSON_AddFalseToObject(cJSON * const object, const char * const name)
        -: 1820:{
        4: 1821:    cJSON *false_item = cJSON_CreateFalse();
        4: 1822:    if (add_item_to_object(object, name, false_item, &global_hooks, false))
        -: 1823:    {
        1: 1824:        return false_item;
        -: 1825:    }
        -: 1826:
        3: 1827:    cJSON_Delete(false_item);
        3: 1828:    return NULL;
        -: 1829:}
        -: 1830:
        5: 1831:CJSON_PUBLIC(cJSON*) cJSON_AddBoolToObject(cJSON * const object, const char * const name, const cJSON_bool boolean)
        -: 1832:{
        5: 1833:    cJSON *bool_item = cJSON_CreateBool(boolean);
        5: 1834:    if (add_item_to_object(object, name, bool_item, &global_hooks, false))
        -: 1835:    {
        3: 1836:        return bool_item;
        -: 1837:    }
        -: 1838:
        2: 1839:    cJSON_Delete(bool_item);
        2: 1840:    return NULL;
        -: 1841:}
        -: 1842:
        6: 1843:CJSON_PUBLIC(cJSON*) cJSON_AddNumberToObject(cJSON * const object, const char * const name, const double number)
        -: 1844:{
        6: 1845:    cJSON *number_item = cJSON_CreateNumber(number);
        6: 1846:    if (add_item_to_object(object, name, number_item, &global_hooks, false))
        -: 1847:    {
    #####: 1848:        return number_item;
        -: 1849:    }
        -: 1850:
        6: 1851:    cJSON_Delete(number_item);
        6: 1852:    return NULL;
        -: 1853:}
        -: 1854:
        4: 1855:CJSON_PUBLIC(cJSON*) cJSON_AddStringToObject(cJSON * const object, const char * const name, const char * const string)
        -: 1856:{
        4: 1857:    cJSON *string_item = cJSON_CreateString(string);
        4: 1858:    if (add_item_to_object(object, name, string_item, &global_hooks, false))
        -: 1859:    {
    #####: 1860:        return string_item;
        -: 1861:    }
        -: 1862:
        4: 1863:    cJSON_Delete(string_item);
        4: 1864:    return NULL;
        -: 1865:}
        -: 1866:
        4: 1867:CJSON_PUBLIC(cJSON*) cJSON_AddRawToObject(cJSON * const object, const char * const name, const char * const raw)
        -: 1868:{
        4: 1869:    cJSON *raw_item = cJSON_CreateRaw(raw);
        4: 1870:    if (add_item_to_object(object, name, raw_item, &global_hooks, false))
        -: 1871:    {
        2: 1872:        return raw_item;
        -: 1873:    }
        -: 1874:
        2: 1875:    cJSON_Delete(raw_item);
        2: 1876:    return NULL;
        -: 1877:}
        -: 1878:
        3: 1879:CJSON_PUBLIC(cJSON*) cJSON_AddObjectToObject(cJSON * const object, const char * const name)
        -: 1880:{
        3: 1881:    cJSON *object_item = cJSON_CreateObject();
        3: 1882:    if (add_item_to_object(object, name, object_item, &global_hooks, false))
        -: 1883:    {
        1: 1884:        return object_item;
        -: 1885:    }
        -: 1886:
        2: 1887:    cJSON_Delete(object_item);
        2: 1888:    return NULL;
        -: 1889:}
        -: 1890:
        6: 1891:CJSON_PUBLIC(cJSON*) cJSON_AddArrayToObject(cJSON * const object, const char * const name)
        -: 1892:{
        6: 1893:    cJSON *array = cJSON_CreateArray();
        6: 1894:    if (add_item_to_object(object, name, array, &global_hooks, false))
        -: 1895:    {
        4: 1896:        return array;
        -: 1897:    }
        -: 1898:
        2: 1899:    cJSON_Delete(array);
        2: 1900:    return NULL;
        -: 1901:}
        -: 1902:
       12: 1903:CJSON_PUBLIC(cJSON *) cJSON_DetachItemViaPointer(cJSON *parent, cJSON * const item)
        -: 1904:{
       12: 1905:    if ((parent == NULL) || (item == NULL))
        -: 1906:    {
       10: 1907:        return NULL;
        -: 1908:    }
        -: 1909:
        2: 1910:    if (item->prev != NULL)
        -: 1911:    {
        -: 1912:        /* not the first element */
        2: 1913:        item->prev->next = item->next;
        -: 1914:    }
        2: 1915:    if (item->next != NULL)
        -: 1916:    {
        -: 1917:        /* not the last element */
        2: 1918:        item->next->prev = item->prev;
        -: 1919:    }
        -: 1920:
        2: 1921:    if (item == parent->child)
        -: 1922:    {
        -: 1923:        /* first element */
        1: 1924:        parent->child = item->next;
        -: 1925:    }
        -: 1926:    /* make sure the detached item doesn't point anywhere anymore */
        2: 1927:    item->prev = NULL;
        2: 1928:    item->next = NULL;
        -: 1929:
        2: 1930:    return item;
        -: 1931:}
        -: 1932:
        3: 1933:CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromArray(cJSON *array, int which)
        -: 1934:{
        3: 1935:    if (which < 0)
        -: 1936:    {
        1: 1937:        return NULL;
        -: 1938:    }
        -: 1939:
        2: 1940:    return cJSON_DetachItemViaPointer(array, get_array_item(array, (size_t)which));
        -: 1941:}
        -: 1942:
        1: 1943:CJSON_PUBLIC(void) cJSON_DeleteItemFromArray(cJSON *array, int which)
        -: 1944:{
        1: 1945:    cJSON_Delete(cJSON_DetachItemFromArray(array, which));
        1: 1946:}
        -: 1947:
        4: 1948:CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObject(cJSON *object, const char *string)
        -: 1949:{
        4: 1950:    cJSON *to_detach = cJSON_GetObjectItem(object, string);
        -: 1951:
        4: 1952:    return cJSON_DetachItemViaPointer(object, to_detach);
        -: 1953:}
        -: 1954:
        4: 1955:CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObjectCaseSensitive(cJSON *object, const char *string)
        -: 1956:{
        4: 1957:    cJSON *to_detach = cJSON_GetObjectItemCaseSensitive(object, string);
        -: 1958:
        4: 1959:    return cJSON_DetachItemViaPointer(object, to_detach);
        -: 1960:}
        -: 1961:
        2: 1962:CJSON_PUBLIC(void) cJSON_DeleteItemFromObject(cJSON *object, const char *string)
        -: 1963:{
        2: 1964:    cJSON_Delete(cJSON_DetachItemFromObject(object, string));
        2: 1965:}
        -: 1966:
        2: 1967:CJSON_PUBLIC(void) cJSON_DeleteItemFromObjectCaseSensitive(cJSON *object, const char *string)
        -: 1968:{
        2: 1969:    cJSON_Delete(cJSON_DetachItemFromObjectCaseSensitive(object, string));
        2: 1970:}
        -: 1971:
        -: 1972:/* Replace array/object items with new ones. */
        6: 1973:CJSON_PUBLIC(void) cJSON_InsertItemInArray(cJSON *array, int which, cJSON *newitem)
        -: 1974:{
        6: 1975:    cJSON *after_inserted = NULL;
        -: 1976:
        6: 1977:    if (which < 0)
        -: 1978:    {
        1: 1979:        return;
        -: 1980:    }
        -: 1981:
        5: 1982:    after_inserted = get_array_item(array, (size_t)which);
        5: 1983:    if (after_inserted == NULL)
        -: 1984:    {
        3: 1985:        add_item_to_array(array, newitem);
        3: 1986:        return;
        -: 1987:    }
        -: 1988:
        2: 1989:    newitem->next = after_inserted;
        2: 1990:    newitem->prev = after_inserted->prev;
        2: 1991:    after_inserted->prev = newitem;
        2: 1992:    if (after_inserted == array->child)
        -: 1993:    {
        2: 1994:        array->child = newitem;
        -: 1995:    }
        -: 1996:    else
        -: 1997:    {
    #####: 1998:        newitem->prev->next = newitem;
        -: 1999:    }
        -: 2000:}
        -: 2001:
       11: 2002:CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemViaPointer(cJSON * const parent, cJSON * const item, cJSON * replacement)
        -: 2003:{
       11: 2004:    if ((parent == NULL) || (replacement == NULL) || (item == NULL))
        -: 2005:    {
        8: 2006:        return false;
        -: 2007:    }
        -: 2008:
        3: 2009:    if (replacement == item)
        -: 2010:    {
        1: 2011:        return true;
        -: 2012:    }
        -: 2013:
        2: 2014:    replacement->next = item->next;
        2: 2015:    replacement->prev = item->prev;
        -: 2016:
        2: 2017:    if (replacement->next != NULL)
        -: 2018:    {
        1: 2019:        replacement->next->prev = replacement;
        -: 2020:    }
        2: 2021:    if (replacement->prev != NULL)
        -: 2022:    {
        2: 2023:        replacement->prev->next = replacement;
        -: 2024:    }
        2: 2025:    if (parent->child == item)
        -: 2026:    {
    #####: 2027:        parent->child = replacement;
        -: 2028:    }
        -: 2029:
        2: 2030:    item->next = NULL;
        2: 2031:    item->prev = NULL;
        2: 2032:    cJSON_Delete(item);
        -: 2033:
        2: 2034:    return true;
        -: 2035:}
        -: 2036:
        4: 2037:CJSON_PUBLIC(void) cJSON_ReplaceItemInArray(cJSON *array, int which, cJSON *newitem)
        -: 2038:{
        4: 2039:    if (which < 0)
        -: 2040:    {
        1: 2041:        return;
        -: 2042:    }
        -: 2043:
        3: 2044:    cJSON_ReplaceItemViaPointer(array, get_array_item(array, (size_t)which), newitem);
        -: 2045:}
        -: 2046:
        7: 2047:static cJSON_bool replace_item_in_object(cJSON *object, const char *string, cJSON *replacement, cJSON_bool case_sensitive)
        -: 2048:{
        7: 2049:    if ((replacement == NULL) || (string == NULL))
        -: 2050:    {
        5: 2051:        return false;
        -: 2052:    }
        -: 2053:
        -: 2054:    /* replace the name in the replacement */
        2: 2055:    if (!(replacement->type & cJSON_StringIsConst) && (replacement->string != NULL))
        -: 2056:    {
        1: 2057:        cJSON_free(replacement->string);
        -: 2058:    }
        2: 2059:    replacement->string = (char*)cJSON_strdup((const unsigned char*)string, &global_hooks);
        2: 2060:    replacement->type &= ~cJSON_StringIsConst;
        -: 2061:
        2: 2062:    cJSON_ReplaceItemViaPointer(object, get_object_item(object, string, case_sensitive), replacement);
        -: 2063:
        2: 2064:    return true;
        -: 2065:}
        -: 2066:
        4: 2067:CJSON_PUBLIC(void) cJSON_ReplaceItemInObject(cJSON *object, const char *string, cJSON *newitem)
        -: 2068:{
        4: 2069:    replace_item_in_object(object, string, newitem, false);
        4: 2070:}
        -: 2071:
        3: 2072:CJSON_PUBLIC(void) cJSON_ReplaceItemInObjectCaseSensitive(cJSON *object, const char *string, cJSON *newitem)
        -: 2073:{
        3: 2074:    replace_item_in_object(object, string, newitem, true);
        3: 2075:}
        -: 2076:
        -: 2077:/* Create basic types: */
       11: 2078:CJSON_PUBLIC(cJSON *) cJSON_CreateNull(void)
        -: 2079:{
       11: 2080:    cJSON *item = cJSON_New_Item(&global_hooks);
       11: 2081:    if(item)
        -: 2082:    {
       11: 2083:        item->type = cJSON_NULL;
        -: 2084:    }
        -: 2085:
       11: 2086:    return item;
        -: 2087:}
        -: 2088:
        3: 2089:CJSON_PUBLIC(cJSON *) cJSON_CreateTrue(void)
        -: 2090:{
        3: 2091:    cJSON *item = cJSON_New_Item(&global_hooks);
        3: 2092:    if(item)
        -: 2093:    {
        3: 2094:        item->type = cJSON_True;
        -: 2095:    }
        -: 2096:
        3: 2097:    return item;
        -: 2098:}
        -: 2099:
        4: 2100:CJSON_PUBLIC(cJSON *) cJSON_CreateFalse(void)
        -: 2101:{
        4: 2102:    cJSON *item = cJSON_New_Item(&global_hooks);
        4: 2103:    if(item)
        -: 2104:    {
        4: 2105:        item->type = cJSON_False;
        -: 2106:    }
        -: 2107:
        4: 2108:    return item;
        -: 2109:}
        -: 2110:
        5: 2111:CJSON_PUBLIC(cJSON *) cJSON_CreateBool(cJSON_bool boolean)
        -: 2112:{
        5: 2113:    cJSON *item = cJSON_New_Item(&global_hooks);
        5: 2114:    if(item)
        -: 2115:    {
        5: 2116:        item->type = boolean ? cJSON_True : cJSON_False;
        -: 2117:    }
        -: 2118:
        5: 2119:    return item;
        -: 2120:}
        -: 2121:
       46: 2122:CJSON_PUBLIC(cJSON *) cJSON_CreateNumber(double num)
        -: 2123:{
       46: 2124:    cJSON *item = cJSON_New_Item(&global_hooks);
       46: 2125:    if(item)
        -: 2126:    {
       46: 2127:        item->type = cJSON_Number;
       46: 2128:        item->valuedouble = num;
        -: 2129:
        -: 2130:        /* use saturation in case of overflow */
       46: 2131:        if (num >= INT_MAX)
        -: 2132:        {
    #####: 2133:            item->valueint = INT_MAX;
        -: 2134:        }
       46: 2135:        else if (num <= (double)INT_MIN)
        -: 2136:        {
    #####: 2137:            item->valueint = INT_MIN;
        -: 2138:        }
        -: 2139:        else
        -: 2140:        {
       46: 2141:            item->valueint = (int)num;
        -: 2142:        }
        -: 2143:    }
        -: 2144:
       46: 2145:    return item;
        -: 2146:}
        -: 2147:
       27: 2148:CJSON_PUBLIC(cJSON *) cJSON_CreateString(const char *string)
        -: 2149:{
       27: 2150:    cJSON *item = cJSON_New_Item(&global_hooks);
       27: 2151:    if(item)
        -: 2152:    {
       27: 2153:        item->type = cJSON_String;
       27: 2154:        item->valuestring = (char*)cJSON_strdup((const unsigned char*)string, &global_hooks);
       27: 2155:        if(!item->valuestring)
        -: 2156:        {
    #####: 2157:            cJSON_Delete(item);
    #####: 2158:            return NULL;
        -: 2159:        }
        -: 2160:    }
        -: 2161:
       27: 2162:    return item;
        -: 2163:}
        -: 2164:
        1: 2165:CJSON_PUBLIC(cJSON *) cJSON_CreateStringReference(const char *string)
        -: 2166:{
        1: 2167:    cJSON *item = cJSON_New_Item(&global_hooks);
        1: 2168:    if (item != NULL)
        -: 2169:    {
        1: 2170:        item->type = cJSON_String | cJSON_IsReference;
        1: 2171:        item->valuestring = (char*)cast_away_const(string);
        -: 2172:    }
        -: 2173:
        1: 2174:    return item;
        -: 2175:}
        -: 2176:
        1: 2177:CJSON_PUBLIC(cJSON *) cJSON_CreateObjectReference(const cJSON *child)
        -: 2178:{
        1: 2179:    cJSON *item = cJSON_New_Item(&global_hooks);
        1: 2180:    if (item != NULL) {
        1: 2181:        item->type = cJSON_Object | cJSON_IsReference;
        1: 2182:        item->child = (cJSON*)cast_away_const(child);
        -: 2183:    }
        -: 2184:
        1: 2185:    return item;
        -: 2186:}
        -: 2187:
        1: 2188:CJSON_PUBLIC(cJSON *) cJSON_CreateArrayReference(const cJSON *child) {
        1: 2189:    cJSON *item = cJSON_New_Item(&global_hooks);
        1: 2190:    if (item != NULL) {
        1: 2191:        item->type = cJSON_Array | cJSON_IsReference;
        1: 2192:        item->child = (cJSON*)cast_away_const(child);
        -: 2193:    }
        -: 2194:
        1: 2195:    return item;
        -: 2196:}
        -: 2197:
        4: 2198:CJSON_PUBLIC(cJSON *) cJSON_CreateRaw(const char *raw)
        -: 2199:{
        4: 2200:    cJSON *item = cJSON_New_Item(&global_hooks);
        4: 2201:    if(item)
        -: 2202:    {
        4: 2203:        item->type = cJSON_Raw;
        4: 2204:        item->valuestring = (char*)cJSON_strdup((const unsigned char*)raw, &global_hooks);
        4: 2205:        if(!item->valuestring)
        -: 2206:        {
    #####: 2207:            cJSON_Delete(item);
    #####: 2208:            return NULL;
        -: 2209:        }
        -: 2210:    }
        -: 2211:
        4: 2212:    return item;
        -: 2213:}
        -: 2214:
       19: 2215:CJSON_PUBLIC(cJSON *) cJSON_CreateArray(void)
        -: 2216:{
       19: 2217:    cJSON *item = cJSON_New_Item(&global_hooks);
       19: 2218:    if(item)
        -: 2219:    {
       19: 2220:        item->type=cJSON_Array;
        -: 2221:    }
        -: 2222:
       19: 2223:    return item;
        -: 2224:}
        -: 2225:
       13: 2226:CJSON_PUBLIC(cJSON *) cJSON_CreateObject(void)
        -: 2227:{
       13: 2228:    cJSON *item = cJSON_New_Item(&global_hooks);
       13: 2229:    if (item)
        -: 2230:    {
       13: 2231:        item->type = cJSON_Object;
        -: 2232:    }
        -: 2233:
       13: 2234:    return item;
        -: 2235:}
        -: 2236:
        -: 2237:/* Create Arrays: */
        5: 2238:CJSON_PUBLIC(cJSON *) cJSON_CreateIntArray(const int *numbers, int count)
        -: 2239:{
        5: 2240:    size_t i = 0;
        5: 2241:    cJSON *n = NULL;
        5: 2242:    cJSON *p = NULL;
        5: 2243:    cJSON *a = NULL;
        -: 2244:
        5: 2245:    if ((count < 0) || (numbers == NULL))
        -: 2246:    {
        1: 2247:        return NULL;
        -: 2248:    }
        -: 2249:
        4: 2250:    a = cJSON_CreateArray();
       23: 2251:    for(i = 0; a && (i < (size_t)count); i++)
        -: 2252:    {
       19: 2253:        n = cJSON_CreateNumber(numbers[i]);
       19: 2254:        if (!n)
        -: 2255:        {
    #####: 2256:            cJSON_Delete(a);
    #####: 2257:            return NULL;
        -: 2258:        }
       19: 2259:        if(!i)
        -: 2260:        {
        4: 2261:            a->child = n;
        -: 2262:        }
        -: 2263:        else
        -: 2264:        {
       15: 2265:            suffix_object(p, n);
        -: 2266:        }
       19: 2267:        p = n;
        -: 2268:    }
        -: 2269:
        4: 2270:    return a;
        -: 2271:}
        -: 2272:
        2: 2273:CJSON_PUBLIC(cJSON *) cJSON_CreateFloatArray(const float *numbers, int count)
        -: 2274:{
        2: 2275:    size_t i = 0;
        2: 2276:    cJSON *n = NULL;
        2: 2277:    cJSON *p = NULL;
        2: 2278:    cJSON *a = NULL;
        -: 2279:
        2: 2280:    if ((count < 0) || (numbers == NULL))
        -: 2281:    {
        1: 2282:        return NULL;
        -: 2283:    }
        -: 2284:
        1: 2285:    a = cJSON_CreateArray();
        -: 2286:
       11: 2287:    for(i = 0; a && (i < (size_t)count); i++)
        -: 2288:    {
       10: 2289:        n = cJSON_CreateNumber((double)numbers[i]);
       10: 2290:        if(!n)
        -: 2291:        {
    #####: 2292:            cJSON_Delete(a);
    #####: 2293:            return NULL;
        -: 2294:        }
       10: 2295:        if(!i)
        -: 2296:        {
        1: 2297:            a->child = n;
        -: 2298:        }
        -: 2299:        else
        -: 2300:        {
        9: 2301:            suffix_object(p, n);
        -: 2302:        }
       10: 2303:        p = n;
        -: 2304:    }
        -: 2305:
        1: 2306:    return a;
        -: 2307:}
        -: 2308:
        2: 2309:CJSON_PUBLIC(cJSON *) cJSON_CreateDoubleArray(const double *numbers, int count)
        -: 2310:{
        2: 2311:    size_t i = 0;
        2: 2312:    cJSON *n = NULL;
        2: 2313:    cJSON *p = NULL;
        2: 2314:    cJSON *a = NULL;
        -: 2315:
        2: 2316:    if ((count < 0) || (numbers == NULL))
        -: 2317:    {
        1: 2318:        return NULL;
        -: 2319:    }
        -: 2320:
        1: 2321:    a = cJSON_CreateArray();
        -: 2322:
       11: 2323:    for(i = 0;a && (i < (size_t)count); i++)
        -: 2324:    {
       10: 2325:        n = cJSON_CreateNumber(numbers[i]);
       10: 2326:        if(!n)
        -: 2327:        {
    #####: 2328:            cJSON_Delete(a);
    #####: 2329:            return NULL;
        -: 2330:        }
       10: 2331:        if(!i)
        -: 2332:        {
        1: 2333:            a->child = n;
        -: 2334:        }
        -: 2335:        else
        -: 2336:        {
        9: 2337:            suffix_object(p, n);
        -: 2338:        }
       10: 2339:        p = n;
        -: 2340:    }
        -: 2341:
        1: 2342:    return a;
        -: 2343:}
        -: 2344:
        2: 2345:CJSON_PUBLIC(cJSON *) cJSON_CreateStringArray(const char *const *strings, int count)
        -: 2346:{
        2: 2347:    size_t i = 0;
        2: 2348:    cJSON *n = NULL;
        2: 2349:    cJSON *p = NULL;
        2: 2350:    cJSON *a = NULL;
        -: 2351:
        2: 2352:    if ((count < 0) || (strings == NULL))
        -: 2353:    {
        1: 2354:        return NULL;
        -: 2355:    }
        -: 2356:
        1: 2357:    a = cJSON_CreateArray();
        -: 2358:
        8: 2359:    for (i = 0; a && (i < (size_t)count); i++)
        -: 2360:    {
        7: 2361:        n = cJSON_CreateString(strings[i]);
        7: 2362:        if(!n)
        -: 2363:        {
    #####: 2364:            cJSON_Delete(a);
    #####: 2365:            return NULL;
        -: 2366:        }
        7: 2367:        if(!i)
        -: 2368:        {
        1: 2369:            a->child = n;
        -: 2370:        }
        -: 2371:        else
        -: 2372:        {
        6: 2373:            suffix_object(p,n);
        -: 2374:        }
        7: 2375:        p = n;
        -: 2376:    }
        -: 2377:
        1: 2378:    return a;
        -: 2379:}
        -: 2380:
        -: 2381:/* Duplication */
      328: 2382:CJSON_PUBLIC(cJSON *) cJSON_Duplicate(const cJSON *item, cJSON_bool recurse)
        -: 2383:{
      328: 2384:    cJSON *newitem = NULL;
      328: 2385:    cJSON *child = NULL;
      328: 2386:    cJSON *next = NULL;
      328: 2387:    cJSON *newchild = NULL;
        -: 2388:
        -: 2389:    /* Bail on bad ptr */
      328: 2390:    if (!item)
        -: 2391:    {
        1: 2392:        goto fail;
        -: 2393:    }
        -: 2394:    /* Create new item */
      327: 2395:    newitem = cJSON_New_Item(&global_hooks);
      327: 2396:    if (!newitem)
        -: 2397:    {
    #####: 2398:        goto fail;
        -: 2399:    }
        -: 2400:    /* Copy over all vars */
      327: 2401:    newitem->type = item->type & (~cJSON_IsReference);
      327: 2402:    newitem->valueint = item->valueint;
      327: 2403:    newitem->valuedouble = item->valuedouble;
      327: 2404:    if (item->valuestring)
        -: 2405:    {
       76: 2406:        newitem->valuestring = (char*)cJSON_strdup((unsigned char*)item->valuestring, &global_hooks);
       76: 2407:        if (!newitem->valuestring)
        -: 2408:        {
    #####: 2409:            goto fail;
        -: 2410:        }
        -: 2411:    }
      327: 2412:    if (item->string)
        -: 2413:    {
      214: 2414:        newitem->string = (item->type&cJSON_StringIsConst) ? item->string : (char*)cJSON_strdup((unsigned char*)item->string, &global_hooks);
      214: 2415:        if (!newitem->string)
        -: 2416:        {
    #####: 2417:            goto fail;
        -: 2418:        }
        -: 2419:    }
        -: 2420:    /* If non-recursive, then we're done! */
      327: 2421:    if (!recurse)
        -: 2422:    {
    #####: 2423:        return newitem;
        -: 2424:    }
        -: 2425:    /* Walk the ->next chain for the child. */
      327: 2426:    child = item->child;
      773: 2427:    while (child != NULL)
        -: 2428:    {
      223: 2429:        newchild = cJSON_Duplicate(child, true); /* Duplicate (with recurse) each item in the ->next chain */
      223: 2430:        if (!newchild)
        -: 2431:        {
    #####: 2432:            goto fail;
        -: 2433:        }
      223: 2434:        if (next != NULL)
        -: 2435:        {
        -: 2436:            /* If newitem->child already set, then crosswire ->prev and ->next and move on */
       86: 2437:            next->next = newchild;
       86: 2438:            newchild->prev = next;
       86: 2439:            next = newchild;
        -: 2440:        }
        -: 2441:        else
        -: 2442:        {
        -: 2443:            /* Set newitem->child and move to it */
      137: 2444:            newitem->child = newchild;
      137: 2445:            next = newchild;
        -: 2446:        }
      223: 2447:        child = child->next;
        -: 2448:    }
        -: 2449:
      327: 2450:    return newitem;
        -: 2451:
        1: 2452:fail:
        1: 2453:    if (newitem != NULL)
        -: 2454:    {
    #####: 2455:        cJSON_Delete(newitem);
        -: 2456:    }
        -: 2457:
        1: 2458:    return NULL;
        -: 2459:}
        -: 2460:
        2: 2461:static void skip_oneline_comment(char **input)
        -: 2462:{
        2: 2463:    *input += static_strlen("//");
        -: 2464:
      128: 2465:    for (; (*input)[0] != '\0'; ++(*input))
        -: 2466:    {
       65: 2467:        if ((*input)[0] == '\n') {
        2: 2468:            *input += static_strlen("\n");
        2: 2469:            return;
        -: 2470:        }
        -: 2471:    }
        -: 2472:}
        -: 2473:
        3: 2474:static void skip_multiline_comment(char **input)
        -: 2475:{
        3: 2476:    *input += static_strlen("/*");
        -: 2477:
      177: 2478:    for (; (*input)[0] != '\0'; ++(*input))
        -: 2479:    {
       90: 2480:        if (((*input)[0] == '*') && ((*input)[1] == '/'))
        -: 2481:        {
        3: 2482:            *input += static_strlen("*/");
        3: 2483:            return;
        -: 2484:        }
        -: 2485:    }
        -: 2486:}
        -: 2487:
       26: 2488:static void minify_string(char **input, char **output) {
       26: 2489:    (*output)[0] = (*input)[0];
       26: 2490:    *input += static_strlen("\"");
       26: 2491:    *output += static_strlen("\"");
        -: 2492:
        -: 2493:
      394: 2494:    for (; (*input)[0] != '\0'; (void)++(*input), ++(*output)) {
      208: 2495:        (*output)[0] = (*input)[0];
        -: 2496:
      208: 2497:        if ((*input)[0] == '\"') {
       24: 2498:            (*output)[0] = '\"';
       24: 2499:            *input += static_strlen("\"");
       24: 2500:            *output += static_strlen("\"");
       24: 2501:            return;
      184: 2502:        } else if (((*input)[0] == '\\') && ((*input)[1] == '\"')) {
        1: 2503:            (*output)[1] = (*input)[1];
        1: 2504:            *input += static_strlen("\"");
        1: 2505:            *output += static_strlen("\"");
        -: 2506:        }
        -: 2507:    }
        -: 2508:}
        -: 2509:
        9: 2510:CJSON_PUBLIC(void) cJSON_Minify(char *json)
        -: 2511:{
        9: 2512:    char *into = json;
        -: 2513:
        9: 2514:    if (json == NULL)
        -: 2515:    {
        1: 2516:        return;
        -: 2517:    }
        -: 2518:
      594: 2519:    while (json[0] != '\0')
        -: 2520:    {
      293: 2521:        switch (json[0])
        -: 2522:        {
      205: 2523:            case ' ':
        -: 2524:            case '\t':
        -: 2525:            case '\r':
        -: 2526:            case '\n':
      205: 2527:                json++;
      205: 2528:                break;
        -: 2529:
        6: 2530:            case '/':
        6: 2531:                if (json[1] == '/')
        -: 2532:                {
        2: 2533:                    skip_oneline_comment(&json);
        -: 2534:                }
        4: 2535:                else if (json[1] == '*')
        -: 2536:                {
        3: 2537:                    skip_multiline_comment(&json);
        -: 2538:                } else {
        1: 2539:                    json++;
        -: 2540:                }
        6: 2541:                break;
        -: 2542:
       26: 2543:            case '\"':
       26: 2544:                minify_string(&json, (char**)&into);
       26: 2545:                break;
        -: 2546:
       56: 2547:            default:
       56: 2548:                into[0] = json[0];
       56: 2549:                json++;
       56: 2550:                into++;
        -: 2551:        }
        -: 2552:    }
        -: 2553:
        -: 2554:    /* and null-terminate. */
        8: 2555:    *into = '\0';
        -: 2556:}
        -: 2557:
      382: 2558:CJSON_PUBLIC(cJSON_bool) cJSON_IsInvalid(const cJSON * const item)
        -: 2559:{
      382: 2560:    if (item == NULL)
        -: 2561:    {
        1: 2562:        return false;
        -: 2563:    }
        -: 2564:
      381: 2565:    return (item->type & 0xFF) == cJSON_Invalid;
        -: 2566:}
        -: 2567:
        3: 2568:CJSON_PUBLIC(cJSON_bool) cJSON_IsFalse(const cJSON * const item)
        -: 2569:{
        3: 2570:    if (item == NULL)
        -: 2571:    {
        1: 2572:        return false;
        -: 2573:    }
        -: 2574:
        2: 2575:    return (item->type & 0xFF) == cJSON_False;
        -: 2576:}
        -: 2577:
      109: 2578:CJSON_PUBLIC(cJSON_bool) cJSON_IsTrue(const cJSON * const item)
        -: 2579:{
      109: 2580:    if (item == NULL)
        -: 2581:    {
      103: 2582:        return false;
        -: 2583:    }
        -: 2584:
        6: 2585:    return (item->type & 0xff) == cJSON_True;
        -: 2586:}
        -: 2587:
        -: 2588:
        2: 2589:CJSON_PUBLIC(cJSON_bool) cJSON_IsBool(const cJSON * const item)
        -: 2590:{
        2: 2591:    if (item == NULL)
        -: 2592:    {
        1: 2593:        return false;
        -: 2594:    }
        -: 2595:
        1: 2596:    return (item->type & (cJSON_True | cJSON_False)) != 0;
        -: 2597:}
        2: 2598:CJSON_PUBLIC(cJSON_bool) cJSON_IsNull(const cJSON * const item)
        -: 2599:{
        2: 2600:    if (item == NULL)
        -: 2601:    {
        1: 2602:        return false;
        -: 2603:    }
        -: 2604:
        1: 2605:    return (item->type & 0xFF) == cJSON_NULL;
        -: 2606:}
        -: 2607:
        3: 2608:CJSON_PUBLIC(cJSON_bool) cJSON_IsNumber(const cJSON * const item)
        -: 2609:{
        3: 2610:    if (item == NULL)
        -: 2611:    {
        1: 2612:        return false;
        -: 2613:    }
        -: 2614:
        2: 2615:    return (item->type & 0xFF) == cJSON_Number;
        -: 2616:}
        -: 2617:
      109: 2618:CJSON_PUBLIC(cJSON_bool) cJSON_IsString(const cJSON * const item)
        -: 2619:{
      109: 2620:    if (item == NULL)
        -: 2621:    {
       24: 2622:        return false;
        -: 2623:    }
        -: 2624:
       85: 2625:    return (item->type & 0xFF) == cJSON_String;
        -: 2626:}
        -: 2627:
        3: 2628:CJSON_PUBLIC(cJSON_bool) cJSON_IsArray(const cJSON * const item)
        -: 2629:{
        3: 2630:    if (item == NULL)
        -: 2631:    {
        1: 2632:        return false;
        -: 2633:    }
        -: 2634:
        2: 2635:    return (item->type & 0xFF) == cJSON_Array;
        -: 2636:}
        -: 2637:
        3: 2638:CJSON_PUBLIC(cJSON_bool) cJSON_IsObject(const cJSON * const item)
        -: 2639:{
        3: 2640:    if (item == NULL)
        -: 2641:    {
        1: 2642:        return false;
        -: 2643:    }
        -: 2644:
        2: 2645:    return (item->type & 0xFF) == cJSON_Object;
        -: 2646:}
        -: 2647:
        3: 2648:CJSON_PUBLIC(cJSON_bool) cJSON_IsRaw(const cJSON * const item)
        -: 2649:{
        3: 2650:    if (item == NULL)
        -: 2651:    {
        1: 2652:        return false;
        -: 2653:    }
        -: 2654:
        2: 2655:    return (item->type & 0xFF) == cJSON_Raw;
        -: 2656:}
        -: 2657:
      398: 2658:CJSON_PUBLIC(cJSON_bool) cJSON_Compare(const cJSON * const a, const cJSON * const b, const cJSON_bool case_sensitive)
        -: 2659:{
      398: 2660:    if ((a == NULL) || (b == NULL) || ((a->type & 0xFF) != (b->type & 0xFF)) || cJSON_IsInvalid(a))
        -: 2661:    {
       20: 2662:        return false;
        -: 2663:    }
        -: 2664:
        -: 2665:    /* check if type is valid */
      378: 2666:    switch (a->type & 0xFF)
        -: 2667:    {
      376: 2668:        case cJSON_False:
        -: 2669:        case cJSON_True:
        -: 2670:        case cJSON_NULL:
        -: 2671:        case cJSON_Number:
        -: 2672:        case cJSON_String:
        -: 2673:        case cJSON_Raw:
        -: 2674:        case cJSON_Array:
        -: 2675:        case cJSON_Object:
      376: 2676:            break;
        -: 2677:
        2: 2678:        default:
        2: 2679:            return false;
        -: 2680:    }
        -: 2681:
        -: 2682:    /* identical objects are equal */
      376: 2683:    if (a == b)
        -: 2684:    {
        1: 2685:        return true;
        -: 2686:    }
        -: 2687:
      375: 2688:    switch (a->type & 0xFF)
        -: 2689:    {
        -: 2690:        /* in these cases and equal type is enough */
       32: 2691:        case cJSON_False:
        -: 2692:        case cJSON_True:
        -: 2693:        case cJSON_NULL:
       32: 2694:            return true;
        -: 2695:
      137: 2696:        case cJSON_Number:
      137: 2697:            if (compare_double(a->valuedouble, b->valuedouble))
        -: 2698:            {
      133: 2699:                return true;
        -: 2700:            }
        4: 2701:            return false;
        -: 2702:
       61: 2703:        case cJSON_String:
        -: 2704:        case cJSON_Raw:
       61: 2705:            if ((a->valuestring == NULL) || (b->valuestring == NULL))
        -: 2706:            {
        6: 2707:                return false;
        -: 2708:            }
       55: 2709:            if (strcmp(a->valuestring, b->valuestring) == 0)
        -: 2710:            {
       45: 2711:                return true;
        -: 2712:            }
        -: 2713:
       10: 2714:            return false;
        -: 2715:
       62: 2716:        case cJSON_Array:
        -: 2717:        {
       62: 2718:            cJSON *a_element = a->child;
       62: 2719:            cJSON *b_element = b->child;
        -: 2720:
      222: 2721:            for (; (a_element != NULL) && (b_element != NULL);)
        -: 2722:            {
      102: 2723:                if (!cJSON_Compare(a_element, b_element, case_sensitive))
        -: 2724:                {
       22: 2725:                    return false;
        -: 2726:                }
        -: 2727:
       80: 2728:                a_element = a_element->next;
       80: 2729:                b_element = b_element->next;
        -: 2730:            }
        -: 2731:
        -: 2732:            /* one of the arrays is longer than the other */
       40: 2733:            if (a_element != b_element) {
        9: 2734:                return false;
        -: 2735:            }
        -: 2736:
       31: 2737:            return true;
        -: 2738:        }
        -: 2739:
       83: 2740:        case cJSON_Object:
        -: 2741:        {
       83: 2742:            cJSON *a_element = NULL;
       83: 2743:            cJSON *b_element = NULL;
      163: 2744:            cJSON_ArrayForEach(a_element, a)
        -: 2745:            {
        -: 2746:                /* TODO This has O(n^2) runtime, which is horrible! */
      108: 2747:                b_element = get_object_item(b, a_element->string, case_sensitive);
      108: 2748:                if (b_element == NULL)
        -: 2749:                {
       12: 2750:                    return false;
        -: 2751:                }
        -: 2752:
       96: 2753:                if (!cJSON_Compare(a_element, b_element, case_sensitive))
        -: 2754:                {
       16: 2755:                    return false;
        -: 2756:                }
        -: 2757:            }
        -: 2758:
        -: 2759:            /* doing this twice, once on a and b to prevent true comparison if a subset of b
        -: 2760:             * TODO: Do this the proper way, this is just a fix for now */
      129: 2761:            cJSON_ArrayForEach(b_element, b)
        -: 2762:            {
       92: 2763:                a_element = get_object_item(a, b_element->string, case_sensitive);
       92: 2764:                if (a_element == NULL)
        -: 2765:                {
       18: 2766:                    return false;
        -: 2767:                }
        -: 2768:
       74: 2769:                if (!cJSON_Compare(b_element, a_element, case_sensitive))
        -: 2770:                {
    #####: 2771:                    return false;
        -: 2772:                }
        -: 2773:            }
        -: 2774:
       37: 2775:            return true;
        -: 2776:        }
        -: 2777:
    #####: 2778:        default:
    #####: 2779:            return false;
        -: 2780:    }
        -: 2781:}
        -: 2782:
        1: 2783:CJSON_PUBLIC(void *) cJSON_malloc(size_t size)
        -: 2784:{
        1: 2785:    return global_hooks.allocate(size);
        -: 2786:}
        -: 2787:
        1: 2788:CJSON_PUBLIC(void) cJSON_free(void *object)
        -: 2789:{
        1: 2790:    global_hooks.deallocate(object);
        1: 2791:}
