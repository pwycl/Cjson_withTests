        -:    0:Source:/mnt/d/CLionProjects/Cjson_withTests/Cjson_lib/cJSON.c
        -:    0:Graph:ConverterTests.cpp.gcno
        -:    0:Data:ConverterTests.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2:  Copyright (c) 2009-2017 Dave Gamble and cJSON contributors
        -:    3:
        -:    4:  Permission is hereby granted, free of charge, to any person obtaining a copy
        -:    5:  of this software and associated documentation files (the "Software"), to deal
        -:    6:  in the Software without restriction, including without limitation the rights
        -:    7:  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        -:    8:  copies of the Software, and to permit persons to whom the Software is
        -:    9:  furnished to do so, subject to the following conditions:
        -:   10:
        -:   11:  The above copyright notice and this permission notice shall be included in
        -:   12:  all copies or substantial portions of the Software.
        -:   13:
        -:   14:  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        -:   15:  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        -:   16:  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        -:   17:  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        -:   18:  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        -:   19:  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
        -:   20:  THE SOFTWARE.
        -:   21:*/
        -:   22:
        -:   23:/* cJSON */
        -:   24:/* JSON parser in C. */
        -:   25:
        -:   26:/* disable warnings about old C89 functions in MSVC */
        -:   27:#if !defined(_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER)
        -:   28:#define _CRT_SECURE_NO_DEPRECATE
        -:   29:#endif
        -:   30:
        -:   31:#ifdef __GNUC__
        -:   32:#pragma GCC visibility push(default)
        -:   33:#endif
        -:   34:#if defined(_MSC_VER)
        -:   35:#pragma warning (push)
        -:   36:/* disable warning about single line comments in system headers */
        -:   37:#pragma warning (disable : 4001)
        -:   38:#endif
        -:   39:
        -:   40:#include <string.h>
        -:   41:#include <stdio.h>
        -:   42:#include <math.h>
        -:   43:#include <stdlib.h>
        -:   44:#include <limits.h>
        -:   45:#include <ctype.h>
        -:   46:
        -:   47:#ifdef ENABLE_LOCALES
        -:   48:#include <locale.h>
        -:   49:#endif
        -:   50:
        -:   51:#if defined(_MSC_VER)
        -:   52:#pragma warning (pop)
        -:   53:#endif
        -:   54:#ifdef __GNUC__
        -:   55:#pragma GCC visibility pop
        -:   56:#endif
        -:   57:
        -:   58:#include "cJSON.h"
        -:   59:
        -:   60:/* define our own boolean type */
        -:   61:#ifdef true
        -:   62:#undef true
        -:   63:#endif
        -:   64:#define true ((cJSON_bool)1)
        -:   65:
        -:   66:#ifdef false
        -:   67:#undef false
        -:   68:#endif
        -:   69:#define false ((cJSON_bool)0)
        -:   70:
        -:   71:typedef struct {
        -:   72:    const unsigned char *json;
        -:   73:    size_t position;
        -:   74:} error;
        -:   75:static error global_error = { NULL, 0 };
        -:   76:
    #####:   77:CJSON_PUBLIC(const char *) cJSON_GetErrorPtr(void)
        -:   78:{
    #####:   79:    return (const char*) (global_error.json + global_error.position);
        -:   80:}
        -:   81:
    #####:   82:CJSON_PUBLIC(char *) cJSON_GetStringValue(const cJSON * const item) {
    #####:   83:    if (!cJSON_IsString(item)) {
    #####:   84:        return NULL;
        -:   85:    }
        -:   86:
    #####:   87:    return item->valuestring;
        -:   88:}
        -:   89:
        -:   90:/* This is a safeguard to prevent copy-pasters from using incompatible C and header files */
        -:   91:#if (CJSON_VERSION_MAJOR != 1) || (CJSON_VERSION_MINOR != 7) || (CJSON_VERSION_PATCH != 12)
        -:   92:    #error cJSON.h and cJSON.c have different versions. Make sure that both have the same.
        -:   93:#endif
        -:   94:
    #####:   95:CJSON_PUBLIC(const char*) cJSON_Version(void)
        -:   96:{
        -:   97:    static char version[15];
    #####:   98:    sprintf(version, "%i.%i.%i", CJSON_VERSION_MAJOR, CJSON_VERSION_MINOR, CJSON_VERSION_PATCH);
        -:   99:
    #####:  100:    return version;
        -:  101:}
        -:  102:
        -:  103:/* Case insensitive string comparison, doesn't consider two NULL pointers equal though */
       71:  104:static int case_insensitive_strcmp(const unsigned char *string1, const unsigned char *string2)
        -:  105:{
       71:  106:    if ((string1 == NULL) || (string2 == NULL))
        -:  107:    {
    #####:  108:        return 1;
        -:  109:    }
        -:  110:
       71:  111:    if (string1 == string2)
        -:  112:    {
    #####:  113:        return 0;
        -:  114:    }
        -:  115:
      251:  116:    for(; tolower(*string1) == tolower(*string2); (void)string1++, string2++)
        -:  117:    {
      108:  118:        if (*string1 == '\0')
        -:  119:        {
       18:  120:            return 0;
        -:  121:        }
        -:  122:    }
        -:  123:
       53:  124:    return tolower(*string1) - tolower(*string2);
        -:  125:}
        -:  126:
        -:  127:typedef struct internal_hooks
        -:  128:{
        -:  129:    void *(CJSON_CDECL *allocate)(size_t size);
        -:  130:    void (CJSON_CDECL *deallocate)(void *pointer);
        -:  131:    void *(CJSON_CDECL *reallocate)(void *pointer, size_t size);
        -:  132:} internal_hooks;
        -:  133:
        -:  134:#if defined(_MSC_VER)
        -:  135:/* work around MSVC error C2322: '...' address of dllimport '...' is not static */
        -:  136:static void * CJSON_CDECL internal_malloc(size_t size)
        -:  137:{
        -:  138:    return malloc(size);
        -:  139:}
        -:  140:static void CJSON_CDECL internal_free(void *pointer)
        -:  141:{
        -:  142:    free(pointer);
        -:  143:}
        -:  144:static void * CJSON_CDECL internal_realloc(void *pointer, size_t size)
        -:  145:{
        -:  146:    return realloc(pointer, size);
        -:  147:}
        -:  148:#else
        -:  149:#define internal_malloc malloc
        -:  150:#define internal_free free
        -:  151:#define internal_realloc realloc
        -:  152:#endif
        -:  153:
        -:  154:/* strlen of character literals resolved at compile time */
        -:  155:#define static_strlen(string_literal) (sizeof(string_literal) - sizeof(""))
        -:  156:
        -:  157:static internal_hooks global_hooks = { internal_malloc, internal_free, internal_realloc };
        -:  158:
       47:  159:static unsigned char* cJSON_strdup(const unsigned char* string, const internal_hooks * const hooks)
        -:  160:{
       47:  161:    size_t length = 0;
       47:  162:    unsigned char *copy = NULL;
        -:  163:
       47:  164:    if (string == NULL)
        -:  165:    {
    #####:  166:        return NULL;
        -:  167:    }
        -:  168:
       47:  169:    length = strlen((const char*)string) + sizeof("");
       47:  170:    copy = (unsigned char*)hooks->allocate(length);
       47:  171:    if (copy == NULL)
        -:  172:    {
    #####:  173:        return NULL;
        -:  174:    }
       47:  175:    memcpy(copy, string, length);
        -:  176:
       47:  177:    return copy;
        -:  178:}
        -:  179:
        2:  180:CJSON_PUBLIC(void) cJSON_InitHooks(cJSON_Hooks* hooks)
        -:  181:{
        2:  182:    if (hooks == NULL)
        -:  183:    {
        -:  184:        /* Reset hooks */
        1:  185:        global_hooks.allocate = malloc;
        1:  186:        global_hooks.deallocate = free;
        1:  187:        global_hooks.reallocate = realloc;
        1:  188:        return;
        -:  189:    }
        -:  190:
        1:  191:    global_hooks.allocate = malloc;
        1:  192:    if (hooks->malloc_fn != NULL)
        -:  193:    {
        1:  194:        global_hooks.allocate = hooks->malloc_fn;
        -:  195:    }
        -:  196:
        1:  197:    global_hooks.deallocate = free;
        1:  198:    if (hooks->free_fn != NULL)
        -:  199:    {
        1:  200:        global_hooks.deallocate = hooks->free_fn;
        -:  201:    }
        -:  202:
        -:  203:    /* use realloc only if both free and malloc are used */
        1:  204:    global_hooks.reallocate = NULL;
        1:  205:    if ((global_hooks.allocate == malloc) && (global_hooks.deallocate == free))
        -:  206:    {
    #####:  207:        global_hooks.reallocate = realloc;
        -:  208:    }
        -:  209:}
        -:  210:
        -:  211:/* Internal constructor. */
      468:  212:static cJSON *cJSON_New_Item(const internal_hooks * const hooks)
        -:  213:{
      468:  214:    cJSON* node = (cJSON*)hooks->allocate(sizeof(cJSON));
      468:  215:    if (node)
        -:  216:    {
      468:  217:        memset(node, '\0', sizeof(cJSON));
        -:  218:    }
        -:  219:
      468:  220:    return node;
        -:  221:}
        -:  222:
        -:  223:/* Delete a cJSON structure. */
      166:  224:CJSON_PUBLIC(void) cJSON_Delete(cJSON *item)
        -:  225:{
      166:  226:    cJSON *next = NULL;
      758:  227:    while (item != NULL)
        -:  228:    {
      296:  229:        next = item->next;
      296:  230:        if (!(item->type & cJSON_IsReference) && (item->child != NULL))
        -:  231:        {
       38:  232:            cJSON_Delete(item->child);
        -:  233:        }
      296:  234:        if (!(item->type & cJSON_IsReference) && (item->valuestring != NULL))
        -:  235:        {
       36:  236:            global_hooks.deallocate(item->valuestring);
        -:  237:        }
      296:  238:        if (!(item->type & cJSON_StringIsConst) && (item->string != NULL))
        -:  239:        {
       82:  240:            global_hooks.deallocate(item->string);
        -:  241:        }
      296:  242:        global_hooks.deallocate(item);
      296:  243:        item = next;
        -:  244:    }
      166:  245:}
        -:  246:
        -:  247:/* get the decimal point character of the current locale */
       96:  248:static unsigned char get_decimal_point(void)
        -:  249:{
        -:  250:#ifdef ENABLE_LOCALES
        -:  251:    struct lconv *lconv = localeconv();
        -:  252:    return (unsigned char) lconv->decimal_point[0];
        -:  253:#else
       96:  254:    return '.';
        -:  255:#endif
        -:  256:}
        -:  257:
        -:  258:typedef struct
        -:  259:{
        -:  260:    const unsigned char *content;
        -:  261:    size_t length;
        -:  262:    size_t offset;
        -:  263:    size_t depth; /* How deeply nested (in arrays/objects) is the input at the current offset. */
        -:  264:    internal_hooks hooks;
        -:  265:} parse_buffer;
        -:  266:
        -:  267:/* check if the given size is left to read in a given parse buffer (starting with 1) */
        -:  268:#define can_read(buffer, size) ((buffer != NULL) && (((buffer)->offset + size) <= (buffer)->length))
        -:  269:/* check if the buffer can be accessed at the given index (starting with 0) */
        -:  270:#define can_access_at_index(buffer, index) ((buffer != NULL) && (((buffer)->offset + index) < (buffer)->length))
        -:  271:#define cannot_access_at_index(buffer, index) (!can_access_at_index(buffer, index))
        -:  272:/* get a pointer to the buffer at the position */
        -:  273:#define buffer_at_offset(buffer) ((buffer)->content + (buffer)->offset)
        -:  274:
        -:  275:/* Parse the input text to generate a number, and populate the result into item. */
       72:  276:static cJSON_bool parse_number(cJSON * const item, parse_buffer * const input_buffer)
        -:  277:{
       72:  278:    double number = 0;
       72:  279:    unsigned char *after_end = NULL;
        -:  280:    unsigned char number_c_string[64];
       72:  281:    unsigned char decimal_point = get_decimal_point();
       72:  282:    size_t i = 0;
        -:  283:
       72:  284:    if ((input_buffer == NULL) || (input_buffer->content == NULL))
        -:  285:    {
    #####:  286:        return false;
        -:  287:    }
        -:  288:
        -:  289:    /* copy the number into a temporary buffer and replace '.' with the decimal point
        -:  290:     * of the current locale (for strtod)
        -:  291:     * This also takes care of '\0' not necessarily being available for marking the end of the input */
      360:  292:    for (i = 0; (i < (sizeof(number_c_string) - 1)) && can_access_at_index(input_buffer, i); i++)
        -:  293:    {
      180:  294:        switch (buffer_at_offset(input_buffer)[i])
        -:  295:        {
      104:  296:            case '0':
        -:  297:            case '1':
        -:  298:            case '2':
        -:  299:            case '3':
        -:  300:            case '4':
        -:  301:            case '5':
        -:  302:            case '6':
        -:  303:            case '7':
        -:  304:            case '8':
        -:  305:            case '9':
        -:  306:            case '+':
        -:  307:            case '-':
        -:  308:            case 'e':
        -:  309:            case 'E':
      104:  310:                number_c_string[i] = buffer_at_offset(input_buffer)[i];
      104:  311:                break;
        -:  312:
        4:  313:            case '.':
        4:  314:                number_c_string[i] = decimal_point;
        4:  315:                break;
        -:  316:
       72:  317:            default:
       72:  318:                goto loop_end;
        -:  319:        }
        -:  320:    }
    #####:  321:loop_end:
       72:  322:    number_c_string[i] = '\0';
        -:  323:
       72:  324:    number = strtod((const char*)number_c_string, (char**)&after_end);
       72:  325:    if (number_c_string == after_end)
        -:  326:    {
    #####:  327:        return false; /* parse_error */
        -:  328:    }
        -:  329:
       72:  330:    item->valuedouble = number;
        -:  331:
        -:  332:    /* use saturation in case of overflow */
       72:  333:    if (number >= INT_MAX)
        -:  334:    {
    #####:  335:        item->valueint = INT_MAX;
        -:  336:    }
       72:  337:    else if (number <= (double)INT_MIN)
        -:  338:    {
    #####:  339:        item->valueint = INT_MIN;
        -:  340:    }
        -:  341:    else
        -:  342:    {
       72:  343:        item->valueint = (int)number;
        -:  344:    }
        -:  345:
       72:  346:    item->type = cJSON_Number;
        -:  347:
       72:  348:    input_buffer->offset += (size_t)(after_end - number_c_string);
       72:  349:    return true;
        -:  350:}
        -:  351:
        -:  352:/* don't ask me, but the original cJSON_SetNumberValue returns an integer or double */
    #####:  353:CJSON_PUBLIC(double) cJSON_SetNumberHelper(cJSON *object, double number)
        -:  354:{
    #####:  355:    if (number >= INT_MAX)
        -:  356:    {
    #####:  357:        object->valueint = INT_MAX;
        -:  358:    }
    #####:  359:    else if (number <= (double)INT_MIN)
        -:  360:    {
    #####:  361:        object->valueint = INT_MIN;
        -:  362:    }
        -:  363:    else
        -:  364:    {
    #####:  365:        object->valueint = (int)number;
        -:  366:    }
        -:  367:
    #####:  368:    return object->valuedouble = number;
        -:  369:}
        -:  370:
        -:  371:typedef struct
        -:  372:{
        -:  373:    unsigned char *buffer;
        -:  374:    size_t length;
        -:  375:    size_t offset;
        -:  376:    size_t depth; /* current nesting depth (for formatted printing) */
        -:  377:    cJSON_bool noalloc;
        -:  378:    cJSON_bool format; /* is this print a formatted print */
        -:  379:    internal_hooks hooks;
        -:  380:} printbuffer;
        -:  381:
        -:  382:/* realloc printbuffer if necessary to have at least "needed" bytes more */
      449:  383:static unsigned char* ensure(printbuffer * const p, size_t needed)
        -:  384:{
      449:  385:    unsigned char *newbuffer = NULL;
      449:  386:    size_t newsize = 0;
        -:  387:
      449:  388:    if ((p == NULL) || (p->buffer == NULL))
        -:  389:    {
    #####:  390:        return NULL;
        -:  391:    }
        -:  392:
      449:  393:    if ((p->length > 0) && (p->offset >= p->length))
        -:  394:    {
        -:  395:        /* make sure that offset is valid */
    #####:  396:        return NULL;
        -:  397:    }
        -:  398:
      449:  399:    if (needed > INT_MAX)
        -:  400:    {
        -:  401:        /* sizes bigger than INT_MAX are currently not supported */
    #####:  402:        return NULL;
        -:  403:    }
        -:  404:
      449:  405:    needed += p->offset + 1;
      449:  406:    if (needed <= p->length)
        -:  407:    {
      449:  408:        return p->buffer + p->offset;
        -:  409:    }
        -:  410:
    #####:  411:    if (p->noalloc) {
    #####:  412:        return NULL;
        -:  413:    }
        -:  414:
        -:  415:    /* calculate new buffer size */
    #####:  416:    if (needed > (INT_MAX / 2))
        -:  417:    {
        -:  418:        /* overflow of int, use INT_MAX if possible */
    #####:  419:        if (needed <= INT_MAX)
        -:  420:        {
    #####:  421:            newsize = INT_MAX;
        -:  422:        }
        -:  423:        else
        -:  424:        {
    #####:  425:            return NULL;
        -:  426:        }
        -:  427:    }
        -:  428:    else
        -:  429:    {
    #####:  430:        newsize = needed * 2;
        -:  431:    }
        -:  432:
    #####:  433:    if (p->hooks.reallocate != NULL)
        -:  434:    {
        -:  435:        /* reallocate with realloc if available */
    #####:  436:        newbuffer = (unsigned char*)p->hooks.reallocate(p->buffer, newsize);
    #####:  437:        if (newbuffer == NULL)
        -:  438:        {
    #####:  439:            p->hooks.deallocate(p->buffer);
    #####:  440:            p->length = 0;
    #####:  441:            p->buffer = NULL;
        -:  442:
    #####:  443:            return NULL;
        -:  444:        }
        -:  445:    }
        -:  446:    else
        -:  447:    {
        -:  448:        /* otherwise reallocate manually */
    #####:  449:        newbuffer = (unsigned char*)p->hooks.allocate(newsize);
    #####:  450:        if (!newbuffer)
        -:  451:        {
    #####:  452:            p->hooks.deallocate(p->buffer);
    #####:  453:            p->length = 0;
    #####:  454:            p->buffer = NULL;
        -:  455:
    #####:  456:            return NULL;
        -:  457:        }
    #####:  458:        if (newbuffer)
        -:  459:        {
    #####:  460:            memcpy(newbuffer, p->buffer, p->offset + 1);
        -:  461:        }
    #####:  462:        p->hooks.deallocate(p->buffer);
        -:  463:    }
    #####:  464:    p->length = newsize;
    #####:  465:    p->buffer = newbuffer;
        -:  466:
    #####:  467:    return newbuffer + p->offset;
        -:  468:}
        -:  469:
        -:  470:/* calculate the new length of the string in a printbuffer and update the offset */
      189:  471:static void update_offset(printbuffer * const buffer)
        -:  472:{
      189:  473:    const unsigned char *buffer_pointer = NULL;
      189:  474:    if ((buffer == NULL) || (buffer->buffer == NULL))
        -:  475:    {
    #####:  476:        return;
        -:  477:    }
      189:  478:    buffer_pointer = buffer->buffer + buffer->offset;
        -:  479:
      189:  480:    buffer->offset += strlen((const char*)buffer_pointer);
        -:  481:}
        -:  482:
        -:  483:/* securely comparison of floating-point variables */
       76:  484:static cJSON_bool compare_double(double a, double b)
        -:  485:{
       76:  486:    return (fabs(a - b) <= CJSON_DOUBLE_PRECISION);
        -:  487:}
        -:  488:
        -:  489:/* Render the number nicely from the given item into a string. */
       24:  490:static cJSON_bool print_number(const cJSON * const item, printbuffer * const output_buffer)
        -:  491:{
       24:  492:    unsigned char *output_pointer = NULL;
       24:  493:    double d = item->valuedouble;
       24:  494:    int length = 0;
       24:  495:    size_t i = 0;
       24:  496:    unsigned char number_buffer[26] = {0}; /* temporary buffer to print the number into */
       24:  497:    unsigned char decimal_point = get_decimal_point();
       24:  498:    double test = 0.0;
        -:  499:
       24:  500:    if (output_buffer == NULL)
        -:  501:    {
    #####:  502:        return false;
        -:  503:    }
        -:  504:
        -:  505:    /* This checks for NaN and Infinity */
       24:  506:    if (!compare_double(d * 0, 0))
        -:  507:    {
    #####:  508:        length = sprintf((char*)number_buffer, "null");
        -:  509:    }
        -:  510:    else
        -:  511:    {
        -:  512:        /* Try 15 decimal places of precision to avoid nonsignificant nonzero digits */
       24:  513:        length = sprintf((char*)number_buffer, "%1.15g", d);
        -:  514:
        -:  515:        /* Check whether the original double can be recovered */
       24:  516:        if ((sscanf((char*)number_buffer, "%lg", &test) != 1) || !compare_double((double)test, d))
        -:  517:        {
        -:  518:            /* If not, print with 17 decimal places of precision */
    #####:  519:            length = sprintf((char*)number_buffer, "%1.17g", d);
        -:  520:        }
        -:  521:    }
        -:  522:
        -:  523:    /* sprintf failed or buffer overrun occurred */
       24:  524:    if ((length < 0) || (length > (int)(sizeof(number_buffer) - 1)))
        -:  525:    {
    #####:  526:        return false;
        -:  527:    }
        -:  528:
        -:  529:    /* reserve appropriate space in the output */
       24:  530:    output_pointer = ensure(output_buffer, (size_t)length + sizeof(""));
       24:  531:    if (output_pointer == NULL)
        -:  532:    {
    #####:  533:        return false;
        -:  534:    }
        -:  535:
        -:  536:    /* copy the printed number to the output and replace locale
        -:  537:     * dependent decimal point with '.' */
       48:  538:    for (i = 0; i < ((size_t)length); i++)
        -:  539:    {
       24:  540:        if (number_buffer[i] == decimal_point)
        -:  541:        {
    #####:  542:            output_pointer[i] = '.';
    #####:  543:            continue;
        -:  544:        }
        -:  545:
       24:  546:        output_pointer[i] = number_buffer[i];
        -:  547:    }
       24:  548:    output_pointer[i] = '\0';
        -:  549:
       24:  550:    output_buffer->offset += (size_t)length;
        -:  551:
       24:  552:    return true;
        -:  553:}
        -:  554:
        -:  555:/* parse 4 digit hexadecimal number */
        4:  556:static unsigned parse_hex4(const unsigned char * const input)
        -:  557:{
        4:  558:    unsigned int h = 0;
        4:  559:    size_t i = 0;
        -:  560:
       20:  561:    for (i = 0; i < 4; i++)
        -:  562:    {
        -:  563:        /* parse digit */
       16:  564:        if ((input[i] >= '0') && (input[i] <= '9'))
        -:  565:        {
        9:  566:            h += (unsigned int) input[i] - '0';
        -:  567:        }
        7:  568:        else if ((input[i] >= 'A') && (input[i] <= 'F'))
        -:  569:        {
        4:  570:            h += (unsigned int) 10 + input[i] - 'A';
        -:  571:        }
        3:  572:        else if ((input[i] >= 'a') && (input[i] <= 'f'))
        -:  573:        {
        3:  574:            h += (unsigned int) 10 + input[i] - 'a';
        -:  575:        }
        -:  576:        else /* invalid */
        -:  577:        {
    #####:  578:            return 0;
        -:  579:        }
        -:  580:
       16:  581:        if (i < 3)
        -:  582:        {
        -:  583:            /* shift left to make place for the next nibble */
       12:  584:            h = h << 4;
        -:  585:        }
        -:  586:    }
        -:  587:
        4:  588:    return h;
        -:  589:}
        -:  590:
        -:  591:/* converts a UTF-16 literal to UTF-8
        -:  592: * A literal can be one or two sequences of the form \uXXXX */
        3:  593:static unsigned char utf16_literal_to_utf8(const unsigned char * const input_pointer, const unsigned char * const input_end, unsigned char **output_pointer)
        -:  594:{
        3:  595:    long unsigned int codepoint = 0;
        3:  596:    unsigned int first_code = 0;
        3:  597:    const unsigned char *first_sequence = input_pointer;
        3:  598:    unsigned char utf8_length = 0;
        3:  599:    unsigned char utf8_position = 0;
        3:  600:    unsigned char sequence_length = 0;
        3:  601:    unsigned char first_byte_mark = 0;
        -:  602:
        3:  603:    if ((input_end - first_sequence) < 6)
        -:  604:    {
        -:  605:        /* input ends unexpectedly */
    #####:  606:        goto fail;
        -:  607:    }
        -:  608:
        -:  609:    /* get the first utf16 sequence */
        3:  610:    first_code = parse_hex4(first_sequence + 2);
        -:  611:
        -:  612:    /* check that the code is valid */
        3:  613:    if (((first_code >= 0xDC00) && (first_code <= 0xDFFF)))
        -:  614:    {
    #####:  615:        goto fail;
        -:  616:    }
        -:  617:
        -:  618:    /* UTF16 surrogate pair */
        3:  619:    if ((first_code >= 0xD800) && (first_code <= 0xDBFF))
        -:  620:    {
        1:  621:        const unsigned char *second_sequence = first_sequence + 6;
        1:  622:        unsigned int second_code = 0;
        1:  623:        sequence_length = 12; /* \uXXXX\uXXXX */
        -:  624:
        1:  625:        if ((input_end - second_sequence) < 6)
        -:  626:        {
        -:  627:            /* input ends unexpectedly */
    #####:  628:            goto fail;
        -:  629:        }
        -:  630:
        1:  631:        if ((second_sequence[0] != '\\') || (second_sequence[1] != 'u'))
        -:  632:        {
        -:  633:            /* missing second half of the surrogate pair */
        -:  634:            goto fail;
        -:  635:        }
        -:  636:
        -:  637:        /* get the second utf16 sequence */
        1:  638:        second_code = parse_hex4(second_sequence + 2);
        -:  639:        /* check that the code is valid */
        2:  640:        if ((second_code < 0xDC00) || (second_code > 0xDFFF))
        -:  641:        {
        -:  642:            /* invalid second half of the surrogate pair */
        -:  643:            goto fail;
        -:  644:        }
        -:  645:
        -:  646:
        -:  647:        /* calculate the unicode codepoint from the surrogate pair */
        1:  648:        codepoint = 0x10000 + (((first_code & 0x3FF) << 10) | (second_code & 0x3FF));
        -:  649:    }
        -:  650:    else
        -:  651:    {
        2:  652:        sequence_length = 6; /* \uXXXX */
        2:  653:        codepoint = first_code;
        -:  654:    }
        -:  655:
        -:  656:    /* encode as UTF-8
        -:  657:     * takes at maximum 4 bytes to encode:
        -:  658:     * 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx */
        3:  659:    if (codepoint < 0x80)
        -:  660:    {
        -:  661:        /* normal ascii, encoding 0xxxxxxx */
    #####:  662:        utf8_length = 1;
        -:  663:    }
        3:  664:    else if (codepoint < 0x800)
        -:  665:    {
        -:  666:        /* two bytes, encoding 110xxxxx 10xxxxxx */
    #####:  667:        utf8_length = 2;
    #####:  668:        first_byte_mark = 0xC0; /* 11000000 */
        -:  669:    }
        3:  670:    else if (codepoint < 0x10000)
        -:  671:    {
        -:  672:        /* three bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx */
        2:  673:        utf8_length = 3;
        2:  674:        first_byte_mark = 0xE0; /* 11100000 */
        -:  675:    }
        1:  676:    else if (codepoint <= 0x10FFFF)
        -:  677:    {
        -:  678:        /* four bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx 10xxxxxx */
        1:  679:        utf8_length = 4;
        1:  680:        first_byte_mark = 0xF0; /* 11110000 */
        -:  681:    }
        -:  682:    else
        -:  683:    {
        -:  684:        /* invalid unicode codepoint */
    #####:  685:        goto fail;
        -:  686:    }
        -:  687:
        -:  688:    /* encode as utf8 */
       10:  689:    for (utf8_position = (unsigned char)(utf8_length - 1); utf8_position > 0; utf8_position--)
        -:  690:    {
        -:  691:        /* 10xxxxxx */
        7:  692:        (*output_pointer)[utf8_position] = (unsigned char)((codepoint | 0x80) & 0xBF);
        7:  693:        codepoint >>= 6;
        -:  694:    }
        -:  695:    /* encode first byte */
        3:  696:    if (utf8_length > 1)
        -:  697:    {
        3:  698:        (*output_pointer)[0] = (unsigned char)((codepoint | first_byte_mark) & 0xFF);
        -:  699:    }
        -:  700:    else
        -:  701:    {
    #####:  702:        (*output_pointer)[0] = (unsigned char)(codepoint & 0x7F);
        -:  703:    }
        -:  704:
        3:  705:    *output_pointer += utf8_length;
        -:  706:
        3:  707:    return sequence_length;
        -:  708:
    #####:  709:fail:
    #####:  710:    return 0;
        -:  711:}
        -:  712:
        -:  713:/* Parse the input text into an unescaped cinput, and populate item. */
      173:  714:static cJSON_bool parse_string(cJSON * const item, parse_buffer * const input_buffer)
        -:  715:{
      173:  716:    const unsigned char *input_pointer = buffer_at_offset(input_buffer) + 1;
      173:  717:    const unsigned char *input_end = buffer_at_offset(input_buffer) + 1;
      173:  718:    unsigned char *output_pointer = NULL;
      173:  719:    unsigned char *output = NULL;
        -:  720:
        -:  721:    /* not a string */
      173:  722:    if (buffer_at_offset(input_buffer)[0] != '\"')
        -:  723:    {
    #####:  724:        goto fail;
        -:  725:    }
        -:  726:
        -:  727:    {
        -:  728:        /* calculate approximate size of the output (overestimate) */
      173:  729:        size_t allocation_length = 0;
      173:  730:        size_t skipped_bytes = 0;
     1781:  731:        while (((size_t)(input_end - input_buffer->content) < input_buffer->length) && (*input_end != '\"'))
        -:  732:        {
        -:  733:            /* is escape sequence */
      804:  734:            if (input_end[0] == '\\')
        -:  735:            {
       15:  736:                if ((size_t)(input_end + 1 - input_buffer->content) >= input_buffer->length)
        -:  737:                {
        -:  738:                    /* prevent buffer overflow when last input character is a backslash */
    #####:  739:                    goto fail;
        -:  740:                }
       15:  741:                skipped_bytes++;
       15:  742:                input_end++;
        -:  743:            }
      804:  744:            input_end++;
        -:  745:        }
      173:  746:        if (((size_t)(input_end - input_buffer->content) >= input_buffer->length) || (*input_end != '\"'))
        -:  747:        {
        -:  748:            goto fail; /* string ended unexpectedly */
        -:  749:        }
        -:  750:
        -:  751:        /* This is at most how much we need for the output */
      173:  752:        allocation_length = (size_t) (input_end - buffer_at_offset(input_buffer)) - skipped_bytes;
      173:  753:        output = (unsigned char*)input_buffer->hooks.allocate(allocation_length + sizeof(""));
      173:  754:        if (output == NULL)
        -:  755:        {
    #####:  756:            goto fail; /* allocation failure */
        -:  757:        }
        -:  758:    }
        -:  759:
      173:  760:    output_pointer = output;
        -:  761:    /* loop through the string literal */
     1747:  762:    while (input_pointer < input_end)
        -:  763:    {
      787:  764:        if (*input_pointer != '\\')
        -:  765:        {
      773:  766:            *output_pointer++ = *input_pointer++;
        -:  767:        }
        -:  768:        /* escape sequence */
        -:  769:        else
        -:  770:        {
       14:  771:            unsigned char sequence_length = 2;
       14:  772:            if ((input_end - input_pointer) < 1)
        -:  773:            {
    #####:  774:                goto fail;
        -:  775:            }
        -:  776:
       14:  777:            switch (input_pointer[1])
        -:  778:            {
        1:  779:                case 'b':
        1:  780:                    *output_pointer++ = '\b';
        1:  781:                    break;
        1:  782:                case 'f':
        1:  783:                    *output_pointer++ = '\f';
        1:  784:                    break;
        1:  785:                case 'n':
        1:  786:                    *output_pointer++ = '\n';
        1:  787:                    break;
        1:  788:                case 'r':
        1:  789:                    *output_pointer++ = '\r';
        1:  790:                    break;
        1:  791:                case 't':
        1:  792:                    *output_pointer++ = '\t';
        1:  793:                    break;
        6:  794:                case '\"':
        -:  795:                case '\\':
        -:  796:                case '/':
        6:  797:                    *output_pointer++ = input_pointer[1];
        6:  798:                    break;
        -:  799:
        -:  800:                /* UTF-16 literal */
        3:  801:                case 'u':
        3:  802:                    sequence_length = utf16_literal_to_utf8(input_pointer, input_end, &output_pointer);
        3:  803:                    if (sequence_length == 0)
        -:  804:                    {
        -:  805:                        /* failed to convert UTF16-literal to UTF-8 */
    #####:  806:                        goto fail;
        -:  807:                    }
        3:  808:                    break;
        -:  809:
    #####:  810:                default:
    #####:  811:                    goto fail;
        -:  812:            }
       14:  813:            input_pointer += sequence_length;
        -:  814:        }
        -:  815:    }
        -:  816:
        -:  817:    /* zero terminate the output */
      173:  818:    *output_pointer = '\0';
        -:  819:
      173:  820:    item->type = cJSON_String;
      173:  821:    item->valuestring = (char*)output;
        -:  822:
      173:  823:    input_buffer->offset = (size_t) (input_end - input_buffer->content);
      173:  824:    input_buffer->offset++;
        -:  825:
      173:  826:    return true;
        -:  827:
    #####:  828:fail:
    #####:  829:    if (output != NULL)
        -:  830:    {
    #####:  831:        input_buffer->hooks.deallocate(output);
        -:  832:    }
        -:  833:
    #####:  834:    if (input_pointer != NULL)
        -:  835:    {
    #####:  836:        input_buffer->offset = (size_t)(input_pointer - input_buffer->content);
        -:  837:    }
        -:  838:
    #####:  839:    return false;
        -:  840:}
        -:  841:
        -:  842:/* Render the cstring provided to an escaped version that can be printed. */
       97:  843:static cJSON_bool print_string_ptr(const unsigned char * const input, printbuffer * const output_buffer)
        -:  844:{
       97:  845:    const unsigned char *input_pointer = NULL;
       97:  846:    unsigned char *output = NULL;
       97:  847:    unsigned char *output_pointer = NULL;
       97:  848:    size_t output_length = 0;
        -:  849:    /* numbers of additional characters needed for escaping */
       97:  850:    size_t escape_characters = 0;
        -:  851:
       97:  852:    if (output_buffer == NULL)
        -:  853:    {
    #####:  854:        return false;
        -:  855:    }
        -:  856:
        -:  857:    /* empty string */
       97:  858:    if (input == NULL)
        -:  859:    {
        1:  860:        output = ensure(output_buffer, sizeof("\"\""));
        1:  861:        if (output == NULL)
        -:  862:        {
    #####:  863:            return false;
        -:  864:        }
        1:  865:        strcpy((char*)output, "\"\"");
        -:  866:
        1:  867:        return true;
        -:  868:    }
        -:  869:
        -:  870:    /* set "flag" to 1 if something needs to be escaped */
      475:  871:    for (input_pointer = input; *input_pointer; input_pointer++)
        -:  872:    {
      379:  873:        switch (*input_pointer)
        -:  874:        {
        7:  875:            case '\"':
        -:  876:            case '\\':
        -:  877:            case '\b':
        -:  878:            case '\f':
        -:  879:            case '\n':
        -:  880:            case '\r':
        -:  881:            case '\t':
        -:  882:                /* one character escape sequence */
        7:  883:                escape_characters++;
        7:  884:                break;
      372:  885:            default:
      372:  886:                if (*input_pointer < 32)
        -:  887:                {
        -:  888:                    /* UTF-16 escape sequence uXXXX */
       26:  889:                    escape_characters += 5;
        -:  890:                }
      372:  891:                break;
        -:  892:        }
        -:  893:    }
       96:  894:    output_length = (size_t)(input_pointer - input) + escape_characters;
        -:  895:
       96:  896:    output = ensure(output_buffer, output_length + sizeof("\"\""));
       96:  897:    if (output == NULL)
        -:  898:    {
    #####:  899:        return false;
        -:  900:    }
        -:  901:
        -:  902:    /* no characters have to be escaped */
       96:  903:    if (escape_characters == 0)
        -:  904:    {
       95:  905:        output[0] = '\"';
       95:  906:        memcpy(output + 1, input, output_length);
       95:  907:        output[output_length + 1] = '\"';
       95:  908:        output[output_length + 2] = '\0';
        -:  909:
       95:  910:        return true;
        -:  911:    }
        -:  912:
        1:  913:    output[0] = '\"';
        1:  914:    output_pointer = output + 1;
        -:  915:    /* copy the string */
      127:  916:    for (input_pointer = input; *input_pointer != '\0'; (void)input_pointer++, output_pointer++)
        -:  917:    {
      126:  918:        if ((*input_pointer > 31) && (*input_pointer != '\"') && (*input_pointer != '\\'))
        -:  919:        {
        -:  920:            /* normal character, copy */
       93:  921:            *output_pointer = *input_pointer;
        -:  922:        }
        -:  923:        else
        -:  924:        {
        -:  925:            /* character needs to be escaped */
       33:  926:            *output_pointer++ = '\\';
       33:  927:            switch (*input_pointer)
        -:  928:            {
        1:  929:                case '\\':
        1:  930:                    *output_pointer = '\\';
        1:  931:                    break;
        1:  932:                case '\"':
        1:  933:                    *output_pointer = '\"';
        1:  934:                    break;
        1:  935:                case '\b':
        1:  936:                    *output_pointer = 'b';
        1:  937:                    break;
        1:  938:                case '\f':
        1:  939:                    *output_pointer = 'f';
        1:  940:                    break;
        1:  941:                case '\n':
        1:  942:                    *output_pointer = 'n';
        1:  943:                    break;
        1:  944:                case '\r':
        1:  945:                    *output_pointer = 'r';
        1:  946:                    break;
        1:  947:                case '\t':
        1:  948:                    *output_pointer = 't';
        1:  949:                    break;
       26:  950:                default:
        -:  951:                    /* escape and print as unicode codepoint */
       26:  952:                    sprintf((char*)output_pointer, "u%04x", *input_pointer);
       26:  953:                    output_pointer += 4;
       26:  954:                    break;
        -:  955:            }
        -:  956:        }
        -:  957:    }
        1:  958:    output[output_length + 1] = '\"';
        1:  959:    output[output_length + 2] = '\0';
        -:  960:
        1:  961:    return true;
        -:  962:}
        -:  963:
        -:  964:/* Invoke print_string_ptr (which is useful) on an item. */
       34:  965:static cJSON_bool print_string(const cJSON * const item, printbuffer * const p)
        -:  966:{
       34:  967:    return print_string_ptr((unsigned char*)item->valuestring, p);
        -:  968:}
        -:  969:
        -:  970:/* Predeclare these prototypes. */
        -:  971:static cJSON_bool parse_value(cJSON * const item, parse_buffer * const input_buffer);
        -:  972:static cJSON_bool print_value(const cJSON * const item, printbuffer * const output_buffer);
        -:  973:static cJSON_bool parse_array(cJSON * const item, parse_buffer * const input_buffer);
        -:  974:static cJSON_bool print_array(const cJSON * const item, printbuffer * const output_buffer);
        -:  975:static cJSON_bool parse_object(cJSON * const item, parse_buffer * const input_buffer);
        -:  976:static cJSON_bool print_object(const cJSON * const item, printbuffer * const output_buffer);
        -:  977:
        -:  978:/* Utility to jump whitespace and cr/lf */
      914:  979:static parse_buffer *buffer_skip_whitespace(parse_buffer * const buffer)
        -:  980:{
      914:  981:    if ((buffer == NULL) || (buffer->content == NULL))
        -:  982:    {
    #####:  983:        return NULL;
        -:  984:    }
        -:  985:
     1224:  986:    while (can_access_at_index(buffer, 0) && (buffer_at_offset(buffer)[0] <= 32))
        -:  987:    {
      155:  988:       buffer->offset++;
        -:  989:    }
        -:  990:
      914:  991:    if (buffer->offset == buffer->length)
        -:  992:    {
        3:  993:        buffer->offset--;
        -:  994:    }
        -:  995:
      914:  996:    return buffer;
        -:  997:}
        -:  998:
        -:  999:/* skip the UTF-8 BOM (byte order mark) if it is at the beginning of a buffer */
      118: 1000:static parse_buffer *skip_utf8_bom(parse_buffer * const buffer)
        -: 1001:{
      118: 1002:    if ((buffer == NULL) || (buffer->content == NULL) || (buffer->offset != 0))
        -: 1003:    {
    #####: 1004:        return NULL;
        -: 1005:    }
        -: 1006:
      118: 1007:    if (can_access_at_index(buffer, 4) && (strncmp((const char*)buffer_at_offset(buffer), "\xEF\xBB\xBF", 3) == 0))
        -: 1008:    {
    #####: 1009:        buffer->offset += 3;
        -: 1010:    }
        -: 1011:
      118: 1012:    return buffer;
        -: 1013:}
        -: 1014:
        -: 1015:/* Parse an object - create a new root, and populate. */
      119: 1016:CJSON_PUBLIC(cJSON *) cJSON_ParseWithOpts(const char *value, const char **return_parse_end, cJSON_bool require_null_terminated)
        -: 1017:{
      119: 1018:    parse_buffer buffer = { 0, 0, 0, 0, { 0, 0, 0 } };
      119: 1019:    cJSON *item = NULL;
        -: 1020:
        -: 1021:    /* reset error position */
      119: 1022:    global_error.json = NULL;
      119: 1023:    global_error.position = 0;
        -: 1024:
      119: 1025:    if (value == NULL)
        -: 1026:    {
        1: 1027:        goto fail;
        -: 1028:    }
        -: 1029:
      118: 1030:    buffer.content = (const unsigned char*)value;
      118: 1031:    buffer.length = strlen((const char*)value) + sizeof("");
      118: 1032:    buffer.offset = 0;
      118: 1033:    buffer.hooks = global_hooks;
        -: 1034:
      118: 1035:    item = cJSON_New_Item(&(buffer.hooks));
      118: 1036:    if (item == NULL) /* memory fail */
        -: 1037:    {
    #####: 1038:        goto fail;
        -: 1039:    }
        -: 1040:
      118: 1041:    if (!parse_value(item, buffer_skip_whitespace(skip_utf8_bom(&buffer))))
        -: 1042:    {
        -: 1043:        /* parse failure. ep is set. */
        1: 1044:        goto fail;
        -: 1045:    }
        -: 1046:
        -: 1047:    /* if we require null-terminated JSON without appended garbage, skip and then check for a null terminator */
      117: 1048:    if (require_null_terminated)
        -: 1049:    {
        2: 1050:        buffer_skip_whitespace(&buffer);
        2: 1051:        if ((buffer.offset >= buffer.length) || buffer_at_offset(&buffer)[0] != '\0')
        -: 1052:        {
        -: 1053:            goto fail;
        -: 1054:        }
        -: 1055:    }
      117: 1056:    if (return_parse_end)
        -: 1057:    {
    #####: 1058:        *return_parse_end = (const char*)buffer_at_offset(&buffer);
        -: 1059:    }
        -: 1060:
      117: 1061:    return item;
        -: 1062:
    #####: 1063:fail:
        2: 1064:    if (item != NULL)
        -: 1065:    {
        1: 1066:        cJSON_Delete(item);
        -: 1067:    }
        -: 1068:
        2: 1069:    if (value != NULL)
        -: 1070:    {
        -: 1071:        error local_error;
        1: 1072:        local_error.json = (const unsigned char*)value;
        1: 1073:        local_error.position = 0;
        -: 1074:
        1: 1075:        if (buffer.offset < buffer.length)
        -: 1076:        {
        1: 1077:            local_error.position = buffer.offset;
        -: 1078:        }
    #####: 1079:        else if (buffer.length > 0)
        -: 1080:        {
    #####: 1081:            local_error.position = buffer.length - 1;
        -: 1082:        }
        -: 1083:
        1: 1084:        if (return_parse_end != NULL)
        -: 1085:        {
        1: 1086:            *return_parse_end = (const char*)local_error.json + local_error.position;
        -: 1087:        }
        -: 1088:
        1: 1089:        global_error = local_error;
        -: 1090:    }
        -: 1091:
        2: 1092:    return NULL;
        -: 1093:}
        -: 1094:
        -: 1095:/* Default options for cJSON_Parse */
      115: 1096:CJSON_PUBLIC(cJSON *) cJSON_Parse(const char *value)
        -: 1097:{
      115: 1098:    return cJSON_ParseWithOpts(value, 0, 0);
        -: 1099:}
        -: 1100:
        -: 1101:#define cjson_min(a, b) ((a < b) ? a : b)
        -: 1102:
       33: 1103:static unsigned char *print(const cJSON * const item, cJSON_bool format, const internal_hooks * const hooks)
        -: 1104:{
        -: 1105:    static const size_t default_buffer_size = 256;
        -: 1106:    printbuffer buffer[1];
       33: 1107:    unsigned char *printed = NULL;
        -: 1108:
       33: 1109:    memset(buffer, 0, sizeof(buffer));
        -: 1110:
        -: 1111:    /* create buffer */
       33: 1112:    buffer->buffer = (unsigned char*) hooks->allocate(default_buffer_size);
       33: 1113:    buffer->length = default_buffer_size;
       33: 1114:    buffer->format = format;
       33: 1115:    buffer->hooks = *hooks;
       33: 1116:    if (buffer->buffer == NULL)
        -: 1117:    {
    #####: 1118:        goto fail;
        -: 1119:    }
        -: 1120:
        -: 1121:    /* print the value */
       33: 1122:    if (!print_value(item, buffer))
        -: 1123:    {
        1: 1124:        goto fail;
        -: 1125:    }
       32: 1126:    update_offset(buffer);
        -: 1127:
        -: 1128:    /* check if reallocate is available */
       32: 1129:    if (hooks->reallocate != NULL)
        -: 1130:    {
       32: 1131:        printed = (unsigned char*) hooks->reallocate(buffer->buffer, buffer->offset + 1);
       32: 1132:        if (printed == NULL) {
    #####: 1133:            goto fail;
        -: 1134:        }
       32: 1135:        buffer->buffer = NULL;
        -: 1136:    }
        -: 1137:    else /* otherwise copy the JSON over to a new buffer */
        -: 1138:    {
    #####: 1139:        printed = (unsigned char*) hooks->allocate(buffer->offset + 1);
    #####: 1140:        if (printed == NULL)
        -: 1141:        {
    #####: 1142:            goto fail;
        -: 1143:        }
    #####: 1144:        memcpy(printed, buffer->buffer, cjson_min(buffer->length, buffer->offset + 1));
    #####: 1145:        printed[buffer->offset] = '\0'; /* just to be sure */
        -: 1146:
        -: 1147:        /* free the buffer */
    #####: 1148:        hooks->deallocate(buffer->buffer);
        -: 1149:    }
        -: 1150:
       32: 1151:    return printed;
        -: 1152:
        1: 1153:fail:
        1: 1154:    if (buffer->buffer != NULL)
        -: 1155:    {
        1: 1156:        hooks->deallocate(buffer->buffer);
        -: 1157:    }
        -: 1158:
        1: 1159:    if (printed != NULL)
        -: 1160:    {
    #####: 1161:        hooks->deallocate(printed);
        -: 1162:    }
        -: 1163:
        1: 1164:    return NULL;
        -: 1165:}
        -: 1166:
        -: 1167:/* Render a cJSON item/entity/structure to text. */
        3: 1168:CJSON_PUBLIC(char *) cJSON_Print(const cJSON *item)
        -: 1169:{
        3: 1170:    return (char*)print(item, true, &global_hooks);
        -: 1171:}
        -: 1172:
       30: 1173:CJSON_PUBLIC(char *) cJSON_PrintUnformatted(const cJSON *item)
        -: 1174:{
       30: 1175:    return (char*)print(item, false, &global_hooks);
        -: 1176:}
        -: 1177:
        1: 1178:CJSON_PUBLIC(char *) cJSON_PrintBuffered(const cJSON *item, int prebuffer, cJSON_bool fmt)
        -: 1179:{
        1: 1180:    printbuffer p = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };
        -: 1181:
        1: 1182:    if (prebuffer < 0)
        -: 1183:    {
    #####: 1184:        return NULL;
        -: 1185:    }
        -: 1186:
        1: 1187:    p.buffer = (unsigned char*)global_hooks.allocate((size_t)prebuffer);
        1: 1188:    if (!p.buffer)
        -: 1189:    {
    #####: 1190:        return NULL;
        -: 1191:    }
        -: 1192:
        1: 1193:    p.length = (size_t)prebuffer;
        1: 1194:    p.offset = 0;
        1: 1195:    p.noalloc = false;
        1: 1196:    p.format = fmt;
        1: 1197:    p.hooks = global_hooks;
        -: 1198:
        1: 1199:    if (!print_value(item, &p))
        -: 1200:    {
        1: 1201:        global_hooks.deallocate(p.buffer);
        1: 1202:        return NULL;
        -: 1203:    }
        -: 1204:
    #####: 1205:    return (char*)p.buffer;
        -: 1206:}
        -: 1207:
        2: 1208:CJSON_PUBLIC(cJSON_bool) cJSON_PrintPreallocated(cJSON *item, char *buffer, const int length, const cJSON_bool format)
        -: 1209:{
        2: 1210:    printbuffer p = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };
        -: 1211:
        2: 1212:    if ((length < 0) || (buffer == NULL))
        -: 1213:    {
        1: 1214:        return false;
        -: 1215:    }
        -: 1216:
        1: 1217:    p.buffer = (unsigned char*)buffer;
        1: 1218:    p.length = (size_t)length;
        1: 1219:    p.offset = 0;
        1: 1220:    p.noalloc = true;
        1: 1221:    p.format = format;
        1: 1222:    p.hooks = global_hooks;
        -: 1223:
        1: 1224:    return print_value(item, &p);
        -: 1225:}
        -: 1226:
        -: 1227:/* Parser core - when encountering text, process appropriately. */
      335: 1228:static cJSON_bool parse_value(cJSON * const item, parse_buffer * const input_buffer)
        -: 1229:{
      335: 1230:    if ((input_buffer == NULL) || (input_buffer->content == NULL))
        -: 1231:    {
    #####: 1232:        return false; /* no input */
        -: 1233:    }
        -: 1234:
        -: 1235:    /* parse the different types of values */
        -: 1236:    /* null */
      335: 1237:    if (can_read(input_buffer, 4) && (strncmp((const char*)buffer_at_offset(input_buffer), "null", 4) == 0))
        -: 1238:    {
       33: 1239:        item->type = cJSON_NULL;
       33: 1240:        input_buffer->offset += 4;
       33: 1241:        return true;
        -: 1242:    }
        -: 1243:    /* false */
      302: 1244:    if (can_read(input_buffer, 5) && (strncmp((const char*)buffer_at_offset(input_buffer), "false", 5) == 0))
        -: 1245:    {
       24: 1246:        item->type = cJSON_False;
       24: 1247:        input_buffer->offset += 5;
       24: 1248:        return true;
        -: 1249:    }
        -: 1250:    /* true */
      278: 1251:    if (can_read(input_buffer, 4) && (strncmp((const char*)buffer_at_offset(input_buffer), "true", 4) == 0))
        -: 1252:    {
       28: 1253:        item->type = cJSON_True;
       28: 1254:        item->valueint = 1;
       28: 1255:        input_buffer->offset += 4;
       28: 1256:        return true;
        -: 1257:    }
        -: 1258:    /* string */
      250: 1259:    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '\"'))
        -: 1260:    {
       56: 1261:        return parse_string(item, input_buffer);
        -: 1262:    }
        -: 1263:    /* number */
      194: 1264:    if (can_access_at_index(input_buffer, 0) && ((buffer_at_offset(input_buffer)[0] == '-') || ((buffer_at_offset(input_buffer)[0] >= '0') && (buffer_at_offset(input_buffer)[0] <= '9'))))
        -: 1265:    {
       72: 1266:        return parse_number(item, input_buffer);
        -: 1267:    }
        -: 1268:    /* array */
      122: 1269:    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '['))
        -: 1270:    {
       56: 1271:        return parse_array(item, input_buffer);
        -: 1272:    }
        -: 1273:    /* object */
       66: 1274:    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '{'))
        -: 1275:    {
       65: 1276:        return parse_object(item, input_buffer);
        -: 1277:    }
        -: 1278:
        1: 1279:    return false;
        -: 1280:}
        -: 1281:
        -: 1282:/* Render a value to text. */
      133: 1283:static cJSON_bool print_value(const cJSON * const item, printbuffer * const output_buffer)
        -: 1284:{
      133: 1285:    unsigned char *output = NULL;
        -: 1286:
      133: 1287:    if ((item == NULL) || (output_buffer == NULL))
        -: 1288:    {
        3: 1289:        return false;
        -: 1290:    }
        -: 1291:
      130: 1292:    switch ((item->type) & 0xFF)
        -: 1293:    {
       15: 1294:        case cJSON_NULL:
       15: 1295:            output = ensure(output_buffer, 5);
       15: 1296:            if (output == NULL)
        -: 1297:            {
    #####: 1298:                return false;
        -: 1299:            }
       15: 1300:            strcpy((char*)output, "null");
       15: 1301:            return true;
        -: 1302:
        4: 1303:        case cJSON_False:
        4: 1304:            output = ensure(output_buffer, 6);
        4: 1305:            if (output == NULL)
        -: 1306:            {
    #####: 1307:                return false;
        -: 1308:            }
        4: 1309:            strcpy((char*)output, "false");
        4: 1310:            return true;
        -: 1311:
        4: 1312:        case cJSON_True:
        4: 1313:            output = ensure(output_buffer, 5);
        4: 1314:            if (output == NULL)
        -: 1315:            {
    #####: 1316:                return false;
        -: 1317:            }
        4: 1318:            strcpy((char*)output, "true");
        4: 1319:            return true;
        -: 1320:
       24: 1321:        case cJSON_Number:
       24: 1322:            return print_number(item, output_buffer);
        -: 1323:
    #####: 1324:        case cJSON_Raw:
        -: 1325:        {
    #####: 1326:            size_t raw_length = 0;
    #####: 1327:            if (item->valuestring == NULL)
        -: 1328:            {
    #####: 1329:                return false;
        -: 1330:            }
        -: 1331:
    #####: 1332:            raw_length = strlen(item->valuestring) + sizeof("");
    #####: 1333:            output = ensure(output_buffer, raw_length);
    #####: 1334:            if (output == NULL)
        -: 1335:            {
    #####: 1336:                return false;
        -: 1337:            }
    #####: 1338:            memcpy(output, item->valuestring, raw_length);
    #####: 1339:            return true;
        -: 1340:        }
        -: 1341:
       34: 1342:        case cJSON_String:
       34: 1343:            return print_string(item, output_buffer);
        -: 1344:
       16: 1345:        case cJSON_Array:
       16: 1346:            return print_array(item, output_buffer);
        -: 1347:
       33: 1348:        case cJSON_Object:
       33: 1349:            return print_object(item, output_buffer);
        -: 1350:
    #####: 1351:        default:
    #####: 1352:            return false;
        -: 1353:    }
        -: 1354:}
        -: 1355:
        -: 1356:/* Build an array from input text. */
       63: 1357:static cJSON_bool parse_array(cJSON * const item, parse_buffer * const input_buffer)
        -: 1358:{
       63: 1359:    cJSON *head = NULL; /* head of the linked list */
       63: 1360:    cJSON *current_item = NULL;
        -: 1361:
       63: 1362:    if (input_buffer->depth >= CJSON_NESTING_LIMIT)
        -: 1363:    {
    #####: 1364:        return false; /* to deeply nested */
        -: 1365:    }
       63: 1366:    input_buffer->depth++;
        -: 1367:
       63: 1368:    if (buffer_at_offset(input_buffer)[0] != '[')
        -: 1369:    {
        -: 1370:        /* not an array */
    #####: 1371:        goto fail;
        -: 1372:    }
        -: 1373:
       63: 1374:    input_buffer->offset++;
       63: 1375:    buffer_skip_whitespace(input_buffer);
       63: 1376:    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ']'))
        -: 1377:    {
        -: 1378:        /* empty array */
       25: 1379:        goto success;
        -: 1380:    }
        -: 1381:
        -: 1382:    /* check if we skipped to the end of the buffer */
       38: 1383:    if (cannot_access_at_index(input_buffer, 0))
        -: 1384:    {
    #####: 1385:        input_buffer->offset--;
    #####: 1386:        goto fail;
        -: 1387:    }
        -: 1388:
        -: 1389:    /* step back to character in front of the first element */
       38: 1390:    input_buffer->offset--;
        -: 1391:    /* loop through the comma separated array elements */
       67: 1392:    do
        -: 1393:    {
        -: 1394:        /* allocate next item */
      105: 1395:        cJSON *new_item = cJSON_New_Item(&(input_buffer->hooks));
      105: 1396:        if (new_item == NULL)
        -: 1397:        {
    #####: 1398:            goto fail; /* allocation failure */
        -: 1399:        }
        -: 1400:
        -: 1401:        /* attach next item to list */
      105: 1402:        if (head == NULL)
        -: 1403:        {
        -: 1404:            /* start the linked list */
       38: 1405:            current_item = head = new_item;
        -: 1406:        }
        -: 1407:        else
        -: 1408:        {
        -: 1409:            /* add to the end and advance */
       67: 1410:            current_item->next = new_item;
       67: 1411:            new_item->prev = current_item;
       67: 1412:            current_item = new_item;
        -: 1413:        }
        -: 1414:
        -: 1415:        /* parse next value */
      105: 1416:        input_buffer->offset++;
      105: 1417:        buffer_skip_whitespace(input_buffer);
      105: 1418:        if (!parse_value(current_item, input_buffer))
        -: 1419:        {
    #####: 1420:            goto fail; /* failed to parse value */
        -: 1421:        }
      105: 1422:        buffer_skip_whitespace(input_buffer);
        -: 1423:    }
      105: 1424:    while (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ','));
        -: 1425:
       76: 1426:    if (cannot_access_at_index(input_buffer, 0) || buffer_at_offset(input_buffer)[0] != ']')
        -: 1427:    {
        -: 1428:        goto fail; /* expected end of array */
        -: 1429:    }
        -: 1430:
       38: 1431:success:
       63: 1432:    input_buffer->depth--;
        -: 1433:
       63: 1434:    item->type = cJSON_Array;
       63: 1435:    item->child = head;
        -: 1436:
       63: 1437:    input_buffer->offset++;
        -: 1438:
       63: 1439:    return true;
        -: 1440:
    #####: 1441:fail:
    #####: 1442:    if (head != NULL)
        -: 1443:    {
    #####: 1444:        cJSON_Delete(head);
        -: 1445:    }
        -: 1446:
    #####: 1447:    return false;
        -: 1448:}
        -: 1449:
        -: 1450:/* Render an array to text */
       30: 1451:static cJSON_bool print_array(const cJSON * const item, printbuffer * const output_buffer)
        -: 1452:{
       30: 1453:    unsigned char *output_pointer = NULL;
       30: 1454:    size_t length = 0;
       30: 1455:    cJSON *current_element = item->child;
        -: 1456:
       30: 1457:    if (output_buffer == NULL)
        -: 1458:    {
    #####: 1459:        return false;
        -: 1460:    }
        -: 1461:
        -: 1462:    /* Compose the output array. */
        -: 1463:    /* opening square bracket */
       30: 1464:    output_pointer = ensure(output_buffer, 1);
       30: 1465:    if (output_pointer == NULL)
        -: 1466:    {
    #####: 1467:        return false;
        -: 1468:    }
        -: 1469:
       30: 1470:    *output_pointer = '[';
       30: 1471:    output_buffer->offset++;
       30: 1472:    output_buffer->depth++;
        -: 1473:
      108: 1474:    while (current_element != NULL)
        -: 1475:    {
       39: 1476:        if (!print_value(current_element, output_buffer))
        -: 1477:        {
    #####: 1478:            return false;
        -: 1479:        }
       39: 1480:        update_offset(output_buffer);
       39: 1481:        if (current_element->next)
        -: 1482:        {
       19: 1483:            length = (size_t) (output_buffer->format ? 2 : 1);
       19: 1484:            output_pointer = ensure(output_buffer, length + 1);
       19: 1485:            if (output_pointer == NULL)
        -: 1486:            {
    #####: 1487:                return false;
        -: 1488:            }
       19: 1489:            *output_pointer++ = ',';
       19: 1490:            if(output_buffer->format)
        -: 1491:            {
        8: 1492:                *output_pointer++ = ' ';
        -: 1493:            }
       19: 1494:            *output_pointer = '\0';
       19: 1495:            output_buffer->offset += length;
        -: 1496:        }
       39: 1497:        current_element = current_element->next;
        -: 1498:    }
        -: 1499:
       30: 1500:    output_pointer = ensure(output_buffer, 2);
       30: 1501:    if (output_pointer == NULL)
        -: 1502:    {
    #####: 1503:        return false;
        -: 1504:    }
       30: 1505:    *output_pointer++ = ']';
       30: 1506:    *output_pointer = '\0';
       30: 1507:    output_buffer->depth--;
        -: 1508:
       30: 1509:    return true;
        -: 1510:}
        -: 1511:
        -: 1512:/* Build an object from the text. */
       74: 1513:static cJSON_bool parse_object(cJSON * const item, parse_buffer * const input_buffer)
        -: 1514:{
       74: 1515:    cJSON *head = NULL; /* linked list head */
       74: 1516:    cJSON *current_item = NULL;
        -: 1517:
       74: 1518:    if (input_buffer->depth >= CJSON_NESTING_LIMIT)
        -: 1519:    {
    #####: 1520:        return false; /* to deeply nested */
        -: 1521:    }
       74: 1522:    input_buffer->depth++;
        -: 1523:
      148: 1524:    if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != '{'))
        -: 1525:    {
        -: 1526:        goto fail; /* not an object */
        -: 1527:    }
        -: 1528:
       74: 1529:    input_buffer->offset++;
       74: 1530:    buffer_skip_whitespace(input_buffer);
       74: 1531:    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '}'))
        -: 1532:    {
       27: 1533:        goto success; /* empty object */
        -: 1534:    }
        -: 1535:
        -: 1536:    /* check if we skipped to the end of the buffer */
       47: 1537:    if (cannot_access_at_index(input_buffer, 0))
        -: 1538:    {
    #####: 1539:        input_buffer->offset--;
    #####: 1540:        goto fail;
        -: 1541:    }
        -: 1542:
        -: 1543:    /* step back to character in front of the first element */
       47: 1544:    input_buffer->offset--;
        -: 1545:    /* loop through the comma separated array elements */
       65: 1546:    do
        -: 1547:    {
        -: 1548:        /* allocate next item */
      112: 1549:        cJSON *new_item = cJSON_New_Item(&(input_buffer->hooks));
      112: 1550:        if (new_item == NULL)
        -: 1551:        {
    #####: 1552:            goto fail; /* allocation failure */
        -: 1553:        }
        -: 1554:
        -: 1555:        /* attach next item to list */
      112: 1556:        if (head == NULL)
        -: 1557:        {
        -: 1558:            /* start the linked list */
       47: 1559:            current_item = head = new_item;
        -: 1560:        }
        -: 1561:        else
        -: 1562:        {
        -: 1563:            /* add to the end and advance */
       65: 1564:            current_item->next = new_item;
       65: 1565:            new_item->prev = current_item;
       65: 1566:            current_item = new_item;
        -: 1567:        }
        -: 1568:
        -: 1569:        /* parse the name of the child */
      112: 1570:        input_buffer->offset++;
      112: 1571:        buffer_skip_whitespace(input_buffer);
      112: 1572:        if (!parse_string(current_item, input_buffer))
        -: 1573:        {
    #####: 1574:            goto fail; /* failed to parse name */
        -: 1575:        }
      112: 1576:        buffer_skip_whitespace(input_buffer);
        -: 1577:
        -: 1578:        /* swap valuestring and string, because we parsed the name */
      112: 1579:        current_item->string = current_item->valuestring;
      112: 1580:        current_item->valuestring = NULL;
        -: 1581:
      336: 1582:        if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != ':'))
        -: 1583:        {
        -: 1584:            goto fail; /* invalid object */
        -: 1585:        }
        -: 1586:
        -: 1587:        /* parse the value */
      112: 1588:        input_buffer->offset++;
      112: 1589:        buffer_skip_whitespace(input_buffer);
      112: 1590:        if (!parse_value(current_item, input_buffer))
        -: 1591:        {
        1: 1592:            goto fail; /* failed to parse value */
        -: 1593:        }
      111: 1594:        buffer_skip_whitespace(input_buffer);
        -: 1595:    }
      111: 1596:    while (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ','));
        -: 1597:
      138: 1598:    if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != '}'))
        -: 1599:    {
        -: 1600:        goto fail; /* expected end of object */
        -: 1601:    }
        -: 1602:
       46: 1603:success:
       73: 1604:    input_buffer->depth--;
        -: 1605:
       73: 1606:    item->type = cJSON_Object;
       73: 1607:    item->child = head;
        -: 1608:
       73: 1609:    input_buffer->offset++;
       73: 1610:    return true;
        -: 1611:
    #####: 1612:fail:
        1: 1613:    if (head != NULL)
        -: 1614:    {
        1: 1615:        cJSON_Delete(head);
        -: 1616:    }
        -: 1617:
        1: 1618:    return false;
        -: 1619:}
        -: 1620:
        -: 1621:/* Render an object to text. */
       47: 1622:static cJSON_bool print_object(const cJSON * const item, printbuffer * const output_buffer)
        -: 1623:{
       47: 1624:    unsigned char *output_pointer = NULL;
       47: 1625:    size_t length = 0;
       47: 1626:    cJSON *current_item = item->child;
        -: 1627:
       47: 1628:    if (output_buffer == NULL)
        -: 1629:    {
    #####: 1630:        return false;
        -: 1631:    }
        -: 1632:
        -: 1633:    /* Compose the output: */
       47: 1634:    length = (size_t) (output_buffer->format ? 2 : 1); /* fmt: {\n */
       47: 1635:    output_pointer = ensure(output_buffer, length + 1);
       47: 1636:    if (output_pointer == NULL)
        -: 1637:    {
    #####: 1638:        return false;
        -: 1639:    }
        -: 1640:
       47: 1641:    *output_pointer++ = '{';
       47: 1642:    output_buffer->depth++;
       47: 1643:    if (output_buffer->format)
        -: 1644:    {
        9: 1645:        *output_pointer++ = '\n';
        -: 1646:    }
       47: 1647:    output_buffer->offset += length;
        -: 1648:
      165: 1649:    while (current_item)
        -: 1650:    {
       59: 1651:        if (output_buffer->format)
        -: 1652:        {
        -: 1653:            size_t i;
       14: 1654:            output_pointer = ensure(output_buffer, output_buffer->depth);
       14: 1655:            if (output_pointer == NULL)
        -: 1656:            {
    #####: 1657:                return false;
        -: 1658:            }
       28: 1659:            for (i = 0; i < output_buffer->depth; i++)
        -: 1660:            {
       14: 1661:                *output_pointer++ = '\t';
        -: 1662:            }
       14: 1663:            output_buffer->offset += output_buffer->depth;
        -: 1664:        }
        -: 1665:
        -: 1666:        /* print key */
       59: 1667:        if (!print_string_ptr((unsigned char*)current_item->string, output_buffer))
        -: 1668:        {
    #####: 1669:            return false;
        -: 1670:        }
       59: 1671:        update_offset(output_buffer);
        -: 1672:
       59: 1673:        length = (size_t) (output_buffer->format ? 2 : 1);
       59: 1674:        output_pointer = ensure(output_buffer, length);
       59: 1675:        if (output_pointer == NULL)
        -: 1676:        {
    #####: 1677:            return false;
        -: 1678:        }
       59: 1679:        *output_pointer++ = ':';
       59: 1680:        if (output_buffer->format)
        -: 1681:        {
       14: 1682:            *output_pointer++ = '\t';
        -: 1683:        }
       59: 1684:        output_buffer->offset += length;
        -: 1685:
        -: 1686:        /* print value */
       59: 1687:        if (!print_value(current_item, output_buffer))
        -: 1688:        {
    #####: 1689:            return false;
        -: 1690:        }
       59: 1691:        update_offset(output_buffer);
        -: 1692:
        -: 1693:        /* print comma if not last */
       59: 1694:        length = ((size_t)(output_buffer->format ? 1 : 0) + (size_t)(current_item->next ? 1 : 0));
       59: 1695:        output_pointer = ensure(output_buffer, length + 1);
       59: 1696:        if (output_pointer == NULL)
        -: 1697:        {
    #####: 1698:            return false;
        -: 1699:        }
       59: 1700:        if (current_item->next)
        -: 1701:        {
       19: 1702:            *output_pointer++ = ',';
        -: 1703:        }
        -: 1704:
       59: 1705:        if (output_buffer->format)
        -: 1706:        {
       14: 1707:            *output_pointer++ = '\n';
        -: 1708:        }
       59: 1709:        *output_pointer = '\0';
       59: 1710:        output_buffer->offset += length;
        -: 1711:
       59: 1712:        current_item = current_item->next;
        -: 1713:    }
        -: 1714:
       47: 1715:    output_pointer = ensure(output_buffer, output_buffer->format ? (output_buffer->depth + 1) : 2);
       47: 1716:    if (output_pointer == NULL)
        -: 1717:    {
    #####: 1718:        return false;
        -: 1719:    }
       47: 1720:    if (output_buffer->format)
        -: 1721:    {
        -: 1722:        size_t i;
       11: 1723:        for (i = 0; i < (output_buffer->depth - 1); i++)
        -: 1724:        {
        2: 1725:            *output_pointer++ = '\t';
        -: 1726:        }
        -: 1727:    }
       47: 1728:    *output_pointer++ = '}';
       47: 1729:    *output_pointer = '\0';
       47: 1730:    output_buffer->depth--;
        -: 1731:
       47: 1732:    return true;
        -: 1733:}
        -: 1734:
        -: 1735:/* Get Array size/item / object item. */
        8: 1736:CJSON_PUBLIC(int) cJSON_GetArraySize(const cJSON *array)
        -: 1737:{
        8: 1738:    cJSON *child = NULL;
        8: 1739:    size_t size = 0;
        -: 1740:
        8: 1741:    if (array == NULL)
        -: 1742:    {
        1: 1743:        return 0;
        -: 1744:    }
        -: 1745:
        7: 1746:    child = array->child;
        -: 1747:
       35: 1748:    while(child != NULL)
        -: 1749:    {
       14: 1750:        size++;
       14: 1751:        child = child->next;
        -: 1752:    }
        -: 1753:
        -: 1754:    /* FIXME: Can overflow here. Cannot be fixed without breaking the API */
        -: 1755:
        7: 1756:    return (int)size;
        -: 1757:}
        -: 1758:
        9: 1759:static cJSON* get_array_item(const cJSON *array, size_t index)
        -: 1760:{
        9: 1761:    cJSON *current_child = NULL;
        -: 1762:
        9: 1763:    if (array == NULL)
        -: 1764:    {
        4: 1765:        return NULL;
        -: 1766:    }
        -: 1767:
        5: 1768:    current_child = array->child;
       17: 1769:    while ((current_child != NULL) && (index > 0))
        -: 1770:    {
        6: 1771:        index--;
        6: 1772:        current_child = current_child->next;
        -: 1773:    }
        -: 1774:
        5: 1775:    return current_child;
        -: 1776:}
        -: 1777:
        1: 1778:CJSON_PUBLIC(cJSON *) cJSON_GetArrayItem(const cJSON *array, int index)
        -: 1779:{
        1: 1780:    if (index < 0)
        -: 1781:    {
    #####: 1782:        return NULL;
        -: 1783:    }
        -: 1784:
        1: 1785:    return get_array_item(array, (size_t)index);
        -: 1786:}
        -: 1787:
       53: 1788:static cJSON *get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)
        -: 1789:{
       53: 1790:    cJSON *current_element = NULL;
        -: 1791:
       53: 1792:    if ((object == NULL) || (name == NULL))
        -: 1793:    {
       13: 1794:        return NULL;
        -: 1795:    }
        -: 1796:
       40: 1797:    current_element = object->child;
       40: 1798:    if (case_sensitive)
        -: 1799:    {
      126: 1800:        while ((current_element != NULL) && (current_element->string != NULL) && (strcmp(name, current_element->string) != 0))
        -: 1801:        {
       53: 1802:            current_element = current_element->next;
        -: 1803:        }
        -: 1804:    }
        -: 1805:    else
        -: 1806:    {
      126: 1807:        while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))
        -: 1808:        {
       53: 1809:            current_element = current_element->next;
        -: 1810:        }
        -: 1811:    }
        -: 1812:
       40: 1813:    if ((current_element == NULL) || (current_element->string == NULL)) {
        4: 1814:        return NULL;
        -: 1815:    }
        -: 1816:
       36: 1817:    return current_element;
        -: 1818:}
        -: 1819:
        6: 1820:CJSON_PUBLIC(cJSON *) cJSON_GetObjectItem(const cJSON * const object, const char * const string)
        -: 1821:{
        6: 1822:    return get_object_item(object, string, false);
        -: 1823:}
        -: 1824:
        5: 1825:CJSON_PUBLIC(cJSON *) cJSON_GetObjectItemCaseSensitive(const cJSON * const object, const char * const string)
        -: 1826:{
        5: 1827:    return get_object_item(object, string, true);
        -: 1828:}
        -: 1829:
        1: 1830:CJSON_PUBLIC(cJSON_bool) cJSON_HasObjectItem(const cJSON *object, const char *string)
        -: 1831:{
        1: 1832:    return cJSON_GetObjectItem(object, string) ? 1 : 0;
        -: 1833:}
        -: 1834:
        -: 1835:/* Utility for array list handling. */
       47: 1836:static void suffix_object(cJSON *prev, cJSON *item)
        -: 1837:{
       47: 1838:    prev->next = item;
       47: 1839:    item->prev = prev;
       47: 1840:}
        -: 1841:
        -: 1842:/* Utility for handling references. */
        3: 1843:static cJSON *create_reference(const cJSON *item, const internal_hooks * const hooks)
        -: 1844:{
        3: 1845:    cJSON *reference = NULL;
        3: 1846:    if (item == NULL)
        -: 1847:    {
        2: 1848:        return NULL;
        -: 1849:    }
        -: 1850:
        1: 1851:    reference = cJSON_New_Item(hooks);
        1: 1852:    if (reference == NULL)
        -: 1853:    {
    #####: 1854:        return NULL;
        -: 1855:    }
        -: 1856:
        1: 1857:    memcpy(reference, item, sizeof(cJSON));
        1: 1858:    reference->string = NULL;
        1: 1859:    reference->type |= cJSON_IsReference;
        1: 1860:    reference->next = reference->prev = NULL;
        1: 1861:    return reference;
        -: 1862:}
        -: 1863:
       27: 1864:static cJSON_bool add_item_to_array(cJSON *array, cJSON *item)
        -: 1865:{
       27: 1866:    cJSON *child = NULL;
        -: 1867:
       27: 1868:    if ((item == NULL) || (array == NULL))
        -: 1869:    {
        3: 1870:        return false;
        -: 1871:    }
        -: 1872:
       24: 1873:    child = array->child;
        -: 1874:
       24: 1875:    if (child == NULL)
        -: 1876:    {
        -: 1877:        /* list is empty, start new one */
       16: 1878:        array->child = item;
        -: 1879:    }
        -: 1880:    else
        -: 1881:    {
        -: 1882:        /* append to the end */
       14: 1883:        while (child->next)
        -: 1884:        {
        3: 1885:            child = child->next;
        -: 1886:        }
        8: 1887:        suffix_object(child, item);
        -: 1888:    }
        -: 1889:
       24: 1890:    return true;
        -: 1891:}
        -: 1892:
        -: 1893:/* Add item to array/object. */
        7: 1894:CJSON_PUBLIC(void) cJSON_AddItemToArray(cJSON *array, cJSON *item)
        -: 1895:{
        7: 1896:    add_item_to_array(array, item);
        7: 1897:}
        -: 1898:
        -: 1899:#if defined(__clang__) || (defined(__GNUC__)  && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 5))))
        -: 1900:    #pragma GCC diagnostic push
        -: 1901:#endif
        -: 1902:#ifdef __GNUC__
        -: 1903:#pragma GCC diagnostic ignored "-Wcast-qual"
        -: 1904:#endif
        -: 1905:/* helper function to cast away const */
        4: 1906:static void* cast_away_const(const void* string)
        -: 1907:{
        4: 1908:    return (void*)string;
        -: 1909:}
        -: 1910:#if defined(__clang__) || (defined(__GNUC__)  && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 5))))
        -: 1911:    #pragma GCC diagnostic pop
        -: 1912:#endif
        -: 1913:
        -: 1914:
       40: 1915:static cJSON_bool add_item_to_object(cJSON * const object, const char * const string, cJSON * const item, const internal_hooks * const hooks, const cJSON_bool constant_key)
        -: 1916:{
       40: 1917:    char *new_key = NULL;
       40: 1918:    int new_type = cJSON_Invalid;
        -: 1919:
       40: 1920:    if ((object == NULL) || (string == NULL) || (item == NULL))
        -: 1921:    {
       25: 1922:        return false;
        -: 1923:    }
        -: 1924:
       15: 1925:    if (constant_key)
        -: 1926:    {
        1: 1927:        new_key = (char*)cast_away_const(string);
        1: 1928:        new_type = item->type | cJSON_StringIsConst;
        -: 1929:    }
        -: 1930:    else
        -: 1931:    {
       14: 1932:        new_key = (char*)cJSON_strdup((const unsigned char*)string, hooks);
       14: 1933:        if (new_key == NULL)
        -: 1934:        {
    #####: 1935:            return false;
        -: 1936:        }
        -: 1937:
       14: 1938:        new_type = item->type & ~cJSON_StringIsConst;
        -: 1939:    }
        -: 1940:
       15: 1941:    if (!(item->type & cJSON_StringIsConst) && (item->string != NULL))
        -: 1942:    {
    #####: 1943:        hooks->deallocate(item->string);
        -: 1944:    }
        -: 1945:
       15: 1946:    item->string = new_key;
       15: 1947:    item->type = new_type;
        -: 1948:
       15: 1949:    return add_item_to_array(object, item);
        -: 1950:}
        -: 1951:
        1: 1952:CJSON_PUBLIC(void) cJSON_AddItemToObject(cJSON *object, const char *string, cJSON *item)
        -: 1953:{
        1: 1954:    add_item_to_object(object, string, item, &global_hooks, false);
        1: 1955:}
        -: 1956:
        -: 1957:/* Add an item to an object with constant string as key */
        1: 1958:CJSON_PUBLIC(void) cJSON_AddItemToObjectCS(cJSON *object, const char *string, cJSON *item)
        -: 1959:{
        1: 1960:    add_item_to_object(object, string, item, &global_hooks, true);
        1: 1961:}
        -: 1962:
        3: 1963:CJSON_PUBLIC(void) cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)
        -: 1964:{
        3: 1965:    if (array == NULL)
        -: 1966:    {
        1: 1967:        return;
        -: 1968:    }
        -: 1969:
        2: 1970:    add_item_to_array(array, create_reference(item, &global_hooks));
        -: 1971:}
        -: 1972:
        3: 1973:CJSON_PUBLIC(void) cJSON_AddItemReferenceToObject(cJSON *object, const char *string, cJSON *item)
        -: 1974:{
        3: 1975:    if ((object == NULL) || (string == NULL))
        -: 1976:    {
        2: 1977:        return;
        -: 1978:    }
        -: 1979:
        1: 1980:    add_item_to_object(object, string, create_reference(item, &global_hooks), &global_hooks, false);
        -: 1981:}
        -: 1982:
        2: 1983:CJSON_PUBLIC(cJSON*) cJSON_AddNullToObject(cJSON * const object, const char * const name)
        -: 1984:{
        2: 1985:    cJSON *null = cJSON_CreateNull();
        2: 1986:    if (add_item_to_object(object, name, null, &global_hooks, false))
        -: 1987:    {
        1: 1988:        return null;
        -: 1989:    }
        -: 1990:
        1: 1991:    cJSON_Delete(null);
        1: 1992:    return NULL;
        -: 1993:}
        -: 1994:
        3: 1995:CJSON_PUBLIC(cJSON*) cJSON_AddTrueToObject(cJSON * const object, const char * const name)
        -: 1996:{
        3: 1997:    cJSON *true_item = cJSON_CreateTrue();
        3: 1998:    if (add_item_to_object(object, name, true_item, &global_hooks, false))
        -: 1999:    {
        1: 2000:        return true_item;
        -: 2001:    }
        -: 2002:
        2: 2003:    cJSON_Delete(true_item);
        2: 2004:    return NULL;
        -: 2005:}
        -: 2006:
        4: 2007:CJSON_PUBLIC(cJSON*) cJSON_AddFalseToObject(cJSON * const object, const char * const name)
        -: 2008:{
        4: 2009:    cJSON *false_item = cJSON_CreateFalse();
        4: 2010:    if (add_item_to_object(object, name, false_item, &global_hooks, false))
        -: 2011:    {
        1: 2012:        return false_item;
        -: 2013:    }
        -: 2014:
        3: 2015:    cJSON_Delete(false_item);
        3: 2016:    return NULL;
        -: 2017:}
        -: 2018:
        5: 2019:CJSON_PUBLIC(cJSON*) cJSON_AddBoolToObject(cJSON * const object, const char * const name, const cJSON_bool boolean)
        -: 2020:{
        5: 2021:    cJSON *bool_item = cJSON_CreateBool(boolean);
        5: 2022:    if (add_item_to_object(object, name, bool_item, &global_hooks, false))
        -: 2023:    {
        3: 2024:        return bool_item;
        -: 2025:    }
        -: 2026:
        2: 2027:    cJSON_Delete(bool_item);
        2: 2028:    return NULL;
        -: 2029:}
        -: 2030:
        6: 2031:CJSON_PUBLIC(cJSON*) cJSON_AddNumberToObject(cJSON * const object, const char * const name, const double number)
        -: 2032:{
        6: 2033:    cJSON *number_item = cJSON_CreateNumber(number);
        6: 2034:    if (add_item_to_object(object, name, number_item, &global_hooks, false))
        -: 2035:    {
    #####: 2036:        return number_item;
        -: 2037:    }
        -: 2038:
        6: 2039:    cJSON_Delete(number_item);
        6: 2040:    return NULL;
        -: 2041:}
        -: 2042:
        4: 2043:CJSON_PUBLIC(cJSON*) cJSON_AddStringToObject(cJSON * const object, const char * const name, const char * const string)
        -: 2044:{
        4: 2045:    cJSON *string_item = cJSON_CreateString(string);
        4: 2046:    if (add_item_to_object(object, name, string_item, &global_hooks, false))
        -: 2047:    {
    #####: 2048:        return string_item;
        -: 2049:    }
        -: 2050:
        4: 2051:    cJSON_Delete(string_item);
        4: 2052:    return NULL;
        -: 2053:}
        -: 2054:
        4: 2055:CJSON_PUBLIC(cJSON*) cJSON_AddRawToObject(cJSON * const object, const char * const name, const char * const raw)
        -: 2056:{
        4: 2057:    cJSON *raw_item = cJSON_CreateRaw(raw);
        4: 2058:    if (add_item_to_object(object, name, raw_item, &global_hooks, false))
        -: 2059:    {
        2: 2060:        return raw_item;
        -: 2061:    }
        -: 2062:
        2: 2063:    cJSON_Delete(raw_item);
        2: 2064:    return NULL;
        -: 2065:}
        -: 2066:
        3: 2067:CJSON_PUBLIC(cJSON*) cJSON_AddObjectToObject(cJSON * const object, const char * const name)
        -: 2068:{
        3: 2069:    cJSON *object_item = cJSON_CreateObject();
        3: 2070:    if (add_item_to_object(object, name, object_item, &global_hooks, false))
        -: 2071:    {
        1: 2072:        return object_item;
        -: 2073:    }
        -: 2074:
        2: 2075:    cJSON_Delete(object_item);
        2: 2076:    return NULL;
        -: 2077:}
        -: 2078:
        6: 2079:CJSON_PUBLIC(cJSON*) cJSON_AddArrayToObject(cJSON * const object, const char * const name)
        -: 2080:{
        6: 2081:    cJSON *array = cJSON_CreateArray();
        6: 2082:    if (add_item_to_object(object, name, array, &global_hooks, false))
        -: 2083:    {
        4: 2084:        return array;
        -: 2085:    }
        -: 2086:
        2: 2087:    cJSON_Delete(array);
        2: 2088:    return NULL;
        -: 2089:}
        -: 2090:
       12: 2091:CJSON_PUBLIC(cJSON *) cJSON_DetachItemViaPointer(cJSON *parent, cJSON * const item)
        -: 2092:{
       12: 2093:    if ((parent == NULL) || (item == NULL))
        -: 2094:    {
       10: 2095:        return NULL;
        -: 2096:    }
        -: 2097:
        2: 2098:    if (item->prev != NULL)
        -: 2099:    {
        -: 2100:        /* not the first element */
        2: 2101:        item->prev->next = item->next;
        -: 2102:    }
        2: 2103:    if (item->next != NULL)
        -: 2104:    {
        -: 2105:        /* not the last element */
        2: 2106:        item->next->prev = item->prev;
        -: 2107:    }
        -: 2108:
        2: 2109:    if (item == parent->child)
        -: 2110:    {
        -: 2111:        /* first element */
        1: 2112:        parent->child = item->next;
        -: 2113:    }
        -: 2114:    /* make sure the detached item doesn't point anywhere anymore */
        2: 2115:    item->prev = NULL;
        2: 2116:    item->next = NULL;
        -: 2117:
        2: 2118:    return item;
        -: 2119:}
        -: 2120:
        3: 2121:CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromArray(cJSON *array, int which)
        -: 2122:{
        3: 2123:    if (which < 0)
        -: 2124:    {
        1: 2125:        return NULL;
        -: 2126:    }
        -: 2127:
        2: 2128:    return cJSON_DetachItemViaPointer(array, get_array_item(array, (size_t)which));
        -: 2129:}
        -: 2130:
        1: 2131:CJSON_PUBLIC(void) cJSON_DeleteItemFromArray(cJSON *array, int which)
        -: 2132:{
        1: 2133:    cJSON_Delete(cJSON_DetachItemFromArray(array, which));
        1: 2134:}
        -: 2135:
        4: 2136:CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObject(cJSON *object, const char *string)
        -: 2137:{
        4: 2138:    cJSON *to_detach = cJSON_GetObjectItem(object, string);
        -: 2139:
        4: 2140:    return cJSON_DetachItemViaPointer(object, to_detach);
        -: 2141:}
        -: 2142:
        4: 2143:CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObjectCaseSensitive(cJSON *object, const char *string)
        -: 2144:{
        4: 2145:    cJSON *to_detach = cJSON_GetObjectItemCaseSensitive(object, string);
        -: 2146:
        4: 2147:    return cJSON_DetachItemViaPointer(object, to_detach);
        -: 2148:}
        -: 2149:
        2: 2150:CJSON_PUBLIC(void) cJSON_DeleteItemFromObject(cJSON *object, const char *string)
        -: 2151:{
        2: 2152:    cJSON_Delete(cJSON_DetachItemFromObject(object, string));
        2: 2153:}
        -: 2154:
        2: 2155:CJSON_PUBLIC(void) cJSON_DeleteItemFromObjectCaseSensitive(cJSON *object, const char *string)
        -: 2156:{
        2: 2157:    cJSON_Delete(cJSON_DetachItemFromObjectCaseSensitive(object, string));
        2: 2158:}
        -: 2159:
        -: 2160:/* Replace array/object items with new ones. */
        4: 2161:CJSON_PUBLIC(void) cJSON_InsertItemInArray(cJSON *array, int which, cJSON *newitem)
        -: 2162:{
        4: 2163:    cJSON *after_inserted = NULL;
        -: 2164:
        4: 2165:    if (which < 0)
        -: 2166:    {
        1: 2167:        return;
        -: 2168:    }
        -: 2169:
        3: 2170:    after_inserted = get_array_item(array, (size_t)which);
        3: 2171:    if (after_inserted == NULL)
        -: 2172:    {
        3: 2173:        add_item_to_array(array, newitem);
        3: 2174:        return;
        -: 2175:    }
        -: 2176:
    #####: 2177:    newitem->next = after_inserted;
    #####: 2178:    newitem->prev = after_inserted->prev;
    #####: 2179:    after_inserted->prev = newitem;
    #####: 2180:    if (after_inserted == array->child)
        -: 2181:    {
    #####: 2182:        array->child = newitem;
        -: 2183:    }
        -: 2184:    else
        -: 2185:    {
    #####: 2186:        newitem->prev->next = newitem;
        -: 2187:    }
        -: 2188:}
        -: 2189:
       11: 2190:CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemViaPointer(cJSON * const parent, cJSON * const item, cJSON * replacement)
        -: 2191:{
       11: 2192:    if ((parent == NULL) || (replacement == NULL) || (item == NULL))
        -: 2193:    {
        8: 2194:        return false;
        -: 2195:    }
        -: 2196:
        3: 2197:    if (replacement == item)
        -: 2198:    {
        1: 2199:        return true;
        -: 2200:    }
        -: 2201:
        2: 2202:    replacement->next = item->next;
        2: 2203:    replacement->prev = item->prev;
        -: 2204:
        2: 2205:    if (replacement->next != NULL)
        -: 2206:    {
        1: 2207:        replacement->next->prev = replacement;
        -: 2208:    }
        2: 2209:    if (replacement->prev != NULL)
        -: 2210:    {
        2: 2211:        replacement->prev->next = replacement;
        -: 2212:    }
        2: 2213:    if (parent->child == item)
        -: 2214:    {
    #####: 2215:        parent->child = replacement;
        -: 2216:    }
        -: 2217:
        2: 2218:    item->next = NULL;
        2: 2219:    item->prev = NULL;
        2: 2220:    cJSON_Delete(item);
        -: 2221:
        2: 2222:    return true;
        -: 2223:}
        -: 2224:
        4: 2225:CJSON_PUBLIC(void) cJSON_ReplaceItemInArray(cJSON *array, int which, cJSON *newitem)
        -: 2226:{
        4: 2227:    if (which < 0)
        -: 2228:    {
        1: 2229:        return;
        -: 2230:    }
        -: 2231:
        3: 2232:    cJSON_ReplaceItemViaPointer(array, get_array_item(array, (size_t)which), newitem);
        -: 2233:}
        -: 2234:
        7: 2235:static cJSON_bool replace_item_in_object(cJSON *object, const char *string, cJSON *replacement, cJSON_bool case_sensitive)
        -: 2236:{
        7: 2237:    if ((replacement == NULL) || (string == NULL))
        -: 2238:    {
        5: 2239:        return false;
        -: 2240:    }
        -: 2241:
        -: 2242:    /* replace the name in the replacement */
        2: 2243:    if (!(replacement->type & cJSON_StringIsConst) && (replacement->string != NULL))
        -: 2244:    {
        1: 2245:        cJSON_free(replacement->string);
        -: 2246:    }
        2: 2247:    replacement->string = (char*)cJSON_strdup((const unsigned char*)string, &global_hooks);
        2: 2248:    replacement->type &= ~cJSON_StringIsConst;
        -: 2249:
        2: 2250:    cJSON_ReplaceItemViaPointer(object, get_object_item(object, string, case_sensitive), replacement);
        -: 2251:
        2: 2252:    return true;
        -: 2253:}
        -: 2254:
        4: 2255:CJSON_PUBLIC(void) cJSON_ReplaceItemInObject(cJSON *object, const char *string, cJSON *newitem)
        -: 2256:{
        4: 2257:    replace_item_in_object(object, string, newitem, false);
        4: 2258:}
        -: 2259:
        3: 2260:CJSON_PUBLIC(void) cJSON_ReplaceItemInObjectCaseSensitive(cJSON *object, const char *string, cJSON *newitem)
        -: 2261:{
        3: 2262:    replace_item_in_object(object, string, newitem, true);
        3: 2263:}
        -: 2264:
        -: 2265:/* Create basic types: */
        8: 2266:CJSON_PUBLIC(cJSON *) cJSON_CreateNull(void)
        -: 2267:{
        8: 2268:    cJSON *item = cJSON_New_Item(&global_hooks);
        8: 2269:    if(item)
        -: 2270:    {
        8: 2271:        item->type = cJSON_NULL;
        -: 2272:    }
        -: 2273:
        8: 2274:    return item;
        -: 2275:}
        -: 2276:
        3: 2277:CJSON_PUBLIC(cJSON *) cJSON_CreateTrue(void)
        -: 2278:{
        3: 2279:    cJSON *item = cJSON_New_Item(&global_hooks);
        3: 2280:    if(item)
        -: 2281:    {
        3: 2282:        item->type = cJSON_True;
        -: 2283:    }
        -: 2284:
        3: 2285:    return item;
        -: 2286:}
        -: 2287:
        4: 2288:CJSON_PUBLIC(cJSON *) cJSON_CreateFalse(void)
        -: 2289:{
        4: 2290:    cJSON *item = cJSON_New_Item(&global_hooks);
        4: 2291:    if(item)
        -: 2292:    {
        4: 2293:        item->type = cJSON_False;
        -: 2294:    }
        -: 2295:
        4: 2296:    return item;
        -: 2297:}
        -: 2298:
        5: 2299:CJSON_PUBLIC(cJSON *) cJSON_CreateBool(cJSON_bool boolean)
        -: 2300:{
        5: 2301:    cJSON *item = cJSON_New_Item(&global_hooks);
        5: 2302:    if(item)
        -: 2303:    {
        5: 2304:        item->type = boolean ? cJSON_True : cJSON_False;
        -: 2305:    }
        -: 2306:
        5: 2307:    return item;
        -: 2308:}
        -: 2309:
       46: 2310:CJSON_PUBLIC(cJSON *) cJSON_CreateNumber(double num)
        -: 2311:{
       46: 2312:    cJSON *item = cJSON_New_Item(&global_hooks);
       46: 2313:    if(item)
        -: 2314:    {
       46: 2315:        item->type = cJSON_Number;
       46: 2316:        item->valuedouble = num;
        -: 2317:
        -: 2318:        /* use saturation in case of overflow */
       46: 2319:        if (num >= INT_MAX)
        -: 2320:        {
    #####: 2321:            item->valueint = INT_MAX;
        -: 2322:        }
       46: 2323:        else if (num <= (double)INT_MIN)
        -: 2324:        {
        1: 2325:            item->valueint = INT_MIN;
        -: 2326:        }
        -: 2327:        else
        -: 2328:        {
       45: 2329:            item->valueint = (int)num;
        -: 2330:        }
        -: 2331:    }
        -: 2332:
       46: 2333:    return item;
        -: 2334:}
        -: 2335:
       25: 2336:CJSON_PUBLIC(cJSON *) cJSON_CreateString(const char *string)
        -: 2337:{
       25: 2338:    cJSON *item = cJSON_New_Item(&global_hooks);
       25: 2339:    if(item)
        -: 2340:    {
       25: 2341:        item->type = cJSON_String;
       25: 2342:        item->valuestring = (char*)cJSON_strdup((const unsigned char*)string, &global_hooks);
       25: 2343:        if(!item->valuestring)
        -: 2344:        {
    #####: 2345:            cJSON_Delete(item);
    #####: 2346:            return NULL;
        -: 2347:        }
        -: 2348:    }
        -: 2349:
       25: 2350:    return item;
        -: 2351:}
        -: 2352:
        1: 2353:CJSON_PUBLIC(cJSON *) cJSON_CreateStringReference(const char *string)
        -: 2354:{
        1: 2355:    cJSON *item = cJSON_New_Item(&global_hooks);
        1: 2356:    if (item != NULL)
        -: 2357:    {
        1: 2358:        item->type = cJSON_String | cJSON_IsReference;
        1: 2359:        item->valuestring = (char*)cast_away_const(string);
        -: 2360:    }
        -: 2361:
        1: 2362:    return item;
        -: 2363:}
        -: 2364:
        1: 2365:CJSON_PUBLIC(cJSON *) cJSON_CreateObjectReference(const cJSON *child)
        -: 2366:{
        1: 2367:    cJSON *item = cJSON_New_Item(&global_hooks);
        1: 2368:    if (item != NULL) {
        1: 2369:        item->type = cJSON_Object | cJSON_IsReference;
        1: 2370:        item->child = (cJSON*)cast_away_const(child);
        -: 2371:    }
        -: 2372:
        1: 2373:    return item;
        -: 2374:}
        -: 2375:
        1: 2376:CJSON_PUBLIC(cJSON *) cJSON_CreateArrayReference(const cJSON *child) {
        1: 2377:    cJSON *item = cJSON_New_Item(&global_hooks);
        1: 2378:    if (item != NULL) {
        1: 2379:        item->type = cJSON_Array | cJSON_IsReference;
        1: 2380:        item->child = (cJSON*)cast_away_const(child);
        -: 2381:    }
        -: 2382:
        1: 2383:    return item;
        -: 2384:}
        -: 2385:
        4: 2386:CJSON_PUBLIC(cJSON *) cJSON_CreateRaw(const char *raw)
        -: 2387:{
        4: 2388:    cJSON *item = cJSON_New_Item(&global_hooks);
        4: 2389:    if(item)
        -: 2390:    {
        4: 2391:        item->type = cJSON_Raw;
        4: 2392:        item->valuestring = (char*)cJSON_strdup((const unsigned char*)raw, &global_hooks);
        4: 2393:        if(!item->valuestring)
        -: 2394:        {
    #####: 2395:            cJSON_Delete(item);
    #####: 2396:            return NULL;
        -: 2397:        }
        -: 2398:    }
        -: 2399:
        4: 2400:    return item;
        -: 2401:}
        -: 2402:
       18: 2403:CJSON_PUBLIC(cJSON *) cJSON_CreateArray(void)
        -: 2404:{
       18: 2405:    cJSON *item = cJSON_New_Item(&global_hooks);
       18: 2406:    if(item)
        -: 2407:    {
       18: 2408:        item->type=cJSON_Array;
        -: 2409:    }
        -: 2410:
       18: 2411:    return item;
        -: 2412:}
        -: 2413:
       12: 2414:CJSON_PUBLIC(cJSON *) cJSON_CreateObject(void)
        -: 2415:{
       12: 2416:    cJSON *item = cJSON_New_Item(&global_hooks);
       12: 2417:    if (item)
        -: 2418:    {
       12: 2419:        item->type = cJSON_Object;
        -: 2420:    }
        -: 2421:
       12: 2422:    return item;
        -: 2423:}
        -: 2424:
        -: 2425:/* Create Arrays: */
        5: 2426:CJSON_PUBLIC(cJSON *) cJSON_CreateIntArray(const int *numbers, int count)
        -: 2427:{
        5: 2428:    size_t i = 0;
        5: 2429:    cJSON *n = NULL;
        5: 2430:    cJSON *p = NULL;
        5: 2431:    cJSON *a = NULL;
        -: 2432:
        5: 2433:    if ((count < 0) || (numbers == NULL))
        -: 2434:    {
        1: 2435:        return NULL;
        -: 2436:    }
        -: 2437:
        4: 2438:    a = cJSON_CreateArray();
       23: 2439:    for(i = 0; a && (i < (size_t)count); i++)
        -: 2440:    {
       19: 2441:        n = cJSON_CreateNumber(numbers[i]);
       19: 2442:        if (!n)
        -: 2443:        {
    #####: 2444:            cJSON_Delete(a);
    #####: 2445:            return NULL;
        -: 2446:        }
       19: 2447:        if(!i)
        -: 2448:        {
        4: 2449:            a->child = n;
        -: 2450:        }
        -: 2451:        else
        -: 2452:        {
       15: 2453:            suffix_object(p, n);
        -: 2454:        }
       19: 2455:        p = n;
        -: 2456:    }
        -: 2457:
        4: 2458:    return a;
        -: 2459:}
        -: 2460:
        2: 2461:CJSON_PUBLIC(cJSON *) cJSON_CreateFloatArray(const float *numbers, int count)
        -: 2462:{
        2: 2463:    size_t i = 0;
        2: 2464:    cJSON *n = NULL;
        2: 2465:    cJSON *p = NULL;
        2: 2466:    cJSON *a = NULL;
        -: 2467:
        2: 2468:    if ((count < 0) || (numbers == NULL))
        -: 2469:    {
        1: 2470:        return NULL;
        -: 2471:    }
        -: 2472:
        1: 2473:    a = cJSON_CreateArray();
        -: 2474:
       11: 2475:    for(i = 0; a && (i < (size_t)count); i++)
        -: 2476:    {
       10: 2477:        n = cJSON_CreateNumber((double)numbers[i]);
       10: 2478:        if(!n)
        -: 2479:        {
    #####: 2480:            cJSON_Delete(a);
    #####: 2481:            return NULL;
        -: 2482:        }
       10: 2483:        if(!i)
        -: 2484:        {
        1: 2485:            a->child = n;
        -: 2486:        }
        -: 2487:        else
        -: 2488:        {
        9: 2489:            suffix_object(p, n);
        -: 2490:        }
       10: 2491:        p = n;
        -: 2492:    }
        -: 2493:
        1: 2494:    return a;
        -: 2495:}
        -: 2496:
        2: 2497:CJSON_PUBLIC(cJSON *) cJSON_CreateDoubleArray(const double *numbers, int count)
        -: 2498:{
        2: 2499:    size_t i = 0;
        2: 2500:    cJSON *n = NULL;
        2: 2501:    cJSON *p = NULL;
        2: 2502:    cJSON *a = NULL;
        -: 2503:
        2: 2504:    if ((count < 0) || (numbers == NULL))
        -: 2505:    {
        1: 2506:        return NULL;
        -: 2507:    }
        -: 2508:
        1: 2509:    a = cJSON_CreateArray();
        -: 2510:
       11: 2511:    for(i = 0;a && (i < (size_t)count); i++)
        -: 2512:    {
       10: 2513:        n = cJSON_CreateNumber(numbers[i]);
       10: 2514:        if(!n)
        -: 2515:        {
    #####: 2516:            cJSON_Delete(a);
    #####: 2517:            return NULL;
        -: 2518:        }
       10: 2519:        if(!i)
        -: 2520:        {
        1: 2521:            a->child = n;
        -: 2522:        }
        -: 2523:        else
        -: 2524:        {
        9: 2525:            suffix_object(p, n);
        -: 2526:        }
       10: 2527:        p = n;
        -: 2528:    }
        -: 2529:
        1: 2530:    return a;
        -: 2531:}
        -: 2532:
        2: 2533:CJSON_PUBLIC(cJSON *) cJSON_CreateStringArray(const char *const *strings, int count)
        -: 2534:{
        2: 2535:    size_t i = 0;
        2: 2536:    cJSON *n = NULL;
        2: 2537:    cJSON *p = NULL;
        2: 2538:    cJSON *a = NULL;
        -: 2539:
        2: 2540:    if ((count < 0) || (strings == NULL))
        -: 2541:    {
        1: 2542:        return NULL;
        -: 2543:    }
        -: 2544:
        1: 2545:    a = cJSON_CreateArray();
        -: 2546:
        8: 2547:    for (i = 0; a && (i < (size_t)count); i++)
        -: 2548:    {
        7: 2549:        n = cJSON_CreateString(strings[i]);
        7: 2550:        if(!n)
        -: 2551:        {
    #####: 2552:            cJSON_Delete(a);
    #####: 2553:            return NULL;
        -: 2554:        }
        7: 2555:        if(!i)
        -: 2556:        {
        1: 2557:            a->child = n;
        -: 2558:        }
        -: 2559:        else
        -: 2560:        {
        6: 2561:            suffix_object(p,n);
        -: 2562:        }
        7: 2563:        p = n;
        -: 2564:    }
        -: 2565:
        1: 2566:    return a;
        -: 2567:}
        -: 2568:
        -: 2569:/* Duplication */
        4: 2570:CJSON_PUBLIC(cJSON *) cJSON_Duplicate(const cJSON *item, cJSON_bool recurse)
        -: 2571:{
        4: 2572:    cJSON *newitem = NULL;
        4: 2573:    cJSON *child = NULL;
        4: 2574:    cJSON *next = NULL;
        4: 2575:    cJSON *newchild = NULL;
        -: 2576:
        -: 2577:    /* Bail on bad ptr */
        4: 2578:    if (!item)
        -: 2579:    {
        1: 2580:        goto fail;
        -: 2581:    }
        -: 2582:    /* Create new item */
        3: 2583:    newitem = cJSON_New_Item(&global_hooks);
        3: 2584:    if (!newitem)
        -: 2585:    {
    #####: 2586:        goto fail;
        -: 2587:    }
        -: 2588:    /* Copy over all vars */
        3: 2589:    newitem->type = item->type & (~cJSON_IsReference);
        3: 2590:    newitem->valueint = item->valueint;
        3: 2591:    newitem->valuedouble = item->valuedouble;
        3: 2592:    if (item->valuestring)
        -: 2593:    {
        2: 2594:        newitem->valuestring = (char*)cJSON_strdup((unsigned char*)item->valuestring, &global_hooks);
        2: 2595:        if (!newitem->valuestring)
        -: 2596:        {
    #####: 2597:            goto fail;
        -: 2598:        }
        -: 2599:    }
        3: 2600:    if (item->string)
        -: 2601:    {
    #####: 2602:        newitem->string = (item->type&cJSON_StringIsConst) ? item->string : (char*)cJSON_strdup((unsigned char*)item->string, &global_hooks);
    #####: 2603:        if (!newitem->string)
        -: 2604:        {
    #####: 2605:            goto fail;
        -: 2606:        }
        -: 2607:    }
        -: 2608:    /* If non-recursive, then we're done! */
        3: 2609:    if (!recurse)
        -: 2610:    {
    #####: 2611:        return newitem;
        -: 2612:    }
        -: 2613:    /* Walk the ->next chain for the child. */
        3: 2614:    child = item->child;
        5: 2615:    while (child != NULL)
        -: 2616:    {
        1: 2617:        newchild = cJSON_Duplicate(child, true); /* Duplicate (with recurse) each item in the ->next chain */
        1: 2618:        if (!newchild)
        -: 2619:        {
    #####: 2620:            goto fail;
        -: 2621:        }
        1: 2622:        if (next != NULL)
        -: 2623:        {
        -: 2624:            /* If newitem->child already set, then crosswire ->prev and ->next and move on */
    #####: 2625:            next->next = newchild;
    #####: 2626:            newchild->prev = next;
    #####: 2627:            next = newchild;
        -: 2628:        }
        -: 2629:        else
        -: 2630:        {
        -: 2631:            /* Set newitem->child and move to it */
        1: 2632:            newitem->child = newchild;
        1: 2633:            next = newchild;
        -: 2634:        }
        1: 2635:        child = child->next;
        -: 2636:    }
        -: 2637:
        3: 2638:    return newitem;
        -: 2639:
        1: 2640:fail:
        1: 2641:    if (newitem != NULL)
        -: 2642:    {
    #####: 2643:        cJSON_Delete(newitem);
        -: 2644:    }
        -: 2645:
        1: 2646:    return NULL;
        -: 2647:}
        -: 2648:
        1: 2649:static void skip_oneline_comment(char **input)
        -: 2650:{
        1: 2651:    *input += static_strlen("//");
        -: 2652:
      111: 2653:    for (; (*input)[0] != '\0'; ++(*input))
        -: 2654:    {
       56: 2655:        if ((*input)[0] == '\n') {
        1: 2656:            *input += static_strlen("\n");
        1: 2657:            return;
        -: 2658:        }
        -: 2659:    }
        -: 2660:}
        -: 2661:
    #####: 2662:static void skip_multiline_comment(char **input)
        -: 2663:{
    #####: 2664:    *input += static_strlen("/*");
        -: 2665:
    #####: 2666:    for (; (*input)[0] != '\0'; ++(*input))
        -: 2667:    {
    #####: 2668:        if (((*input)[0] == '*') && ((*input)[1] == '/'))
        -: 2669:        {
    #####: 2670:            *input += static_strlen("*/");
    #####: 2671:            return;
        -: 2672:        }
        -: 2673:    }
        -: 2674:}
        -: 2675:
        2: 2676:static void minify_string(char **input, char **output) {
        2: 2677:    (*output)[0] = (*input)[0];
        2: 2678:    *input += static_strlen("\"");
        2: 2679:    *output += static_strlen("\"");
        -: 2680:
        -: 2681:
       18: 2682:    for (; (*input)[0] != '\0'; (void)++(*input), ++(*output)) {
        8: 2683:        (*output)[0] = (*input)[0];
        -: 2684:
        8: 2685:        if ((*input)[0] == '\"') {
    #####: 2686:            (*output)[0] = '\"';
    #####: 2687:            *input += static_strlen("\"");
    #####: 2688:            *output += static_strlen("\"");
    #####: 2689:            return;
        8: 2690:        } else if (((*input)[0] == '\\') && ((*input)[1] == '\"')) {
    #####: 2691:            (*output)[1] = (*input)[1];
    #####: 2692:            *input += static_strlen("\"");
    #####: 2693:            *output += static_strlen("\"");
        -: 2694:        }
        -: 2695:    }
        -: 2696:}
        -: 2697:
        3: 2698:CJSON_PUBLIC(void) cJSON_Minify(char *json)
        -: 2699:{
        3: 2700:    char *into = json;
        -: 2701:
        3: 2702:    if (json == NULL)
        -: 2703:    {
    #####: 2704:        return;
        -: 2705:    }
        -: 2706:
       13: 2707:    while (json[0] != '\0')
        -: 2708:    {
        5: 2709:        switch (json[0])
        -: 2710:        {
    #####: 2711:            case ' ':
        -: 2712:            case '\t':
        -: 2713:            case '\r':
        -: 2714:            case '\n':
    #####: 2715:                json++;
    #####: 2716:                break;
        -: 2717:
        1: 2718:            case '/':
        1: 2719:                if (json[1] == '/')
        -: 2720:                {
        1: 2721:                    skip_oneline_comment(&json);
        -: 2722:                }
    #####: 2723:                else if (json[1] == '*')
        -: 2724:                {
    #####: 2725:                    skip_multiline_comment(&json);
        -: 2726:                } else {
    #####: 2727:                    json++;
        -: 2728:                }
        1: 2729:                break;
        -: 2730:
        2: 2731:            case '\"':
        2: 2732:                minify_string(&json, (char**)&into);
        2: 2733:                break;
        -: 2734:
        2: 2735:            default:
        2: 2736:                into[0] = json[0];
        2: 2737:                json++;
        2: 2738:                into++;
        -: 2739:        }
        -: 2740:    }
        -: 2741:
        -: 2742:    /* and null-terminate. */
        3: 2743:    *into = '\0';
        -: 2744:}
        -: 2745:
      108: 2746:CJSON_PUBLIC(cJSON_bool) cJSON_IsInvalid(const cJSON * const item)
        -: 2747:{
      108: 2748:    if (item == NULL)
        -: 2749:    {
        1: 2750:        return false;
        -: 2751:    }
        -: 2752:
      107: 2753:    return (item->type & 0xFF) == cJSON_Invalid;
        -: 2754:}
        -: 2755:
        3: 2756:CJSON_PUBLIC(cJSON_bool) cJSON_IsFalse(const cJSON * const item)
        -: 2757:{
        3: 2758:    if (item == NULL)
        -: 2759:    {
        1: 2760:        return false;
        -: 2761:    }
        -: 2762:
        2: 2763:    return (item->type & 0xFF) == cJSON_False;
        -: 2764:}
        -: 2765:
        3: 2766:CJSON_PUBLIC(cJSON_bool) cJSON_IsTrue(const cJSON * const item)
        -: 2767:{
        3: 2768:    if (item == NULL)
        -: 2769:    {
        1: 2770:        return false;
        -: 2771:    }
        -: 2772:
        2: 2773:    return (item->type & 0xff) == cJSON_True;
        -: 2774:}
        -: 2775:
        -: 2776:
        2: 2777:CJSON_PUBLIC(cJSON_bool) cJSON_IsBool(const cJSON * const item)
        -: 2778:{
        2: 2779:    if (item == NULL)
        -: 2780:    {
        1: 2781:        return false;
        -: 2782:    }
        -: 2783:
        1: 2784:    return (item->type & (cJSON_True | cJSON_False)) != 0;
        -: 2785:}
        2: 2786:CJSON_PUBLIC(cJSON_bool) cJSON_IsNull(const cJSON * const item)
        -: 2787:{
        2: 2788:    if (item == NULL)
        -: 2789:    {
        1: 2790:        return false;
        -: 2791:    }
        -: 2792:
        1: 2793:    return (item->type & 0xFF) == cJSON_NULL;
        -: 2794:}
        -: 2795:
        3: 2796:CJSON_PUBLIC(cJSON_bool) cJSON_IsNumber(const cJSON * const item)
        -: 2797:{
        3: 2798:    if (item == NULL)
        -: 2799:    {
        1: 2800:        return false;
        -: 2801:    }
        -: 2802:
        2: 2803:    return (item->type & 0xFF) == cJSON_Number;
        -: 2804:}
        -: 2805:
        3: 2806:CJSON_PUBLIC(cJSON_bool) cJSON_IsString(const cJSON * const item)
        -: 2807:{
        3: 2808:    if (item == NULL)
        -: 2809:    {
        1: 2810:        return false;
        -: 2811:    }
        -: 2812:
        2: 2813:    return (item->type & 0xFF) == cJSON_String;
        -: 2814:}
        -: 2815:
        3: 2816:CJSON_PUBLIC(cJSON_bool) cJSON_IsArray(const cJSON * const item)
        -: 2817:{
        3: 2818:    if (item == NULL)
        -: 2819:    {
        1: 2820:        return false;
        -: 2821:    }
        -: 2822:
        2: 2823:    return (item->type & 0xFF) == cJSON_Array;
        -: 2824:}
        -: 2825:
        3: 2826:CJSON_PUBLIC(cJSON_bool) cJSON_IsObject(const cJSON * const item)
        -: 2827:{
        3: 2828:    if (item == NULL)
        -: 2829:    {
        1: 2830:        return false;
        -: 2831:    }
        -: 2832:
        2: 2833:    return (item->type & 0xFF) == cJSON_Object;
        -: 2834:}
        -: 2835:
        3: 2836:CJSON_PUBLIC(cJSON_bool) cJSON_IsRaw(const cJSON * const item)
        -: 2837:{
        3: 2838:    if (item == NULL)
        -: 2839:    {
        1: 2840:        return false;
        -: 2841:    }
        -: 2842:
        2: 2843:    return (item->type & 0xFF) == cJSON_Raw;
        -: 2844:}
        -: 2845:
      112: 2846:CJSON_PUBLIC(cJSON_bool) cJSON_Compare(const cJSON * const a, const cJSON * const b, const cJSON_bool case_sensitive)
        -: 2847:{
      112: 2848:    if ((a == NULL) || (b == NULL) || ((a->type & 0xFF) != (b->type & 0xFF)) || cJSON_IsInvalid(a))
        -: 2849:    {
        8: 2850:        return false;
        -: 2851:    }
        -: 2852:
        -: 2853:    /* check if type is valid */
      104: 2854:    switch (a->type & 0xFF)
        -: 2855:    {
      102: 2856:        case cJSON_False:
        -: 2857:        case cJSON_True:
        -: 2858:        case cJSON_NULL:
        -: 2859:        case cJSON_Number:
        -: 2860:        case cJSON_String:
        -: 2861:        case cJSON_Raw:
        -: 2862:        case cJSON_Array:
        -: 2863:        case cJSON_Object:
      102: 2864:            break;
        -: 2865:
        2: 2866:        default:
        2: 2867:            return false;
        -: 2868:    }
        -: 2869:
        -: 2870:    /* identical objects are equal */
      102: 2871:    if (a == b)
        -: 2872:    {
    #####: 2873:        return true;
        -: 2874:    }
        -: 2875:
      102: 2876:    switch (a->type & 0xFF)
        -: 2877:    {
        -: 2878:        /* in these cases and equal type is enough */
       28: 2879:        case cJSON_False:
        -: 2880:        case cJSON_True:
        -: 2881:        case cJSON_NULL:
       28: 2882:            return true;
        -: 2883:
       28: 2884:        case cJSON_Number:
       28: 2885:            if (compare_double(a->valuedouble, b->valuedouble))
        -: 2886:            {
       26: 2887:                return true;
        -: 2888:            }
        2: 2889:            return false;
        -: 2890:
       12: 2891:        case cJSON_String:
        -: 2892:        case cJSON_Raw:
       12: 2893:            if ((a->valuestring == NULL) || (b->valuestring == NULL))
        -: 2894:            {
    #####: 2895:                return false;
        -: 2896:            }
       12: 2897:            if (strcmp(a->valuestring, b->valuestring) == 0)
        -: 2898:            {
       10: 2899:                return true;
        -: 2900:            }
        -: 2901:
        2: 2902:            return false;
        -: 2903:
       20: 2904:        case cJSON_Array:
        -: 2905:        {
       20: 2906:            cJSON *a_element = a->child;
       20: 2907:            cJSON *b_element = b->child;
        -: 2908:
       72: 2909:            for (; (a_element != NULL) && (b_element != NULL);)
        -: 2910:            {
       28: 2911:                if (!cJSON_Compare(a_element, b_element, case_sensitive))
        -: 2912:                {
        2: 2913:                    return false;
        -: 2914:                }
        -: 2915:
       26: 2916:                a_element = a_element->next;
       26: 2917:                b_element = b_element->next;
        -: 2918:            }
        -: 2919:
        -: 2920:            /* one of the arrays is longer than the other */
       18: 2921:            if (a_element != b_element) {
        2: 2922:                return false;
        -: 2923:            }
        -: 2924:
       16: 2925:            return true;
        -: 2926:        }
        -: 2927:
       14: 2928:        case cJSON_Object:
        -: 2929:        {
       14: 2930:            cJSON *a_element = NULL;
       14: 2931:            cJSON *b_element = NULL;
       32: 2932:            cJSON_ArrayForEach(a_element, a)
        -: 2933:            {
        -: 2934:                /* TODO This has O(n^2) runtime, which is horrible! */
       20: 2935:                b_element = get_object_item(b, a_element->string, case_sensitive);
       20: 2936:                if (b_element == NULL)
        -: 2937:                {
        2: 2938:                    return false;
        -: 2939:                }
        -: 2940:
       18: 2941:                if (!cJSON_Compare(a_element, b_element, case_sensitive))
        -: 2942:                {
    #####: 2943:                    return false;
        -: 2944:                }
        -: 2945:            }
        -: 2946:
        -: 2947:            /* doing this twice, once on a and b to prevent true comparison if a subset of b
        -: 2948:             * TODO: Do this the proper way, this is just a fix for now */
       30: 2949:            cJSON_ArrayForEach(b_element, b)
        -: 2950:            {
       20: 2951:                a_element = get_object_item(a, b_element->string, case_sensitive);
       20: 2952:                if (a_element == NULL)
        -: 2953:                {
        2: 2954:                    return false;
        -: 2955:                }
        -: 2956:
       18: 2957:                if (!cJSON_Compare(b_element, a_element, case_sensitive))
        -: 2958:                {
    #####: 2959:                    return false;
        -: 2960:                }
        -: 2961:            }
        -: 2962:
       10: 2963:            return true;
        -: 2964:        }
        -: 2965:
    #####: 2966:        default:
    #####: 2967:            return false;
        -: 2968:    }
        -: 2969:}
        -: 2970:
    #####: 2971:CJSON_PUBLIC(void *) cJSON_malloc(size_t size)
        -: 2972:{
    #####: 2973:    return global_hooks.allocate(size);
        -: 2974:}
        -: 2975:
        1: 2976:CJSON_PUBLIC(void) cJSON_free(void *object)
        -: 2977:{
        1: 2978:    global_hooks.deallocate(object);
        1: 2979:}
