        -:    0:Source:D:/CLionProjects/Cjson_withTests/Cjson_lib/cJSON.c
        -:    0:Graph:D:\CLionProjects\Cjson_withTests\cmake-build-debug\Google_tests\CMakeFiles\Google_Tests_run.dir\ConverterTests.cpp.gcno
        -:    0:Data:D:\CLionProjects\Cjson_withTests\cmake-build-debug\Google_tests\CMakeFiles\Google_Tests_run.dir\ConverterTests.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2:  Copyright (c) 2009-2017 Dave Gamble and cJSON contributors
        -:    3:
        -:    4:  Permission is hereby granted, free of charge, to any person obtaining a copy
        -:    5:  of this software and associated documentation files (the "Software"), to deal
        -:    6:  in the Software without restriction, including without limitation the rights
        -:    7:  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        -:    8:  copies of the Software, and to permit persons to whom the Software is
        -:    9:  furnished to do so, subject to the following conditions:
        -:   10:
        -:   11:  The above copyright notice and this permission notice shall be included in
        -:   12:  all copies or substantial portions of the Software.
        -:   13:
        -:   14:  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        -:   15:  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        -:   16:  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        -:   17:  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        -:   18:  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        -:   19:  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
        -:   20:  THE SOFTWARE.
        -:   21:*/
        -:   22:
        -:   23:/* cJSON */
        -:   24:/* JSON parser in C. */
        -:   25:
        -:   26:/* disable warnings about old C89 functions in MSVC */
        -:   27:#if !defined(_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER)
        -:   28:#define _CRT_SECURE_NO_DEPRECATE
        -:   29:#endif
        -:   30:
        -:   31:#ifdef __GNUC__
        -:   32:#pragma GCC visibility push(default)
        -:   33:#endif
        -:   34:#if defined(_MSC_VER)
        -:   35:#pragma warning (push)
        -:   36:/* disable warning about single line comments in system headers */
        -:   37:#pragma warning (disable : 4001)
        -:   38:#endif
        -:   39:
        -:   40:#include <string.h>
        -:   41:#include <stdio.h>
        -:   42:#include <math.h>
        -:   43:#include <stdlib.h>
        -:   44:#include <limits.h>
        -:   45:#include <ctype.h>
        -:   46:
        -:   47:#ifdef ENABLE_LOCALES
        -:   48:#include <locale.h>
        -:   49:#endif
        -:   50:
        -:   51:#if defined(_MSC_VER)
        -:   52:#pragma warning (pop)
        -:   53:#endif
        -:   54:#ifdef __GNUC__
        -:   55:#pragma GCC visibility pop
        -:   56:#endif
        -:   57:
        -:   58:#include "cJSON.h"
        -:   59:
        -:   60:/* define our own boolean type */
        -:   61:#ifdef true
        -:   62:#undef true
        -:   63:#endif
        -:   64:#define true ((cJSON_bool)1)
        -:   65:
        -:   66:#ifdef false
        -:   67:#undef false
        -:   68:#endif
        -:   69:#define false ((cJSON_bool)0)
        -:   70:
        -:   71:typedef struct {
        -:   72:    const unsigned char *json;
        -:   73:    size_t position;
        -:   74:} error;
        -:   75:static error global_error = { NULL, 0 };
        -:   76:
    #####:   77:CJSON_PUBLIC(const char *) cJSON_GetErrorPtr(void)
        -:   78:{
    #####:   79:    return (const char*) (global_error.json + global_error.position);
    %%%%%:   79-block  0
        -:   80:}
        -:   81:
    #####:   82:CJSON_PUBLIC(char *) cJSON_GetStringValue(const cJSON * const item) {
    #####:   83:    if (!cJSON_IsString(item)) {
    %%%%%:   83-block  0
    #####:   84:        return NULL;
    %%%%%:   84-block  0
        -:   85:    }
        -:   86:
    #####:   87:    return item->valuestring;
    %%%%%:   87-block  0
        -:   88:}
        -:   89:
        -:   90:/* This is a safeguard to prevent copy-pasters from using incompatible C and header files */
        -:   91:#if (CJSON_VERSION_MAJOR != 1) || (CJSON_VERSION_MINOR != 7) || (CJSON_VERSION_PATCH != 12)
        -:   92:    #error cJSON.h and cJSON.c have different versions. Make sure that both have the same.
        -:   93:#endif
        -:   94:
    #####:   95:CJSON_PUBLIC(const char*) cJSON_Version(void)
        -:   96:{
        -:   97:    static char version[15];
    #####:   98:    sprintf(version, "%i.%i.%i", CJSON_VERSION_MAJOR, CJSON_VERSION_MINOR, CJSON_VERSION_PATCH);
    %%%%%:   98-block  0
        -:   99:
    #####:  100:    return version;
        -:  101:}
        -:  102:
        -:  103:/* Case insensitive string comparison, doesn't consider two NULL pointers equal though */
    #####:  104:static int case_insensitive_strcmp(const unsigned char *string1, const unsigned char *string2)
        -:  105:{
    #####:  106:    if ((string1 == NULL) || (string2 == NULL))
    %%%%%:  106-block  0
    %%%%%:  106-block  1
        -:  107:    {
    #####:  108:        return 1;
    %%%%%:  108-block  0
        -:  109:    }
        -:  110:
    #####:  111:    if (string1 == string2)
    %%%%%:  111-block  0
        -:  112:    {
    #####:  113:        return 0;
    %%%%%:  113-block  0
        -:  114:    }
        -:  115:
    #####:  116:    for(; tolower(*string1) == tolower(*string2); (void)string1++, string2++)
    %%%%%:  116-block  0
    %%%%%:  116-block  1
        -:  117:    {
    #####:  118:        if (*string1 == '\0')
    %%%%%:  118-block  0
        -:  119:        {
    #####:  120:            return 0;
    %%%%%:  120-block  0
        -:  121:        }
        -:  122:    }
        -:  123:
    #####:  124:    return tolower(*string1) - tolower(*string2);
    %%%%%:  124-block  0
        -:  125:}
        -:  126:
        -:  127:typedef struct internal_hooks
        -:  128:{
        -:  129:    void *(CJSON_CDECL *allocate)(size_t size);
        -:  130:    void (CJSON_CDECL *deallocate)(void *pointer);
        -:  131:    void *(CJSON_CDECL *reallocate)(void *pointer, size_t size);
        -:  132:} internal_hooks;
        -:  133:
        -:  134:#if defined(_MSC_VER)
        -:  135:/* work around MSVC error C2322: '...' address of dllimport '...' is not static */
        -:  136:static void * CJSON_CDECL internal_malloc(size_t size)
        -:  137:{
        -:  138:    return malloc(size);
        -:  139:}
        -:  140:static void CJSON_CDECL internal_free(void *pointer)
        -:  141:{
        -:  142:    free(pointer);
        -:  143:}
        -:  144:static void * CJSON_CDECL internal_realloc(void *pointer, size_t size)
        -:  145:{
        -:  146:    return realloc(pointer, size);
        -:  147:}
        -:  148:#else
        -:  149:#define internal_malloc malloc
        -:  150:#define internal_free free
        -:  151:#define internal_realloc realloc
        -:  152:#endif
        -:  153:
        -:  154:/* strlen of character literals resolved at compile time */
        -:  155:#define static_strlen(string_literal) (sizeof(string_literal) - sizeof(""))
        -:  156:
        -:  157:static internal_hooks global_hooks = { internal_malloc, internal_free, internal_realloc };
        -:  158:
    #####:  159:static unsigned char* cJSON_strdup(const unsigned char* string, const internal_hooks * const hooks)
        -:  160:{
    #####:  161:    size_t length = 0;
    #####:  162:    unsigned char *copy = NULL;
        -:  163:
    #####:  164:    if (string == NULL)
    %%%%%:  164-block  0
        -:  165:    {
    #####:  166:        return NULL;
    %%%%%:  166-block  0
        -:  167:    }
        -:  168:
    #####:  169:    length = strlen((const char*)string) + sizeof("");
    #####:  170:    copy = (unsigned char*)hooks->allocate(length);
    %%%%%:  170-block  0
    #####:  171:    if (copy == NULL)
        -:  172:    {
    #####:  173:        return NULL;
    %%%%%:  173-block  0
        -:  174:    }
    #####:  175:    memcpy(copy, string, length);
        -:  176:
    #####:  177:    return copy;
    %%%%%:  177-block  0
        -:  178:}
        -:  179:
    #####:  180:CJSON_PUBLIC(void) cJSON_InitHooks(cJSON_Hooks* hooks)
        -:  181:{
    #####:  182:    if (hooks == NULL)
    %%%%%:  182-block  0
        -:  183:    {
        -:  184:        /* Reset hooks */
    #####:  185:        global_hooks.allocate = malloc;
    #####:  186:        global_hooks.deallocate = free;
    #####:  187:        global_hooks.reallocate = realloc;
    #####:  188:        return;
    %%%%%:  188-block  0
        -:  189:    }
        -:  190:
    #####:  191:    global_hooks.allocate = malloc;
    #####:  192:    if (hooks->malloc_fn != NULL)
    %%%%%:  192-block  0
        -:  193:    {
    #####:  194:        global_hooks.allocate = hooks->malloc_fn;
    %%%%%:  194-block  0
        -:  195:    }
        -:  196:
    #####:  197:    global_hooks.deallocate = free;
    #####:  198:    if (hooks->free_fn != NULL)
    %%%%%:  198-block  0
        -:  199:    {
    #####:  200:        global_hooks.deallocate = hooks->free_fn;
    %%%%%:  200-block  0
        -:  201:    }
        -:  202:
        -:  203:    /* use realloc only if both free and malloc are used */
    #####:  204:    global_hooks.reallocate = NULL;
    #####:  205:    if ((global_hooks.allocate == malloc) && (global_hooks.deallocate == free))
    %%%%%:  205-block  0
    %%%%%:  205-block  1
        -:  206:    {
    #####:  207:        global_hooks.reallocate = realloc;
    %%%%%:  207-block  0
        -:  208:    }
        -:  209:}
        -:  210:
        -:  211:/* Internal constructor. */
       28:  212:static cJSON *cJSON_New_Item(const internal_hooks * const hooks)
        -:  213:{
       28:  214:    cJSON* node = (cJSON*)hooks->allocate(sizeof(cJSON));
       28:  214-block  0
       28:  215:    if (node)
        -:  216:    {
       28:  217:        memset(node, '\0', sizeof(cJSON));
       28:  217-block  0
        -:  218:    }
        -:  219:
       28:  220:    return node;
       28:  220-block  0
        -:  221:}
        -:  222:
        -:  223:/* Delete a cJSON structure. */
       12:  224:CJSON_PUBLIC(void) cJSON_Delete(cJSON *item)
        -:  225:{
       12:  226:    cJSON *next = NULL;
       12:  226-block  0
       40:  227:    while (item != NULL)
       40:  227-block  0
        -:  228:    {
       28:  229:        next = item->next;
       28:  230:        if (!(item->type & cJSON_IsReference) && (item->child != NULL))
       28:  230-block  0
       28:  230-block  1
        -:  231:        {
    #####:  232:            cJSON_Delete(item->child);
    %%%%%:  232-block  0
        -:  233:        }
       28:  234:        if (!(item->type & cJSON_IsReference) && (item->valuestring != NULL))
       28:  234-block  0
       28:  234-block  1
        -:  235:        {
        4:  236:            global_hooks.deallocate(item->valuestring);
        4:  236-block  0
        -:  237:        }
       28:  238:        if (!(item->type & cJSON_StringIsConst) && (item->string != NULL))
       28:  238-block  0
       28:  238-block  1
        -:  239:        {
       14:  240:            global_hooks.deallocate(item->string);
       14:  240-block  0
        -:  241:        }
       28:  242:        global_hooks.deallocate(item);
       28:  242-block  0
       28:  243:        item = next;
        -:  244:    }
       12:  245:}
        -:  246:
        -:  247:/* get the decimal point character of the current locale */
       28:  248:static unsigned char get_decimal_point(void)
        -:  249:{
        -:  250:#ifdef ENABLE_LOCALES
        -:  251:    struct lconv *lconv = localeconv();
        -:  252:    return (unsigned char) lconv->decimal_point[0];
        -:  253:#else
       28:  254:    return '.';
       28:  254-block  0
        -:  255:#endif
        -:  256:}
        -:  257:
        -:  258:typedef struct
        -:  259:{
        -:  260:    const unsigned char *content;
        -:  261:    size_t length;
        -:  262:    size_t offset;
        -:  263:    size_t depth; /* How deeply nested (in arrays/objects) is the input at the current offset. */
        -:  264:    internal_hooks hooks;
        -:  265:} parse_buffer;
        -:  266:
        -:  267:/* check if the given size is left to read in a given parse buffer (starting with 1) */
        -:  268:#define can_read(buffer, size) ((buffer != NULL) && (((buffer)->offset + size) <= (buffer)->length))
        -:  269:/* check if the buffer can be accessed at the given index (starting with 0) */
        -:  270:#define can_access_at_index(buffer, index) ((buffer != NULL) && (((buffer)->offset + index) < (buffer)->length))
        -:  271:#define cannot_access_at_index(buffer, index) (!can_access_at_index(buffer, index))
        -:  272:/* get a pointer to the buffer at the position */
        -:  273:#define buffer_at_offset(buffer) ((buffer)->content + (buffer)->offset)
        -:  274:
        -:  275:/* Parse the input text to generate a number, and populate the result into item. */
       28:  276:static cJSON_bool parse_number(cJSON * const item, parse_buffer * const input_buffer)
        -:  277:{
       28:  278:    double number = 0;
       28:  279:    unsigned char *after_end = NULL;
        -:  280:    unsigned char number_c_string[64];
       28:  281:    unsigned char decimal_point = get_decimal_point();
       28:  281-block  0
       28:  282:    size_t i = 0;
        -:  283:
       28:  284:    if ((input_buffer == NULL) || (input_buffer->content == NULL))
       28:  284-block  0
        -:  285:    {
    #####:  286:        return false;
    %%%%%:  286-block  0
        -:  287:    }
        -:  288:
        -:  289:    /* copy the number into a temporary buffer and replace '.' with the decimal point
        -:  290:     * of the current locale (for strtod)
        -:  291:     * This also takes care of '\0' not necessarily being available for marking the end of the input */
      145:  292:    for (i = 0; (i < (sizeof(number_c_string) - 1)) && can_access_at_index(input_buffer, i); i++)
       28:  292-block  0
      145:  292-block  1
      145:  292-block  2
      145:  292-block  3
      117:  292-block  4
        -:  293:    {
      145:  294:        switch (buffer_at_offset(input_buffer)[i])
      145:  294-block  0
        -:  295:        {
      114:  296:            case '0':
        -:  297:            case '1':
        -:  298:            case '2':
        -:  299:            case '3':
        -:  300:            case '4':
        -:  301:            case '5':
        -:  302:            case '6':
        -:  303:            case '7':
        -:  304:            case '8':
        -:  305:            case '9':
        -:  306:            case '+':
        -:  307:            case '-':
        -:  308:            case 'e':
        -:  309:            case 'E':
      114:  310:                number_c_string[i] = buffer_at_offset(input_buffer)[i];
      114:  311:                break;
      114:  311-block  0
        -:  312:
        3:  313:            case '.':
        3:  314:                number_c_string[i] = decimal_point;
        3:  315:                break;
        3:  315-block  0
        -:  316:
       28:  317:            default:
       28:  318:                goto loop_end;
       28:  318-block  0
        -:  319:        }
        -:  320:    }
    #####:  321:loop_end:
    %%%%%:  321-block  0
    %%%%%:  321-block  1
    %%%%%:  321-block  2
       28:  322:    number_c_string[i] = '\0';
        -:  323:
       28:  324:    number = strtod((const char*)number_c_string, (char**)&after_end);
       28:  324-block  0
       28:  325:    if (number_c_string == after_end)
        -:  326:    {
    #####:  327:        return false; /* parse_error */
    %%%%%:  327-block  0
        -:  328:    }
        -:  329:
       28:  330:    item->valuedouble = number;
        -:  331:
        -:  332:    /* use saturation in case of overflow */
       28:  333:    if (number >= INT_MAX)
       28:  333-block  0
        -:  334:    {
        2:  335:        item->valueint = INT_MAX;
        2:  335-block  0
        -:  336:    }
       26:  337:    else if (number <= (double)INT_MIN)
       26:  337-block  0
        -:  338:    {
        3:  339:        item->valueint = INT_MIN;
        3:  339-block  0
        -:  340:    }
        -:  341:    else
        -:  342:    {
       23:  343:        item->valueint = (int)number;
       23:  343-block  0
        -:  344:    }
        -:  345:
       28:  346:    item->type = cJSON_Number;
        -:  347:
       28:  348:    input_buffer->offset += (size_t)(after_end - number_c_string);
       28:  349:    return true;
       28:  349-block  0
        -:  350:}
        -:  351:
        -:  352:/* don't ask me, but the original cJSON_SetNumberValue returns an integer or double */
    #####:  353:CJSON_PUBLIC(double) cJSON_SetNumberHelper(cJSON *object, double number)
        -:  354:{
    #####:  355:    if (number >= INT_MAX)
    %%%%%:  355-block  0
        -:  356:    {
    #####:  357:        object->valueint = INT_MAX;
    %%%%%:  357-block  0
        -:  358:    }
    #####:  359:    else if (number <= (double)INT_MIN)
    %%%%%:  359-block  0
        -:  360:    {
    #####:  361:        object->valueint = INT_MIN;
    %%%%%:  361-block  0
        -:  362:    }
        -:  363:    else
        -:  364:    {
    #####:  365:        object->valueint = (int)number;
    %%%%%:  365-block  0
        -:  366:    }
        -:  367:
    #####:  368:    return object->valuedouble = number;
    %%%%%:  368-block  0
        -:  369:}
        -:  370:
        -:  371:typedef struct
        -:  372:{
        -:  373:    unsigned char *buffer;
        -:  374:    size_t length;
        -:  375:    size_t offset;
        -:  376:    size_t depth; /* current nesting depth (for formatted printing) */
        -:  377:    cJSON_bool noalloc;
        -:  378:    cJSON_bool format; /* is this print a formatted print */
        -:  379:    internal_hooks hooks;
        -:  380:} printbuffer;
        -:  381:
        -:  382:/* realloc printbuffer if necessary to have at least "needed" bytes more */
    #####:  383:static unsigned char* ensure(printbuffer * const p, size_t needed)
        -:  384:{
    #####:  385:    unsigned char *newbuffer = NULL;
    #####:  386:    size_t newsize = 0;
        -:  387:
    #####:  388:    if ((p == NULL) || (p->buffer == NULL))
    %%%%%:  388-block  0
    %%%%%:  388-block  1
        -:  389:    {
    #####:  390:        return NULL;
    %%%%%:  390-block  0
        -:  391:    }
        -:  392:
    #####:  393:    if ((p->length > 0) && (p->offset >= p->length))
    %%%%%:  393-block  0
    %%%%%:  393-block  1
        -:  394:    {
        -:  395:        /* make sure that offset is valid */
    #####:  396:        return NULL;
    %%%%%:  396-block  0
        -:  397:    }
        -:  398:
    #####:  399:    if (needed > INT_MAX)
    %%%%%:  399-block  0
        -:  400:    {
        -:  401:        /* sizes bigger than INT_MAX are currently not supported */
    #####:  402:        return NULL;
    %%%%%:  402-block  0
        -:  403:    }
        -:  404:
    #####:  405:    needed += p->offset + 1;
    #####:  406:    if (needed <= p->length)
    %%%%%:  406-block  0
        -:  407:    {
    #####:  408:        return p->buffer + p->offset;
    %%%%%:  408-block  0
        -:  409:    }
        -:  410:
    #####:  411:    if (p->noalloc) {
    %%%%%:  411-block  0
    #####:  412:        return NULL;
    %%%%%:  412-block  0
        -:  413:    }
        -:  414:
        -:  415:    /* calculate new buffer size */
    #####:  416:    if (needed > (INT_MAX / 2))
    %%%%%:  416-block  0
        -:  417:    {
        -:  418:        /* overflow of int, use INT_MAX if possible */
    #####:  419:        if (needed <= INT_MAX)
    %%%%%:  419-block  0
        -:  420:        {
    #####:  421:            newsize = INT_MAX;
    %%%%%:  421-block  0
        -:  422:        }
        -:  423:        else
        -:  424:        {
    #####:  425:            return NULL;
    %%%%%:  425-block  0
        -:  426:        }
        -:  427:    }
        -:  428:    else
        -:  429:    {
    #####:  430:        newsize = needed * 2;
    %%%%%:  430-block  0
        -:  431:    }
        -:  432:
    #####:  433:    if (p->hooks.reallocate != NULL)
    %%%%%:  433-block  0
        -:  434:    {
        -:  435:        /* reallocate with realloc if available */
    #####:  436:        newbuffer = (unsigned char*)p->hooks.reallocate(p->buffer, newsize);
    %%%%%:  436-block  0
    #####:  437:        if (newbuffer == NULL)
        -:  438:        {
    #####:  439:            p->hooks.deallocate(p->buffer);
    %%%%%:  439-block  0
    #####:  440:            p->length = 0;
    #####:  441:            p->buffer = NULL;
        -:  442:
    #####:  443:            return NULL;
        -:  444:        }
        -:  445:    }
        -:  446:    else
        -:  447:    {
        -:  448:        /* otherwise reallocate manually */
    #####:  449:        newbuffer = (unsigned char*)p->hooks.allocate(newsize);
    %%%%%:  449-block  0
    #####:  450:        if (!newbuffer)
        -:  451:        {
    #####:  452:            p->hooks.deallocate(p->buffer);
    %%%%%:  452-block  0
    #####:  453:            p->length = 0;
    #####:  454:            p->buffer = NULL;
        -:  455:
    #####:  456:            return NULL;
        -:  457:        }
    #####:  458:        if (newbuffer)
    %%%%%:  458-block  0
        -:  459:        {
    #####:  460:            memcpy(newbuffer, p->buffer, p->offset + 1);
    %%%%%:  460-block  0
        -:  461:        }
    #####:  462:        p->hooks.deallocate(p->buffer);
    %%%%%:  462-block  0
        -:  463:    }
    #####:  464:    p->length = newsize;
    #####:  465:    p->buffer = newbuffer;
        -:  466:
    #####:  467:    return newbuffer + p->offset;
    %%%%%:  467-block  0
        -:  468:}
        -:  469:
        -:  470:/* calculate the new length of the string in a printbuffer and update the offset */
    #####:  471:static void update_offset(printbuffer * const buffer)
        -:  472:{
    #####:  473:    const unsigned char *buffer_pointer = NULL;
    #####:  474:    if ((buffer == NULL) || (buffer->buffer == NULL))
    %%%%%:  474-block  0
    %%%%%:  474-block  1
        -:  475:    {
    #####:  476:        return;
    %%%%%:  476-block  0
        -:  477:    }
    #####:  478:    buffer_pointer = buffer->buffer + buffer->offset;
        -:  479:
    #####:  480:    buffer->offset += strlen((const char*)buffer_pointer);
    %%%%%:  480-block  0
        -:  481:}
        -:  482:
        -:  483:/* securely comparison of floating-point variables */
    #####:  484:static cJSON_bool compare_double(double a, double b)
        -:  485:{
    #####:  486:    return (fabs(a - b) <= CJSON_DOUBLE_PRECISION);
    %%%%%:  486-block  0
        -:  487:}
        -:  488:
        -:  489:/* Render the number nicely from the given item into a string. */
    #####:  490:static cJSON_bool print_number(const cJSON * const item, printbuffer * const output_buffer)
        -:  491:{
    #####:  492:    unsigned char *output_pointer = NULL;
    #####:  493:    double d = item->valuedouble;
    #####:  494:    int length = 0;
    #####:  495:    size_t i = 0;
    #####:  496:    unsigned char number_buffer[26] = {0}; /* temporary buffer to print the number into */
    #####:  497:    unsigned char decimal_point = get_decimal_point();
    %%%%%:  497-block  0
    #####:  498:    double test = 0.0;
        -:  499:
    #####:  500:    if (output_buffer == NULL)
        -:  501:    {
    #####:  502:        return false;
    %%%%%:  502-block  0
        -:  503:    }
        -:  504:
        -:  505:    /* This checks for NaN and Infinity */
    #####:  506:    if (!compare_double(d * 0, 0))
    %%%%%:  506-block  0
        -:  507:    {
    #####:  508:        length = sprintf((char*)number_buffer, "null");
    %%%%%:  508-block  0
        -:  509:    }
        -:  510:    else
        -:  511:    {
        -:  512:        /* Try 15 decimal places of precision to avoid nonsignificant nonzero digits */
    #####:  513:        length = sprintf((char*)number_buffer, "%1.15g", d);
    %%%%%:  513-block  0
        -:  514:
        -:  515:        /* Check whether the original double can be recovered */
    #####:  516:        if ((sscanf((char*)number_buffer, "%lg", &test) != 1) || !compare_double((double)test, d))
    %%%%%:  516-block  0
    %%%%%:  516-block  1
    %%%%%:  516-block  2
    %%%%%:  516-block  3
    %%%%%:  516-block  4
        -:  517:        {
        -:  518:            /* If not, print with 17 decimal places of precision */
    #####:  519:            length = sprintf((char*)number_buffer, "%1.17g", d);
    %%%%%:  519-block  0
        -:  520:        }
        -:  521:    }
        -:  522:
        -:  523:    /* sprintf failed or buffer overrun occurred */
    #####:  524:    if ((length < 0) || (length > (int)(sizeof(number_buffer) - 1)))
    %%%%%:  524-block  0
    %%%%%:  524-block  1
        -:  525:    {
    #####:  526:        return false;
    %%%%%:  526-block  0
        -:  527:    }
        -:  528:
        -:  529:    /* reserve appropriate space in the output */
    #####:  530:    output_pointer = ensure(output_buffer, (size_t)length + sizeof(""));
    %%%%%:  530-block  0
    #####:  531:    if (output_pointer == NULL)
    %%%%%:  531-block  0
        -:  532:    {
    #####:  533:        return false;
    %%%%%:  533-block  0
        -:  534:    }
        -:  535:
        -:  536:    /* copy the printed number to the output and replace locale
        -:  537:     * dependent decimal point with '.' */
    #####:  538:    for (i = 0; i < ((size_t)length); i++)
    %%%%%:  538-block  0
    %%%%%:  538-block  1
    %%%%%:  538-block  2
        -:  539:    {
    #####:  540:        if (number_buffer[i] == decimal_point)
    %%%%%:  540-block  0
        -:  541:        {
    #####:  542:            output_pointer[i] = '.';
    #####:  543:            continue;
    %%%%%:  543-block  0
        -:  544:        }
        -:  545:
    #####:  546:        output_pointer[i] = number_buffer[i];
    %%%%%:  546-block  0
        -:  547:    }
    #####:  548:    output_pointer[i] = '\0';
        -:  549:
    #####:  550:    output_buffer->offset += (size_t)length;
        -:  551:
    #####:  552:    return true;
    %%%%%:  552-block  0
        -:  553:}
        -:  554:
        -:  555:/* parse 4 digit hexadecimal number */
    #####:  556:static unsigned parse_hex4(const unsigned char * const input)
        -:  557:{
    #####:  558:    unsigned int h = 0;
    #####:  559:    size_t i = 0;
        -:  560:
    #####:  561:    for (i = 0; i < 4; i++)
    %%%%%:  561-block  0
    %%%%%:  561-block  1
    %%%%%:  561-block  2
        -:  562:    {
        -:  563:        /* parse digit */
    #####:  564:        if ((input[i] >= '0') && (input[i] <= '9'))
    %%%%%:  564-block  0
    %%%%%:  564-block  1
        -:  565:        {
    #####:  566:            h += (unsigned int) input[i] - '0';
    %%%%%:  566-block  0
        -:  567:        }
    #####:  568:        else if ((input[i] >= 'A') && (input[i] <= 'F'))
    %%%%%:  568-block  0
    %%%%%:  568-block  1
        -:  569:        {
    #####:  570:            h += (unsigned int) 10 + input[i] - 'A';
    %%%%%:  570-block  0
        -:  571:        }
    #####:  572:        else if ((input[i] >= 'a') && (input[i] <= 'f'))
    %%%%%:  572-block  0
    %%%%%:  572-block  1
        -:  573:        {
    #####:  574:            h += (unsigned int) 10 + input[i] - 'a';
    %%%%%:  574-block  0
        -:  575:        }
        -:  576:        else /* invalid */
        -:  577:        {
    #####:  578:            return 0;
    %%%%%:  578-block  0
        -:  579:        }
        -:  580:
    #####:  581:        if (i < 3)
    %%%%%:  581-block  0
        -:  582:        {
        -:  583:            /* shift left to make place for the next nibble */
    #####:  584:            h = h << 4;
    %%%%%:  584-block  0
        -:  585:        }
        -:  586:    }
        -:  587:
    #####:  588:    return h;
    %%%%%:  588-block  0
        -:  589:}
        -:  590:
        -:  591:/* converts a UTF-16 literal to UTF-8
        -:  592: * A literal can be one or two sequences of the form \uXXXX */
    #####:  593:static unsigned char utf16_literal_to_utf8(const unsigned char * const input_pointer, const unsigned char * const input_end, unsigned char **output_pointer)
        -:  594:{
    #####:  595:    long unsigned int codepoint = 0;
    #####:  596:    unsigned int first_code = 0;
    #####:  597:    const unsigned char *first_sequence = input_pointer;
    #####:  598:    unsigned char utf8_length = 0;
    #####:  599:    unsigned char utf8_position = 0;
    #####:  600:    unsigned char sequence_length = 0;
    #####:  601:    unsigned char first_byte_mark = 0;
        -:  602:
    #####:  603:    if ((input_end - first_sequence) < 6)
    %%%%%:  603-block  0
        -:  604:    {
        -:  605:        /* input ends unexpectedly */
    #####:  606:        goto fail;
    %%%%%:  606-block  0
        -:  607:    }
        -:  608:
        -:  609:    /* get the first utf16 sequence */
    #####:  610:    first_code = parse_hex4(first_sequence + 2);
    %%%%%:  610-block  0
        -:  611:
        -:  612:    /* check that the code is valid */
    #####:  613:    if (((first_code >= 0xDC00) && (first_code <= 0xDFFF)))
    %%%%%:  613-block  0
        -:  614:    {
    #####:  615:        goto fail;
    %%%%%:  615-block  0
        -:  616:    }
        -:  617:
        -:  618:    /* UTF16 surrogate pair */
    #####:  619:    if ((first_code >= 0xD800) && (first_code <= 0xDBFF))
    %%%%%:  619-block  0
    %%%%%:  619-block  1
        -:  620:    {
    #####:  621:        const unsigned char *second_sequence = first_sequence + 6;
    #####:  622:        unsigned int second_code = 0;
    #####:  623:        sequence_length = 12; /* \uXXXX\uXXXX */
        -:  624:
    #####:  625:        if ((input_end - second_sequence) < 6)
    %%%%%:  625-block  0
        -:  626:        {
        -:  627:            /* input ends unexpectedly */
    #####:  628:            goto fail;
    %%%%%:  628-block  0
        -:  629:        }
        -:  630:
    #####:  631:        if ((second_sequence[0] != '\\') || (second_sequence[1] != 'u'))
    %%%%%:  631-block  0
    %%%%%:  631-block  1
        -:  632:        {
        -:  633:            /* missing second half of the surrogate pair */
    #####:  634:            goto fail;
    %%%%%:  634-block  0
        -:  635:        }
        -:  636:
        -:  637:        /* get the second utf16 sequence */
    #####:  638:        second_code = parse_hex4(second_sequence + 2);
    %%%%%:  638-block  0
        -:  639:        /* check that the code is valid */
    #####:  640:        if ((second_code < 0xDC00) || (second_code > 0xDFFF))
    %%%%%:  640-block  0
        -:  641:        {
        -:  642:            /* invalid second half of the surrogate pair */
    #####:  643:            goto fail;
    %%%%%:  643-block  0
        -:  644:        }
        -:  645:
        -:  646:
        -:  647:        /* calculate the unicode codepoint from the surrogate pair */
    #####:  648:        codepoint = 0x10000 + (((first_code & 0x3FF) << 10) | (second_code & 0x3FF));
    %%%%%:  648-block  0
        -:  649:    }
        -:  650:    else
        -:  651:    {
    #####:  652:        sequence_length = 6; /* \uXXXX */
    #####:  653:        codepoint = first_code;
    %%%%%:  653-block  0
        -:  654:    }
        -:  655:
        -:  656:    /* encode as UTF-8
        -:  657:     * takes at maximum 4 bytes to encode:
        -:  658:     * 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx */
    #####:  659:    if (codepoint < 0x80)
    %%%%%:  659-block  0
        -:  660:    {
        -:  661:        /* normal ascii, encoding 0xxxxxxx */
    #####:  662:        utf8_length = 1;
    %%%%%:  662-block  0
        -:  663:    }
    #####:  664:    else if (codepoint < 0x800)
    %%%%%:  664-block  0
        -:  665:    {
        -:  666:        /* two bytes, encoding 110xxxxx 10xxxxxx */
    #####:  667:        utf8_length = 2;
    #####:  668:        first_byte_mark = 0xC0; /* 11000000 */
    %%%%%:  668-block  0
        -:  669:    }
    #####:  670:    else if (codepoint < 0x10000)
    %%%%%:  670-block  0
        -:  671:    {
        -:  672:        /* three bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx */
    #####:  673:        utf8_length = 3;
    #####:  674:        first_byte_mark = 0xE0; /* 11100000 */
    %%%%%:  674-block  0
        -:  675:    }
    #####:  676:    else if (codepoint <= 0x10FFFF)
    %%%%%:  676-block  0
        -:  677:    {
        -:  678:        /* four bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx 10xxxxxx */
    #####:  679:        utf8_length = 4;
    #####:  680:        first_byte_mark = 0xF0; /* 11110000 */
    %%%%%:  680-block  0
        -:  681:    }
        -:  682:    else
        -:  683:    {
        -:  684:        /* invalid unicode codepoint */
    #####:  685:        goto fail;
    %%%%%:  685-block  0
        -:  686:    }
        -:  687:
        -:  688:    /* encode as utf8 */
    #####:  689:    for (utf8_position = (unsigned char)(utf8_length - 1); utf8_position > 0; utf8_position--)
    %%%%%:  689-block  0
    %%%%%:  689-block  1
        -:  690:    {
        -:  691:        /* 10xxxxxx */
    #####:  692:        (*output_pointer)[utf8_position] = (unsigned char)((codepoint | 0x80) & 0xBF);
    #####:  693:        codepoint >>= 6;
    %%%%%:  693-block  0
        -:  694:    }
        -:  695:    /* encode first byte */
    #####:  696:    if (utf8_length > 1)
    %%%%%:  696-block  0
        -:  697:    {
    #####:  698:        (*output_pointer)[0] = (unsigned char)((codepoint | first_byte_mark) & 0xFF);
    %%%%%:  698-block  0
        -:  699:    }
        -:  700:    else
        -:  701:    {
    #####:  702:        (*output_pointer)[0] = (unsigned char)(codepoint & 0x7F);
    %%%%%:  702-block  0
        -:  703:    }
        -:  704:
    #####:  705:    *output_pointer += utf8_length;
        -:  706:
    #####:  707:    return sequence_length;
    %%%%%:  707-block  0
        -:  708:
    #####:  709:fail:
    #####:  710:    return 0;
    %%%%%:  710-block  0
        -:  711:}
        -:  712:
        -:  713:/* Parse the input text into an unescaped cinput, and populate item. */
       18:  714:static cJSON_bool parse_string(cJSON * const item, parse_buffer * const input_buffer)
        -:  715:{
       18:  716:    const unsigned char *input_pointer = buffer_at_offset(input_buffer) + 1;
       18:  717:    const unsigned char *input_end = buffer_at_offset(input_buffer) + 1;
       18:  718:    unsigned char *output_pointer = NULL;
       18:  719:    unsigned char *output = NULL;
        -:  720:
        -:  721:    /* not a string */
       18:  722:    if (buffer_at_offset(input_buffer)[0] != '\"')
       18:  722-block  0
        -:  723:    {
    #####:  724:        goto fail;
    %%%%%:  724-block  0
        -:  725:    }
        -:  726:
        -:  727:    {
        -:  728:        /* calculate approximate size of the output (overestimate) */
       18:  729:        size_t allocation_length = 0;
       18:  730:        size_t skipped_bytes = 0;
       18:  730-block  0
      100:  731:        while (((size_t)(input_end - input_buffer->content) < input_buffer->length) && (*input_end != '\"'))
      100:  731-block  0
      100:  731-block  1
        -:  732:        {
        -:  733:            /* is escape sequence */
       82:  734:            if (input_end[0] == '\\')
       82:  734-block  0
        -:  735:            {
    #####:  736:                if ((size_t)(input_end + 1 - input_buffer->content) >= input_buffer->length)
    %%%%%:  736-block  0
        -:  737:                {
        -:  738:                    /* prevent buffer overflow when last input character is a backslash */
    #####:  739:                    goto fail;
    %%%%%:  739-block  0
        -:  740:                }
    #####:  741:                skipped_bytes++;
    #####:  742:                input_end++;
    %%%%%:  742-block  0
        -:  743:            }
       82:  744:            input_end++;
       82:  744-block  0
        -:  745:        }
       18:  746:        if (((size_t)(input_end - input_buffer->content) >= input_buffer->length) || (*input_end != '\"'))
       18:  746-block  0
       18:  746-block  1
        -:  747:        {
    #####:  748:            goto fail; /* string ended unexpectedly */
    %%%%%:  748-block  0
        -:  749:        }
        -:  750:
        -:  751:        /* This is at most how much we need for the output */
       18:  752:        allocation_length = (size_t) (input_end - buffer_at_offset(input_buffer)) - skipped_bytes;
       18:  753:        output = (unsigned char*)input_buffer->hooks.allocate(allocation_length + sizeof(""));
       18:  753-block  0
       18:  754:        if (output == NULL)
       18:  754-block  0
        -:  755:        {
    #####:  756:            goto fail; /* allocation failure */
    %%%%%:  756-block  0
        -:  757:        }
        -:  758:    }
        -:  759:
       18:  760:    output_pointer = output;
       18:  760-block  0
        -:  761:    /* loop through the string literal */
      100:  762:    while (input_pointer < input_end)
      100:  762-block  0
       82:  762-block  1
        -:  763:    {
       82:  764:        if (*input_pointer != '\\')
       82:  764-block  0
        -:  765:        {
       82:  766:            *output_pointer++ = *input_pointer++;
       82:  766-block  0
        -:  767:        }
        -:  768:        /* escape sequence */
        -:  769:        else
        -:  770:        {
    #####:  771:            unsigned char sequence_length = 2;
    #####:  772:            if ((input_end - input_pointer) < 1)
    %%%%%:  772-block  0
        -:  773:            {
    #####:  774:                goto fail;
    %%%%%:  774-block  0
        -:  775:            }
        -:  776:
    #####:  777:            switch (input_pointer[1])
    %%%%%:  777-block  0
        -:  778:            {
    #####:  779:                case 'b':
    #####:  780:                    *output_pointer++ = '\b';
    #####:  781:                    break;
    %%%%%:  781-block  0
    #####:  782:                case 'f':
    #####:  783:                    *output_pointer++ = '\f';
    #####:  784:                    break;
    %%%%%:  784-block  0
    #####:  785:                case 'n':
    #####:  786:                    *output_pointer++ = '\n';
    #####:  787:                    break;
    %%%%%:  787-block  0
    #####:  788:                case 'r':
    #####:  789:                    *output_pointer++ = '\r';
    #####:  790:                    break;
    %%%%%:  790-block  0
    #####:  791:                case 't':
    #####:  792:                    *output_pointer++ = '\t';
    #####:  793:                    break;
    %%%%%:  793-block  0
    #####:  794:                case '\"':
        -:  795:                case '\\':
        -:  796:                case '/':
    #####:  797:                    *output_pointer++ = input_pointer[1];
    #####:  798:                    break;
    %%%%%:  798-block  0
        -:  799:
        -:  800:                /* UTF-16 literal */
    #####:  801:                case 'u':
    #####:  802:                    sequence_length = utf16_literal_to_utf8(input_pointer, input_end, &output_pointer);
    %%%%%:  802-block  0
    #####:  803:                    if (sequence_length == 0)
        -:  804:                    {
        -:  805:                        /* failed to convert UTF16-literal to UTF-8 */
    #####:  806:                        goto fail;
    %%%%%:  806-block  0
        -:  807:                    }
    #####:  808:                    break;
    %%%%%:  808-block  0
        -:  809:
    #####:  810:                default:
    #####:  811:                    goto fail;
    %%%%%:  811-block  0
        -:  812:            }
    #####:  813:            input_pointer += sequence_length;
    %%%%%:  813-block  0
        -:  814:        }
        -:  815:    }
        -:  816:
        -:  817:    /* zero terminate the output */
       18:  818:    *output_pointer = '\0';
        -:  819:
       18:  820:    item->type = cJSON_String;
       18:  821:    item->valuestring = (char*)output;
        -:  822:
       18:  823:    input_buffer->offset = (size_t) (input_end - input_buffer->content);
       18:  824:    input_buffer->offset++;
        -:  825:
       18:  826:    return true;
       18:  826-block  0
        -:  827:
    #####:  828:fail:
    #####:  829:    if (output != NULL)
    %%%%%:  829-block  0
        -:  830:    {
    #####:  831:        input_buffer->hooks.deallocate(output);
    %%%%%:  831-block  0
        -:  832:    }
        -:  833:
    #####:  834:    if (input_pointer != NULL)
    %%%%%:  834-block  0
        -:  835:    {
    #####:  836:        input_buffer->offset = (size_t)(input_pointer - input_buffer->content);
    %%%%%:  836-block  0
        -:  837:    }
        -:  838:
    #####:  839:    return false;
    %%%%%:  839-block  0
        -:  840:}
        -:  841:
        -:  842:/* Render the cstring provided to an escaped version that can be printed. */
    #####:  843:static cJSON_bool print_string_ptr(const unsigned char * const input, printbuffer * const output_buffer)
        -:  844:{
    #####:  845:    const unsigned char *input_pointer = NULL;
    #####:  846:    unsigned char *output = NULL;
    #####:  847:    unsigned char *output_pointer = NULL;
    #####:  848:    size_t output_length = 0;
        -:  849:    /* numbers of additional characters needed for escaping */
    #####:  850:    size_t escape_characters = 0;
        -:  851:
    #####:  852:    if (output_buffer == NULL)
    %%%%%:  852-block  0
        -:  853:    {
    #####:  854:        return false;
    %%%%%:  854-block  0
        -:  855:    }
        -:  856:
        -:  857:    /* empty string */
    #####:  858:    if (input == NULL)
    %%%%%:  858-block  0
        -:  859:    {
    #####:  860:        output = ensure(output_buffer, sizeof("\"\""));
    %%%%%:  860-block  0
    #####:  861:        if (output == NULL)
        -:  862:        {
    #####:  863:            return false;
    %%%%%:  863-block  0
        -:  864:        }
    #####:  865:        strcpy((char*)output, "\"\"");
        -:  866:
    #####:  867:        return true;
    %%%%%:  867-block  0
        -:  868:    }
        -:  869:
        -:  870:    /* set "flag" to 1 if something needs to be escaped */
    #####:  871:    for (input_pointer = input; *input_pointer; input_pointer++)
    %%%%%:  871-block  0
    %%%%%:  871-block  1
    %%%%%:  871-block  2
        -:  872:    {
    #####:  873:        switch (*input_pointer)
    %%%%%:  873-block  0
        -:  874:        {
    #####:  875:            case '\"':
        -:  876:            case '\\':
        -:  877:            case '\b':
        -:  878:            case '\f':
        -:  879:            case '\n':
        -:  880:            case '\r':
        -:  881:            case '\t':
        -:  882:                /* one character escape sequence */
    #####:  883:                escape_characters++;
    #####:  884:                break;
    %%%%%:  884-block  0
    #####:  885:            default:
    #####:  886:                if (*input_pointer < 32)
    %%%%%:  886-block  0
        -:  887:                {
        -:  888:                    /* UTF-16 escape sequence uXXXX */
    #####:  889:                    escape_characters += 5;
    %%%%%:  889-block  0
        -:  890:                }
    #####:  891:                break;
    %%%%%:  891-block  0
        -:  892:        }
        -:  893:    }
    #####:  894:    output_length = (size_t)(input_pointer - input) + escape_characters;
        -:  895:
    #####:  896:    output = ensure(output_buffer, output_length + sizeof("\"\""));
    %%%%%:  896-block  0
    #####:  897:    if (output == NULL)
        -:  898:    {
    #####:  899:        return false;
    %%%%%:  899-block  0
        -:  900:    }
        -:  901:
        -:  902:    /* no characters have to be escaped */
    #####:  903:    if (escape_characters == 0)
    %%%%%:  903-block  0
        -:  904:    {
    #####:  905:        output[0] = '\"';
    #####:  906:        memcpy(output + 1, input, output_length);
    #####:  907:        output[output_length + 1] = '\"';
    #####:  908:        output[output_length + 2] = '\0';
        -:  909:
    #####:  910:        return true;
    %%%%%:  910-block  0
        -:  911:    }
        -:  912:
    #####:  913:    output[0] = '\"';
    #####:  914:    output_pointer = output + 1;
        -:  915:    /* copy the string */
    #####:  916:    for (input_pointer = input; *input_pointer != '\0'; (void)input_pointer++, output_pointer++)
    %%%%%:  916-block  0
    %%%%%:  916-block  1
    %%%%%:  916-block  2
        -:  917:    {
    #####:  918:        if ((*input_pointer > 31) && (*input_pointer != '\"') && (*input_pointer != '\\'))
    %%%%%:  918-block  0
    %%%%%:  918-block  1
    %%%%%:  918-block  2
        -:  919:        {
        -:  920:            /* normal character, copy */
    #####:  921:            *output_pointer = *input_pointer;
    %%%%%:  921-block  0
        -:  922:        }
        -:  923:        else
        -:  924:        {
        -:  925:            /* character needs to be escaped */
    #####:  926:            *output_pointer++ = '\\';
    #####:  927:            switch (*input_pointer)
    %%%%%:  927-block  0
        -:  928:            {
    #####:  929:                case '\\':
    #####:  930:                    *output_pointer = '\\';
    #####:  931:                    break;
    %%%%%:  931-block  0
    #####:  932:                case '\"':
    #####:  933:                    *output_pointer = '\"';
    #####:  934:                    break;
    %%%%%:  934-block  0
    #####:  935:                case '\b':
    #####:  936:                    *output_pointer = 'b';
    #####:  937:                    break;
    %%%%%:  937-block  0
    #####:  938:                case '\f':
    #####:  939:                    *output_pointer = 'f';
    #####:  940:                    break;
    %%%%%:  940-block  0
    #####:  941:                case '\n':
    #####:  942:                    *output_pointer = 'n';
    #####:  943:                    break;
    %%%%%:  943-block  0
    #####:  944:                case '\r':
    #####:  945:                    *output_pointer = 'r';
    #####:  946:                    break;
    %%%%%:  946-block  0
    #####:  947:                case '\t':
    #####:  948:                    *output_pointer = 't';
    #####:  949:                    break;
    %%%%%:  949-block  0
    #####:  950:                default:
        -:  951:                    /* escape and print as unicode codepoint */
    #####:  952:                    sprintf((char*)output_pointer, "u%04x", *input_pointer);
    %%%%%:  952-block  0
    #####:  953:                    output_pointer += 4;
    #####:  954:                    break;
        -:  955:            }
        -:  956:        }
        -:  957:    }
    #####:  958:    output[output_length + 1] = '\"';
    #####:  959:    output[output_length + 2] = '\0';
        -:  960:
    #####:  961:    return true;
    %%%%%:  961-block  0
        -:  962:}
        -:  963:
        -:  964:/* Invoke print_string_ptr (which is useful) on an item. */
    #####:  965:static cJSON_bool print_string(const cJSON * const item, printbuffer * const p)
        -:  966:{
    #####:  967:    return print_string_ptr((unsigned char*)item->valuestring, p);
    %%%%%:  967-block  0
        -:  968:}
        -:  969:
        -:  970:/* Predeclare these prototypes. */
        -:  971:static cJSON_bool parse_value(cJSON * const item, parse_buffer * const input_buffer);
        -:  972:static cJSON_bool print_value(const cJSON * const item, printbuffer * const output_buffer);
        -:  973:static cJSON_bool parse_array(cJSON * const item, parse_buffer * const input_buffer);
        -:  974:static cJSON_bool print_array(const cJSON * const item, printbuffer * const output_buffer);
        -:  975:static cJSON_bool parse_object(cJSON * const item, parse_buffer * const input_buffer);
        -:  976:static cJSON_bool print_object(const cJSON * const item, printbuffer * const output_buffer);
        -:  977:
        -:  978:/* Utility to jump whitespace and cr/lf */
      106:  979:static parse_buffer *buffer_skip_whitespace(parse_buffer * const buffer)
        -:  980:{
      106:  981:    if ((buffer == NULL) || (buffer->content == NULL))
      106:  981-block  0
      106:  981-block  1
        -:  982:    {
    #####:  983:        return NULL;
    %%%%%:  983-block  0
        -:  984:    }
        -:  985:
      129:  986:    while (can_access_at_index(buffer, 0) && (buffer_at_offset(buffer)[0] <= 32))
      129:  986-block  0
      129:  986-block  1
      129:  986-block  2
        -:  987:    {
       23:  988:       buffer->offset++;
       23:  988-block  0
        -:  989:    }
        -:  990:
      106:  991:    if (buffer->offset == buffer->length)
      106:  991-block  0
        -:  992:    {
    #####:  993:        buffer->offset--;
    %%%%%:  993-block  0
        -:  994:    }
        -:  995:
      106:  996:    return buffer;
      106:  996-block  0
        -:  997:}
        -:  998:
        -:  999:/* skip the UTF-8 BOM (byte order mark) if it is at the beginning of a buffer */
    #####: 1000:static parse_buffer *skip_utf8_bom(parse_buffer * const buffer)
        -: 1001:{
    #####: 1002:    if ((buffer == NULL) || (buffer->content == NULL) || (buffer->offset != 0))
    %%%%%: 1002-block  0
    %%%%%: 1002-block  1
    %%%%%: 1002-block  2
        -: 1003:    {
    #####: 1004:        return NULL;
    %%%%%: 1004-block  0
        -: 1005:    }
        -: 1006:
    #####: 1007:    if (can_access_at_index(buffer, 4) && (strncmp((const char*)buffer_at_offset(buffer), "\xEF\xBB\xBF", 3) == 0))
    %%%%%: 1007-block  0
    %%%%%: 1007-block  1
    %%%%%: 1007-block  2
        -: 1008:    {
    #####: 1009:        buffer->offset += 3;
    %%%%%: 1009-block  0
        -: 1010:    }
        -: 1011:
    #####: 1012:    return buffer;
    %%%%%: 1012-block  0
        -: 1013:}
        -: 1014:
        -: 1015:/* Parse an object - create a new root, and populate. */
    #####: 1016:CJSON_PUBLIC(cJSON *) cJSON_ParseWithOpts(const char *value, const char **return_parse_end, cJSON_bool require_null_terminated)
        -: 1017:{
    #####: 1018:    parse_buffer buffer = { 0, 0, 0, 0, { 0, 0, 0 } };
    #####: 1019:    cJSON *item = NULL;
        -: 1020:
        -: 1021:    /* reset error position */
    #####: 1022:    global_error.json = NULL;
    #####: 1023:    global_error.position = 0;
        -: 1024:
    #####: 1025:    if (value == NULL)
    %%%%%: 1025-block  0
        -: 1026:    {
    #####: 1027:        goto fail;
    %%%%%: 1027-block  0
        -: 1028:    }
        -: 1029:
    #####: 1030:    buffer.content = (const unsigned char*)value;
    #####: 1031:    buffer.length = strlen((const char*)value) + sizeof("");
    #####: 1032:    buffer.offset = 0;
    #####: 1033:    buffer.hooks = global_hooks;
        -: 1034:
    #####: 1035:    item = cJSON_New_Item(&global_hooks);
    %%%%%: 1035-block  0
    #####: 1036:    if (item == NULL) /* memory fail */
    %%%%%: 1036-block  0
        -: 1037:    {
    #####: 1038:        goto fail;
    %%%%%: 1038-block  0
        -: 1039:    }
        -: 1040:
    #####: 1041:    if (!parse_value(item, buffer_skip_whitespace(skip_utf8_bom(&buffer))))
    %%%%%: 1041-block  0
    %%%%%: 1041-block  1
        -: 1042:    {
        -: 1043:        /* parse failure. ep is set. */
    #####: 1044:        goto fail;
    %%%%%: 1044-block  0
        -: 1045:    }
        -: 1046:
        -: 1047:    /* if we require null-terminated JSON without appended garbage, skip and then check for a null terminator */
    #####: 1048:    if (require_null_terminated)
    %%%%%: 1048-block  0
        -: 1049:    {
    #####: 1050:        buffer_skip_whitespace(&buffer);
    %%%%%: 1050-block  0
    #####: 1051:        if ((buffer.offset >= buffer.length) || buffer_at_offset(&buffer)[0] != '\0')
    %%%%%: 1051-block  0
        -: 1052:        {
    #####: 1053:            goto fail;
    %%%%%: 1053-block  0
        -: 1054:        }
        -: 1055:    }
    #####: 1056:    if (return_parse_end)
    %%%%%: 1056-block  0
        -: 1057:    {
    #####: 1058:        *return_parse_end = (const char*)buffer_at_offset(&buffer);
    %%%%%: 1058-block  0
        -: 1059:    }
        -: 1060:
    #####: 1061:    return item;
    %%%%%: 1061-block  0
        -: 1062:
    #####: 1063:fail:
    #####: 1064:    if (item != NULL)
    %%%%%: 1064-block  0
        -: 1065:    {
    #####: 1066:        cJSON_Delete(item);
    %%%%%: 1066-block  0
        -: 1067:    }
        -: 1068:
    #####: 1069:    if (value != NULL)
    %%%%%: 1069-block  0
        -: 1070:    {
        -: 1071:        error local_error;
    #####: 1072:        local_error.json = (const unsigned char*)value;
    #####: 1073:        local_error.position = 0;
        -: 1074:
    #####: 1075:        if (buffer.offset < buffer.length)
    %%%%%: 1075-block  0
        -: 1076:        {
    #####: 1077:            local_error.position = buffer.offset;
    %%%%%: 1077-block  0
        -: 1078:        }
    #####: 1079:        else if (buffer.length > 0)
    %%%%%: 1079-block  0
        -: 1080:        {
    #####: 1081:            local_error.position = buffer.length - 1;
    %%%%%: 1081-block  0
        -: 1082:        }
        -: 1083:
    #####: 1084:        if (return_parse_end != NULL)
    %%%%%: 1084-block  0
        -: 1085:        {
    #####: 1086:            *return_parse_end = (const char*)local_error.json + local_error.position;
    %%%%%: 1086-block  0
        -: 1087:        }
        -: 1088:
    #####: 1089:        global_error = local_error;
    %%%%%: 1089-block  0
        -: 1090:    }
        -: 1091:
    #####: 1092:    return NULL;
    %%%%%: 1092-block  0
        -: 1093:}
        -: 1094:
        -: 1095:/* Default options for cJSON_Parse */
    #####: 1096:CJSON_PUBLIC(cJSON *) cJSON_Parse(const char *value)
        -: 1097:{
    #####: 1098:    return cJSON_ParseWithOpts(value, 0, 0);
    %%%%%: 1098-block  0
        -: 1099:}
        -: 1100:
        -: 1101:#define cjson_min(a, b) ((a < b) ? a : b)
        -: 1102:
    #####: 1103:static unsigned char *print(const cJSON * const item, cJSON_bool format, const internal_hooks * const hooks)
        -: 1104:{
        -: 1105:    static const size_t default_buffer_size = 256;
        -: 1106:    printbuffer buffer[1];
    #####: 1107:    unsigned char *printed = NULL;
        -: 1108:
    #####: 1109:    memset(buffer, 0, sizeof(buffer));
        -: 1110:
        -: 1111:    /* create buffer */
    #####: 1112:    buffer->buffer = (unsigned char*) hooks->allocate(default_buffer_size);
    %%%%%: 1112-block  0
    #####: 1113:    buffer->length = default_buffer_size;
    #####: 1114:    buffer->format = format;
    #####: 1115:    buffer->hooks = *hooks;
    #####: 1116:    if (buffer->buffer == NULL)
    %%%%%: 1116-block  0
        -: 1117:    {
    #####: 1118:        goto fail;
    %%%%%: 1118-block  0
        -: 1119:    }
        -: 1120:
        -: 1121:    /* print the value */
    #####: 1122:    if (!print_value(item, buffer))
    %%%%%: 1122-block  0
    %%%%%: 1122-block  1
        -: 1123:    {
    #####: 1124:        goto fail;
    %%%%%: 1124-block  0
        -: 1125:    }
    #####: 1126:    update_offset(buffer);
    %%%%%: 1126-block  0
        -: 1127:
        -: 1128:    /* check if reallocate is available */
    #####: 1129:    if (hooks->reallocate != NULL)
        -: 1130:    {
    #####: 1131:        printed = (unsigned char*) hooks->reallocate(buffer->buffer, buffer->offset + 1);
    %%%%%: 1131-block  0
    #####: 1132:        if (printed == NULL) {
    %%%%%: 1132-block  0
    #####: 1133:            goto fail;
    %%%%%: 1133-block  0
        -: 1134:        }
    #####: 1135:        buffer->buffer = NULL;
    %%%%%: 1135-block  0
        -: 1136:    }
        -: 1137:    else /* otherwise copy the JSON over to a new buffer */
        -: 1138:    {
    #####: 1139:        printed = (unsigned char*) hooks->allocate(buffer->offset + 1);
    %%%%%: 1139-block  0
    #####: 1140:        if (printed == NULL)
    %%%%%: 1140-block  0
        -: 1141:        {
    #####: 1142:            goto fail;
    %%%%%: 1142-block  0
        -: 1143:        }
    #####: 1144:        memcpy(printed, buffer->buffer, cjson_min(buffer->length, buffer->offset + 1));
    #####: 1145:        printed[buffer->offset] = '\0'; /* just to be sure */
        -: 1146:
        -: 1147:        /* free the buffer */
    #####: 1148:        hooks->deallocate(buffer->buffer);
    %%%%%: 1148-block  0
        -: 1149:    }
        -: 1150:
    #####: 1151:    return printed;
    %%%%%: 1151-block  0
        -: 1152:
    #####: 1153:fail:
    #####: 1154:    if (buffer->buffer != NULL)
    %%%%%: 1154-block  0
        -: 1155:    {
    #####: 1156:        hooks->deallocate(buffer->buffer);
    %%%%%: 1156-block  0
        -: 1157:    }
        -: 1158:
    #####: 1159:    if (printed != NULL)
    %%%%%: 1159-block  0
        -: 1160:    {
    #####: 1161:        hooks->deallocate(printed);
    %%%%%: 1161-block  0
        -: 1162:    }
        -: 1163:
    #####: 1164:    return NULL;
    %%%%%: 1164-block  0
        -: 1165:}
        -: 1166:
        -: 1167:/* Render a cJSON item/entity/structure to text. */
    #####: 1168:CJSON_PUBLIC(char *) cJSON_Print(const cJSON *item)
        -: 1169:{
    #####: 1170:    return (char*)print(item, true, &global_hooks);
    %%%%%: 1170-block  0
        -: 1171:}
        -: 1172:
    #####: 1173:CJSON_PUBLIC(char *) cJSON_PrintUnformatted(const cJSON *item)
        -: 1174:{
    #####: 1175:    return (char*)print(item, false, &global_hooks);
    %%%%%: 1175-block  0
        -: 1176:}
        -: 1177:
    #####: 1178:CJSON_PUBLIC(char *) cJSON_PrintBuffered(const cJSON *item, int prebuffer, cJSON_bool fmt)
        -: 1179:{
    #####: 1180:    printbuffer p = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };
        -: 1181:
    #####: 1182:    if (prebuffer < 0)
    %%%%%: 1182-block  0
        -: 1183:    {
    #####: 1184:        return NULL;
    %%%%%: 1184-block  0
        -: 1185:    }
        -: 1186:
    #####: 1187:    p.buffer = (unsigned char*)global_hooks.allocate((size_t)prebuffer);
    %%%%%: 1187-block  0
    #####: 1188:    if (!p.buffer)
    %%%%%: 1188-block  0
        -: 1189:    {
    #####: 1190:        return NULL;
    %%%%%: 1190-block  0
        -: 1191:    }
        -: 1192:
    #####: 1193:    p.length = (size_t)prebuffer;
    #####: 1194:    p.offset = 0;
    #####: 1195:    p.noalloc = false;
    #####: 1196:    p.format = fmt;
    #####: 1197:    p.hooks = global_hooks;
        -: 1198:
    #####: 1199:    if (!print_value(item, &p))
    %%%%%: 1199-block  0
    %%%%%: 1199-block  1
        -: 1200:    {
    #####: 1201:        global_hooks.deallocate(p.buffer);
    %%%%%: 1201-block  0
    #####: 1202:        return NULL;
    %%%%%: 1202-block  0
        -: 1203:    }
        -: 1204:
    #####: 1205:    return (char*)p.buffer;
    %%%%%: 1205-block  0
        -: 1206:}
        -: 1207:
    #####: 1208:CJSON_PUBLIC(cJSON_bool) cJSON_PrintPreallocated(cJSON *item, char *buffer, const int length, const cJSON_bool format)
        -: 1209:{
    #####: 1210:    printbuffer p = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };
        -: 1211:
    #####: 1212:    if ((length < 0) || (buffer == NULL))
    %%%%%: 1212-block  0
    %%%%%: 1212-block  1
        -: 1213:    {
    #####: 1214:        return false;
    %%%%%: 1214-block  0
        -: 1215:    }
        -: 1216:
    #####: 1217:    p.buffer = (unsigned char*)buffer;
    #####: 1218:    p.length = (size_t)length;
    #####: 1219:    p.offset = 0;
    #####: 1220:    p.noalloc = true;
    #####: 1221:    p.format = format;
    #####: 1222:    p.hooks = global_hooks;
        -: 1223:
    #####: 1224:    return print_value(item, &p);
    %%%%%: 1224-block  0
    %%%%%: 1224-block  1
        -: 1225:}
        -: 1226:
        -: 1227:/* Parser core - when encountering text, process appropriately. */
       28: 1228:static cJSON_bool parse_value(cJSON * const item, parse_buffer * const input_buffer)
        -: 1229:{
       28: 1230:    if ((input_buffer == NULL) || (input_buffer->content == NULL))
       28: 1230-block  0
       28: 1230-block  1
        -: 1231:    {
    #####: 1232:        return false; /* no input */
    %%%%%: 1232-block  0
        -: 1233:    }
        -: 1234:
        -: 1235:    /* parse the different types of values */
        -: 1236:    /* null */
       28: 1237:    if (can_read(input_buffer, 4) && (strncmp((const char*)buffer_at_offset(input_buffer), "null", 4) == 0))
       28: 1237-block  0
       28: 1237-block  1
       24: 1237-block  2
        -: 1238:    {
        4: 1239:        item->type = cJSON_NULL;
        4: 1240:        input_buffer->offset += 4;
        4: 1241:        return true;
        4: 1241-block  0
        -: 1242:    }
        -: 1243:    /* false */
       24: 1244:    if (can_read(input_buffer, 5) && (strncmp((const char*)buffer_at_offset(input_buffer), "false", 5) == 0))
       24: 1244-block  0
       24: 1244-block  1
       16: 1244-block  2
        -: 1245:    {
        2: 1246:        item->type = cJSON_False;
        2: 1247:        input_buffer->offset += 5;
        2: 1248:        return true;
        2: 1248-block  0
        -: 1249:    }
        -: 1250:    /* true */
       22: 1251:    if (can_read(input_buffer, 4) && (strncmp((const char*)buffer_at_offset(input_buffer), "true", 4) == 0))
       22: 1251-block  0
       22: 1251-block  1
       18: 1251-block  2
        -: 1252:    {
        2: 1253:        item->type = cJSON_True;
        2: 1254:        item->valueint = 1;
        2: 1255:        input_buffer->offset += 4;
        2: 1256:        return true;
        2: 1256-block  0
        -: 1257:    }
        -: 1258:    /* string */
       20: 1259:    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '\"'))
       20: 1259-block  0
       20: 1259-block  1
       20: 1259-block  2
        -: 1260:    {
        4: 1261:        return parse_string(item, input_buffer);
        4: 1261-block  0
        -: 1262:    }
        -: 1263:    /* number */
       16: 1264:    if (can_access_at_index(input_buffer, 0) && ((buffer_at_offset(input_buffer)[0] == '-') || ((buffer_at_offset(input_buffer)[0] >= '0') && (buffer_at_offset(input_buffer)[0] <= '9'))))
       16: 1264-block  0
       16: 1264-block  1
       16: 1264-block  2
       16: 1264-block  3
       16: 1264-block  4
        -: 1265:    {
       10: 1266:        return parse_number(item, input_buffer);
       10: 1266-block  0
        -: 1267:    }
        -: 1268:    /* array */
        6: 1269:    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '['))
        6: 1269-block  0
        6: 1269-block  1
        6: 1269-block  2
        -: 1270:    {
        4: 1271:        return parse_array(item, input_buffer);
        4: 1271-block  0
        -: 1272:    }
        -: 1273:    /* object */
        2: 1274:    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '{'))
        2: 1274-block  0
        2: 1274-block  1
        2: 1274-block  2
        -: 1275:    {
        2: 1276:        return parse_object(item, input_buffer);
        2: 1276-block  0
        -: 1277:    }
        -: 1278:
    #####: 1279:    return false;
    %%%%%: 1279-block  0
        -: 1280:}
        -: 1281:
        -: 1282:/* Render a value to text. */
    #####: 1283:static cJSON_bool print_value(const cJSON * const item, printbuffer * const output_buffer)
        -: 1284:{
    #####: 1285:    unsigned char *output = NULL;
        -: 1286:
    #####: 1287:    if ((item == NULL) || (output_buffer == NULL))
    %%%%%: 1287-block  0
    %%%%%: 1287-block  1
        -: 1288:    {
    #####: 1289:        return false;
    %%%%%: 1289-block  0
        -: 1290:    }
        -: 1291:
    #####: 1292:    switch ((item->type) & 0xFF)
    %%%%%: 1292-block  0
        -: 1293:    {
    #####: 1294:        case cJSON_NULL:
    #####: 1295:            output = ensure(output_buffer, 5);
    %%%%%: 1295-block  0
    #####: 1296:            if (output == NULL)
        -: 1297:            {
    #####: 1298:                return false;
    %%%%%: 1298-block  0
        -: 1299:            }
    #####: 1300:            strcpy((char*)output, "null");
    #####: 1301:            return true;
    %%%%%: 1301-block  0
        -: 1302:
    #####: 1303:        case cJSON_False:
    #####: 1304:            output = ensure(output_buffer, 6);
    %%%%%: 1304-block  0
    #####: 1305:            if (output == NULL)
        -: 1306:            {
    #####: 1307:                return false;
    %%%%%: 1307-block  0
        -: 1308:            }
    #####: 1309:            strcpy((char*)output, "false");
    #####: 1310:            return true;
    %%%%%: 1310-block  0
        -: 1311:
    #####: 1312:        case cJSON_True:
    #####: 1313:            output = ensure(output_buffer, 5);
    %%%%%: 1313-block  0
    #####: 1314:            if (output == NULL)
        -: 1315:            {
    #####: 1316:                return false;
    %%%%%: 1316-block  0
        -: 1317:            }
    #####: 1318:            strcpy((char*)output, "true");
    #####: 1319:            return true;
    %%%%%: 1319-block  0
        -: 1320:
    #####: 1321:        case cJSON_Number:
    #####: 1322:            return print_number(item, output_buffer);
    %%%%%: 1322-block  0
        -: 1323:
    #####: 1324:        case cJSON_Raw:
        -: 1325:        {
    #####: 1326:            size_t raw_length = 0;
    #####: 1327:            if (item->valuestring == NULL)
    %%%%%: 1327-block  0
        -: 1328:            {
    #####: 1329:                return false;
    %%%%%: 1329-block  0
        -: 1330:            }
        -: 1331:
    #####: 1332:            raw_length = strlen(item->valuestring) + sizeof("");
    #####: 1333:            output = ensure(output_buffer, raw_length);
    %%%%%: 1333-block  0
    #####: 1334:            if (output == NULL)
        -: 1335:            {
    #####: 1336:                return false;
    %%%%%: 1336-block  0
        -: 1337:            }
    #####: 1338:            memcpy(output, item->valuestring, raw_length);
    #####: 1339:            return true;
    %%%%%: 1339-block  0
        -: 1340:        }
        -: 1341:
    #####: 1342:        case cJSON_String:
    #####: 1343:            return print_string(item, output_buffer);
    %%%%%: 1343-block  0
        -: 1344:
    #####: 1345:        case cJSON_Array:
    #####: 1346:            return print_array(item, output_buffer);
    %%%%%: 1346-block  0
        -: 1347:
    #####: 1348:        case cJSON_Object:
    #####: 1349:            return print_object(item, output_buffer);
    %%%%%: 1349-block  0
        -: 1350:
    #####: 1351:        default:
    #####: 1352:            return false;
    %%%%%: 1352-block  0
        -: 1353:    }
        -: 1354:}
        -: 1355:
        -: 1356:/* Build an array from input text. */
       12: 1357:static cJSON_bool parse_array(cJSON * const item, parse_buffer * const input_buffer)
        -: 1358:{
       12: 1359:    cJSON *head = NULL; /* head of the linked list */
       12: 1360:    cJSON *current_item = NULL;
        -: 1361:
       12: 1362:    if (input_buffer->depth >= CJSON_NESTING_LIMIT)
       12: 1362-block  0
        -: 1363:    {
    #####: 1364:        return false; /* to deeply nested */
    %%%%%: 1364-block  0
        -: 1365:    }
       12: 1366:    input_buffer->depth++;
        -: 1367:
       12: 1368:    if (buffer_at_offset(input_buffer)[0] != '[')
       12: 1368-block  0
        -: 1369:    {
        -: 1370:        /* not an array */
    #####: 1371:        goto fail;
    %%%%%: 1371-block  0
        -: 1372:    }
        -: 1373:
       12: 1374:    input_buffer->offset++;
       12: 1375:    buffer_skip_whitespace(input_buffer);
       12: 1375-block  0
       12: 1376:    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ']'))
       12: 1376-block  0
       12: 1376-block  1
        -: 1377:    {
        -: 1378:        /* empty array */
        6: 1379:        goto success;
        6: 1379-block  0
        -: 1380:    }
        -: 1381:
        -: 1382:    /* check if we skipped to the end of the buffer */
        6: 1383:    if (cannot_access_at_index(input_buffer, 0))
        6: 1383-block  0
        6: 1383-block  1
        -: 1384:    {
    #####: 1385:        input_buffer->offset--;
    #####: 1386:        goto fail;
    %%%%%: 1386-block  0
        -: 1387:    }
        -: 1388:
        -: 1389:    /* step back to character in front of the first element */
        6: 1390:    input_buffer->offset--;
        6: 1390-block  0
        -: 1391:    /* loop through the comma separated array elements */
        8: 1392:    do
        8: 1392-block  0
        -: 1393:    {
        -: 1394:        /* allocate next item */
       14: 1395:        cJSON *new_item = cJSON_New_Item(&(input_buffer->hooks));
       14: 1395-block  0
       14: 1396:        if (new_item == NULL)
        -: 1397:        {
    #####: 1398:            goto fail; /* allocation failure */
    %%%%%: 1398-block  0
        -: 1399:        }
        -: 1400:
        -: 1401:        /* attach next item to list */
       14: 1402:        if (head == NULL)
       14: 1402-block  0
        -: 1403:        {
        -: 1404:            /* start the linked list */
        6: 1405:            current_item = head = new_item;
        6: 1405-block  0
        -: 1406:        }
        -: 1407:        else
        -: 1408:        {
        -: 1409:            /* add to the end and advance */
        8: 1410:            current_item->next = new_item;
        8: 1411:            new_item->prev = current_item;
        8: 1412:            current_item = new_item;
        8: 1412-block  0
        -: 1413:        }
        -: 1414:
        -: 1415:        /* parse next value */
       14: 1416:        input_buffer->offset++;
       14: 1417:        buffer_skip_whitespace(input_buffer);
       14: 1417-block  0
       14: 1418:        if (!parse_value(current_item, input_buffer))
        -: 1419:        {
    #####: 1420:            goto fail; /* failed to parse value */
    %%%%%: 1420-block  0
        -: 1421:        }
       14: 1422:        buffer_skip_whitespace(input_buffer);
       14: 1422-block  0
        -: 1423:    }
       14: 1424:    while (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ','));
       14: 1424-block  0
       14: 1424-block  1
        -: 1425:
        6: 1426:    if (cannot_access_at_index(input_buffer, 0) || buffer_at_offset(input_buffer)[0] != ']')
        6: 1426-block  0
        6: 1426-block  1
        6: 1426-block  2
        -: 1427:    {
    #####: 1428:        goto fail; /* expected end of array */
    %%%%%: 1428-block  0
        -: 1429:    }
        -: 1430:
        6: 1431:success:
        6: 1431-block  0
       12: 1432:    input_buffer->depth--;
        -: 1433:
       12: 1434:    item->type = cJSON_Array;
       12: 1435:    item->child = head;
        -: 1436:
       12: 1437:    input_buffer->offset++;
        -: 1438:
       12: 1439:    return true;
       12: 1439-block  0
        -: 1440:
    #####: 1441:fail:
    #####: 1442:    if (head != NULL)
    %%%%%: 1442-block  0
        -: 1443:    {
    #####: 1444:        cJSON_Delete(head);
    %%%%%: 1444-block  0
        -: 1445:    }
        -: 1446:
    #####: 1447:    return false;
    %%%%%: 1447-block  0
        -: 1448:}
        -: 1449:
        -: 1450:/* Render an array to text */
    #####: 1451:static cJSON_bool print_array(const cJSON * const item, printbuffer * const output_buffer)
        -: 1452:{
    #####: 1453:    unsigned char *output_pointer = NULL;
    #####: 1454:    size_t length = 0;
    #####: 1455:    cJSON *current_element = item->child;
        -: 1456:
    #####: 1457:    if (output_buffer == NULL)
    %%%%%: 1457-block  0
        -: 1458:    {
    #####: 1459:        return false;
    %%%%%: 1459-block  0
        -: 1460:    }
        -: 1461:
        -: 1462:    /* Compose the output array. */
        -: 1463:    /* opening square bracket */
    #####: 1464:    output_pointer = ensure(output_buffer, 1);
    %%%%%: 1464-block  0
    #####: 1465:    if (output_pointer == NULL)
        -: 1466:    {
    #####: 1467:        return false;
    %%%%%: 1467-block  0
        -: 1468:    }
        -: 1469:
    #####: 1470:    *output_pointer = '[';
    #####: 1471:    output_buffer->offset++;
    #####: 1472:    output_buffer->depth++;
    %%%%%: 1472-block  0
        -: 1473:
    #####: 1474:    while (current_element != NULL)
    %%%%%: 1474-block  0
        -: 1475:    {
    #####: 1476:        if (!print_value(current_element, output_buffer))
    %%%%%: 1476-block  0
        -: 1477:        {
    #####: 1478:            return false;
    %%%%%: 1478-block  0
        -: 1479:        }
    #####: 1480:        update_offset(output_buffer);
    %%%%%: 1480-block  0
    #####: 1481:        if (current_element->next)
        -: 1482:        {
    #####: 1483:            length = (size_t) (output_buffer->format ? 2 : 1);
    %%%%%: 1483-block  0
    %%%%%: 1483-block  1
    %%%%%: 1483-block  2
    #####: 1484:            output_pointer = ensure(output_buffer, length + 1);
    %%%%%: 1484-block  0
    #####: 1485:            if (output_pointer == NULL)
        -: 1486:            {
    #####: 1487:                return false;
    %%%%%: 1487-block  0
        -: 1488:            }
    #####: 1489:            *output_pointer++ = ',';
    #####: 1490:            if(output_buffer->format)
    %%%%%: 1490-block  0
        -: 1491:            {
    #####: 1492:                *output_pointer++ = ' ';
    %%%%%: 1492-block  0
        -: 1493:            }
    #####: 1494:            *output_pointer = '\0';
    #####: 1495:            output_buffer->offset += length;
    %%%%%: 1495-block  0
        -: 1496:        }
    #####: 1497:        current_element = current_element->next;
    %%%%%: 1497-block  0
        -: 1498:    }
        -: 1499:
    #####: 1500:    output_pointer = ensure(output_buffer, 2);
    %%%%%: 1500-block  0
    #####: 1501:    if (output_pointer == NULL)
        -: 1502:    {
    #####: 1503:        return false;
    %%%%%: 1503-block  0
        -: 1504:    }
    #####: 1505:    *output_pointer++ = ']';
    #####: 1506:    *output_pointer = '\0';
    #####: 1507:    output_buffer->depth--;
        -: 1508:
    #####: 1509:    return true;
    %%%%%: 1509-block  0
        -: 1510:}
        -: 1511:
        -: 1512:/* Build an object from the text. */
       10: 1513:static cJSON_bool parse_object(cJSON * const item, parse_buffer * const input_buffer)
        -: 1514:{
       10: 1515:    cJSON *head = NULL; /* linked list head */
       10: 1516:    cJSON *current_item = NULL;
        -: 1517:
       10: 1518:    if (input_buffer->depth >= CJSON_NESTING_LIMIT)
       10: 1518-block  0
        -: 1519:    {
    #####: 1520:        return false; /* to deeply nested */
    %%%%%: 1520-block  0
        -: 1521:    }
       10: 1522:    input_buffer->depth++;
        -: 1523:
       10: 1524:    if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != '{'))
       10: 1524-block  0
       10: 1524-block  1
       10: 1524-block  2
        -: 1525:    {
    #####: 1526:        goto fail; /* not an object */
    %%%%%: 1526-block  0
        -: 1527:    }
        -: 1528:
       10: 1529:    input_buffer->offset++;
       10: 1530:    buffer_skip_whitespace(input_buffer);
       10: 1530-block  0
       10: 1531:    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '}'))
       10: 1531-block  0
       10: 1531-block  1
        -: 1532:    {
        4: 1533:        goto success; /* empty object */
        4: 1533-block  0
        -: 1534:    }
        -: 1535:
        -: 1536:    /* check if we skipped to the end of the buffer */
        6: 1537:    if (cannot_access_at_index(input_buffer, 0))
        6: 1537-block  0
        6: 1537-block  1
        -: 1538:    {
    #####: 1539:        input_buffer->offset--;
    #####: 1540:        goto fail;
    %%%%%: 1540-block  0
        -: 1541:    }
        -: 1542:
        -: 1543:    /* step back to character in front of the first element */
        6: 1544:    input_buffer->offset--;
        6: 1544-block  0
        -: 1545:    /* loop through the comma separated array elements */
        8: 1546:    do
        8: 1546-block  0
        -: 1547:    {
        -: 1548:        /* allocate next item */
       14: 1549:        cJSON *new_item = cJSON_New_Item(&(input_buffer->hooks));
       14: 1549-block  0
       14: 1550:        if (new_item == NULL)
        -: 1551:        {
    #####: 1552:            goto fail; /* allocation failure */
    %%%%%: 1552-block  0
        -: 1553:        }
        -: 1554:
        -: 1555:        /* attach next item to list */
       14: 1556:        if (head == NULL)
       14: 1556-block  0
        -: 1557:        {
        -: 1558:            /* start the linked list */
        6: 1559:            current_item = head = new_item;
        6: 1559-block  0
        -: 1560:        }
        -: 1561:        else
        -: 1562:        {
        -: 1563:            /* add to the end and advance */
        8: 1564:            current_item->next = new_item;
        8: 1565:            new_item->prev = current_item;
        8: 1566:            current_item = new_item;
        8: 1566-block  0
        -: 1567:        }
        -: 1568:
        -: 1569:        /* parse the name of the child */
       14: 1570:        input_buffer->offset++;
       14: 1571:        buffer_skip_whitespace(input_buffer);
       14: 1571-block  0
       14: 1572:        if (!parse_string(current_item, input_buffer))
        -: 1573:        {
    #####: 1574:            goto fail; /* failed to parse name */
    %%%%%: 1574-block  0
        -: 1575:        }
       14: 1576:        buffer_skip_whitespace(input_buffer);
       14: 1576-block  0
        -: 1577:
        -: 1578:        /* swap valuestring and string, because we parsed the name */
       14: 1579:        current_item->string = current_item->valuestring;
       14: 1580:        current_item->valuestring = NULL;
        -: 1581:
       14: 1582:        if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != ':'))
       14: 1582-block  0
       14: 1582-block  1
        -: 1583:        {
    #####: 1584:            goto fail; /* invalid object */
    %%%%%: 1584-block  0
        -: 1585:        }
        -: 1586:
        -: 1587:        /* parse the value */
       14: 1588:        input_buffer->offset++;
       14: 1589:        buffer_skip_whitespace(input_buffer);
       14: 1589-block  0
       14: 1590:        if (!parse_value(current_item, input_buffer))
        -: 1591:        {
    #####: 1592:            goto fail; /* failed to parse value */
    %%%%%: 1592-block  0
        -: 1593:        }
       14: 1594:        buffer_skip_whitespace(input_buffer);
       14: 1594-block  0
        -: 1595:    }
       14: 1596:    while (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ','));
       14: 1596-block  0
       14: 1596-block  1
        -: 1597:
        6: 1598:    if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != '}'))
        6: 1598-block  0
        6: 1598-block  1
        6: 1598-block  2
        -: 1599:    {
    #####: 1600:        goto fail; /* expected end of object */
    %%%%%: 1600-block  0
        -: 1601:    }
        -: 1602:
        6: 1603:success:
        6: 1603-block  0
       10: 1604:    input_buffer->depth--;
        -: 1605:
       10: 1606:    item->type = cJSON_Object;
       10: 1607:    item->child = head;
        -: 1608:
       10: 1609:    input_buffer->offset++;
       10: 1610:    return true;
       10: 1610-block  0
        -: 1611:
    #####: 1612:fail:
    #####: 1613:    if (head != NULL)
    %%%%%: 1613-block  0
        -: 1614:    {
    #####: 1615:        cJSON_Delete(head);
    %%%%%: 1615-block  0
        -: 1616:    }
        -: 1617:
    #####: 1618:    return false;
    %%%%%: 1618-block  0
        -: 1619:}
        -: 1620:
        -: 1621:/* Render an object to text. */
    #####: 1622:static cJSON_bool print_object(const cJSON * const item, printbuffer * const output_buffer)
        -: 1623:{
    #####: 1624:    unsigned char *output_pointer = NULL;
    #####: 1625:    size_t length = 0;
    #####: 1626:    cJSON *current_item = item->child;
        -: 1627:
    #####: 1628:    if (output_buffer == NULL)
    %%%%%: 1628-block  0
        -: 1629:    {
    #####: 1630:        return false;
    %%%%%: 1630-block  0
        -: 1631:    }
        -: 1632:
        -: 1633:    /* Compose the output: */
    #####: 1634:    length = (size_t) (output_buffer->format ? 2 : 1); /* fmt: {\n */
    %%%%%: 1634-block  0
    %%%%%: 1634-block  1
    %%%%%: 1634-block  2
    #####: 1635:    output_pointer = ensure(output_buffer, length + 1);
    %%%%%: 1635-block  0
    #####: 1636:    if (output_pointer == NULL)
        -: 1637:    {
    #####: 1638:        return false;
    %%%%%: 1638-block  0
        -: 1639:    }
        -: 1640:
    #####: 1641:    *output_pointer++ = '{';
    #####: 1642:    output_buffer->depth++;
    #####: 1643:    if (output_buffer->format)
    %%%%%: 1643-block  0
        -: 1644:    {
    #####: 1645:        *output_pointer++ = '\n';
    %%%%%: 1645-block  0
        -: 1646:    }
    #####: 1647:    output_buffer->offset += length;
    %%%%%: 1647-block  0
        -: 1648:
    #####: 1649:    while (current_item)
    %%%%%: 1649-block  0
        -: 1650:    {
    #####: 1651:        if (output_buffer->format)
    %%%%%: 1651-block  0
        -: 1652:        {
        -: 1653:            size_t i;
    #####: 1654:            output_pointer = ensure(output_buffer, output_buffer->depth);
    %%%%%: 1654-block  0
    #####: 1655:            if (output_pointer == NULL)
        -: 1656:            {
    #####: 1657:                return false;
    %%%%%: 1657-block  0
        -: 1658:            }
    #####: 1659:            for (i = 0; i < output_buffer->depth; i++)
    %%%%%: 1659-block  0
    %%%%%: 1659-block  1
        -: 1660:            {
    #####: 1661:                *output_pointer++ = '\t';
    %%%%%: 1661-block  0
        -: 1662:            }
    #####: 1663:            output_buffer->offset += output_buffer->depth;
    %%%%%: 1663-block  0
        -: 1664:        }
        -: 1665:
        -: 1666:        /* print key */
    #####: 1667:        if (!print_string_ptr((unsigned char*)current_item->string, output_buffer))
    %%%%%: 1667-block  0
        -: 1668:        {
    #####: 1669:            return false;
    %%%%%: 1669-block  0
        -: 1670:        }
    #####: 1671:        update_offset(output_buffer);
    %%%%%: 1671-block  0
        -: 1672:
    #####: 1673:        length = (size_t) (output_buffer->format ? 2 : 1);
    %%%%%: 1673-block  0
    %%%%%: 1673-block  1
    #####: 1674:        output_pointer = ensure(output_buffer, length);
    %%%%%: 1674-block  0
    #####: 1675:        if (output_pointer == NULL)
        -: 1676:        {
    #####: 1677:            return false;
    %%%%%: 1677-block  0
        -: 1678:        }
    #####: 1679:        *output_pointer++ = ':';
    #####: 1680:        if (output_buffer->format)
    %%%%%: 1680-block  0
        -: 1681:        {
    #####: 1682:            *output_pointer++ = '\t';
    %%%%%: 1682-block  0
        -: 1683:        }
    #####: 1684:        output_buffer->offset += length;
        -: 1685:
        -: 1686:        /* print value */
    #####: 1687:        if (!print_value(current_item, output_buffer))
    %%%%%: 1687-block  0
        -: 1688:        {
    #####: 1689:            return false;
    %%%%%: 1689-block  0
        -: 1690:        }
    #####: 1691:        update_offset(output_buffer);
    %%%%%: 1691-block  0
        -: 1692:
        -: 1693:        /* print comma if not last */
    #####: 1694:        length = ((size_t)(output_buffer->format ? 1 : 0) + (size_t)(current_item->next ? 1 : 0));
    %%%%%: 1694-block  0
    %%%%%: 1694-block  1
    %%%%%: 1694-block  2
    %%%%%: 1694-block  3
    %%%%%: 1694-block  4
    #####: 1695:        output_pointer = ensure(output_buffer, length + 1);
    %%%%%: 1695-block  0
    #####: 1696:        if (output_pointer == NULL)
        -: 1697:        {
    #####: 1698:            return false;
    %%%%%: 1698-block  0
        -: 1699:        }
    #####: 1700:        if (current_item->next)
    %%%%%: 1700-block  0
        -: 1701:        {
    #####: 1702:            *output_pointer++ = ',';
    %%%%%: 1702-block  0
        -: 1703:        }
        -: 1704:
    #####: 1705:        if (output_buffer->format)
    %%%%%: 1705-block  0
        -: 1706:        {
    #####: 1707:            *output_pointer++ = '\n';
    %%%%%: 1707-block  0
        -: 1708:        }
    #####: 1709:        *output_pointer = '\0';
    #####: 1710:        output_buffer->offset += length;
        -: 1711:
    #####: 1712:        current_item = current_item->next;
    %%%%%: 1712-block  0
        -: 1713:    }
        -: 1714:
    #####: 1715:    output_pointer = ensure(output_buffer, output_buffer->format ? (output_buffer->depth + 1) : 2);
    %%%%%: 1715-block  0
    %%%%%: 1715-block  1
    %%%%%: 1715-block  2
    %%%%%: 1715-block  3
    #####: 1716:    if (output_pointer == NULL)
        -: 1717:    {
    #####: 1718:        return false;
    %%%%%: 1718-block  0
        -: 1719:    }
    #####: 1720:    if (output_buffer->format)
    %%%%%: 1720-block  0
        -: 1721:    {
        -: 1722:        size_t i;
    #####: 1723:        for (i = 0; i < (output_buffer->depth - 1); i++)
    %%%%%: 1723-block  0
    %%%%%: 1723-block  1
        -: 1724:        {
    #####: 1725:            *output_pointer++ = '\t';
    %%%%%: 1725-block  0
        -: 1726:        }
        -: 1727:    }
    #####: 1728:    *output_pointer++ = '}';
    #####: 1729:    *output_pointer = '\0';
    #####: 1730:    output_buffer->depth--;
        -: 1731:
    #####: 1732:    return true;
    %%%%%: 1732-block  0
        -: 1733:}
        -: 1734:
        -: 1735:/* Get Array size/item / object item. */
    #####: 1736:CJSON_PUBLIC(int) cJSON_GetArraySize(const cJSON *array)
        -: 1737:{
    #####: 1738:    cJSON *child = NULL;
    #####: 1739:    size_t size = 0;
        -: 1740:
    #####: 1741:    if (array == NULL)
    %%%%%: 1741-block  0
        -: 1742:    {
    #####: 1743:        return 0;
    %%%%%: 1743-block  0
        -: 1744:    }
        -: 1745:
    #####: 1746:    child = array->child;
    %%%%%: 1746-block  0
        -: 1747:
    #####: 1748:    while(child != NULL)
    %%%%%: 1748-block  0
        -: 1749:    {
    #####: 1750:        size++;
    #####: 1751:        child = child->next;
    %%%%%: 1751-block  0
        -: 1752:    }
        -: 1753:
        -: 1754:    /* FIXME: Can overflow here. Cannot be fixed without breaking the API */
        -: 1755:
    #####: 1756:    return (int)size;
    %%%%%: 1756-block  0
        -: 1757:}
        -: 1758:
    #####: 1759:static cJSON* get_array_item(const cJSON *array, size_t index)
        -: 1760:{
    #####: 1761:    cJSON *current_child = NULL;
        -: 1762:
    #####: 1763:    if (array == NULL)
    %%%%%: 1763-block  0
        -: 1764:    {
    #####: 1765:        return NULL;
    %%%%%: 1765-block  0
        -: 1766:    }
        -: 1767:
    #####: 1768:    current_child = array->child;
    %%%%%: 1768-block  0
    #####: 1769:    while ((current_child != NULL) && (index > 0))
    %%%%%: 1769-block  0
    %%%%%: 1769-block  1
        -: 1770:    {
    #####: 1771:        index--;
    #####: 1772:        current_child = current_child->next;
    %%%%%: 1772-block  0
        -: 1773:    }
        -: 1774:
    #####: 1775:    return current_child;
    %%%%%: 1775-block  0
        -: 1776:}
        -: 1777:
    #####: 1778:CJSON_PUBLIC(cJSON *) cJSON_GetArrayItem(const cJSON *array, int index)
        -: 1779:{
    #####: 1780:    if (index < 0)
    %%%%%: 1780-block  0
        -: 1781:    {
    #####: 1782:        return NULL;
    %%%%%: 1782-block  0
        -: 1783:    }
        -: 1784:
    #####: 1785:    return get_array_item(array, (size_t)index);
    %%%%%: 1785-block  0
        -: 1786:}
        -: 1787:
    #####: 1788:static cJSON *get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)
        -: 1789:{
    #####: 1790:    cJSON *current_element = NULL;
        -: 1791:
    #####: 1792:    if ((object == NULL) || (name == NULL))
    %%%%%: 1792-block  0
    %%%%%: 1792-block  1
        -: 1793:    {
    #####: 1794:        return NULL;
    %%%%%: 1794-block  0
        -: 1795:    }
        -: 1796:
    #####: 1797:    current_element = object->child;
    #####: 1798:    if (case_sensitive)
    %%%%%: 1798-block  0
        -: 1799:    {
    #####: 1800:        while ((current_element != NULL) && (current_element->string != NULL) && (strcmp(name, current_element->string) != 0))
    %%%%%: 1800-block  0
    %%%%%: 1800-block  1
    %%%%%: 1800-block  2
        -: 1801:        {
    #####: 1802:            current_element = current_element->next;
    %%%%%: 1802-block  0
        -: 1803:        }
        -: 1804:    }
        -: 1805:    else
        -: 1806:    {
    #####: 1807:        while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))
    %%%%%: 1807-block  0
    %%%%%: 1807-block  1
    %%%%%: 1807-block  2
    %%%%%: 1807-block  3
    %%%%%: 1807-block  4
        -: 1808:        {
    #####: 1809:            current_element = current_element->next;
    %%%%%: 1809-block  0
        -: 1810:        }
        -: 1811:    }
        -: 1812:
    #####: 1813:    if ((current_element == NULL) || (current_element->string == NULL)) {
    %%%%%: 1813-block  0
    %%%%%: 1813-block  1
    #####: 1814:        return NULL;
    %%%%%: 1814-block  0
        -: 1815:    }
        -: 1816:
    #####: 1817:    return current_element;
    %%%%%: 1817-block  0
        -: 1818:}
        -: 1819:
    #####: 1820:CJSON_PUBLIC(cJSON *) cJSON_GetObjectItem(const cJSON * const object, const char * const string)
        -: 1821:{
    #####: 1822:    return get_object_item(object, string, false);
    %%%%%: 1822-block  0
        -: 1823:}
        -: 1824:
    #####: 1825:CJSON_PUBLIC(cJSON *) cJSON_GetObjectItemCaseSensitive(const cJSON * const object, const char * const string)
        -: 1826:{
    #####: 1827:    return get_object_item(object, string, true);
    %%%%%: 1827-block  0
        -: 1828:}
        -: 1829:
    #####: 1830:CJSON_PUBLIC(cJSON_bool) cJSON_HasObjectItem(const cJSON *object, const char *string)
        -: 1831:{
    #####: 1832:    return cJSON_GetObjectItem(object, string) ? 1 : 0;
    %%%%%: 1832-block  0
    %%%%%: 1832-block  1
    %%%%%: 1832-block  2
    %%%%%: 1832-block  3
        -: 1833:}
        -: 1834:
        -: 1835:/* Utility for array list handling. */
    #####: 1836:static void suffix_object(cJSON *prev, cJSON *item)
        -: 1837:{
    #####: 1838:    prev->next = item;
    #####: 1839:    item->prev = prev;
    #####: 1840:}
        -: 1841:
        -: 1842:/* Utility for handling references. */
    #####: 1843:static cJSON *create_reference(const cJSON *item, const internal_hooks * const hooks)
        -: 1844:{
    #####: 1845:    cJSON *reference = NULL;
    #####: 1846:    if (item == NULL)
    %%%%%: 1846-block  0
        -: 1847:    {
    #####: 1848:        return NULL;
    %%%%%: 1848-block  0
        -: 1849:    }
        -: 1850:
    #####: 1851:    reference = cJSON_New_Item(hooks);
    %%%%%: 1851-block  0
    #####: 1852:    if (reference == NULL)
        -: 1853:    {
    #####: 1854:        return NULL;
    %%%%%: 1854-block  0
        -: 1855:    }
        -: 1856:
    #####: 1857:    memcpy(reference, item, sizeof(cJSON));
    #####: 1858:    reference->string = NULL;
    #####: 1859:    reference->type |= cJSON_IsReference;
    #####: 1860:    reference->next = reference->prev = NULL;
    #####: 1861:    return reference;
    %%%%%: 1861-block  0
        -: 1862:}
        -: 1863:
    #####: 1864:static cJSON_bool add_item_to_array(cJSON *array, cJSON *item)
        -: 1865:{
    #####: 1866:    cJSON *child = NULL;
        -: 1867:
    #####: 1868:    if ((item == NULL) || (array == NULL))
    %%%%%: 1868-block  0
    %%%%%: 1868-block  1
        -: 1869:    {
    #####: 1870:        return false;
    %%%%%: 1870-block  0
        -: 1871:    }
        -: 1872:
    #####: 1873:    child = array->child;
        -: 1874:
    #####: 1875:    if (child == NULL)
    %%%%%: 1875-block  0
        -: 1876:    {
        -: 1877:        /* list is empty, start new one */
    #####: 1878:        array->child = item;
    %%%%%: 1878-block  0
        -: 1879:    }
        -: 1880:    else
        -: 1881:    {
        -: 1882:        /* append to the end */
    #####: 1883:        while (child->next)
    %%%%%: 1883-block  0
        -: 1884:        {
    #####: 1885:            child = child->next;
    %%%%%: 1885-block  0
        -: 1886:        }
    #####: 1887:        suffix_object(child, item);
    %%%%%: 1887-block  0
        -: 1888:    }
        -: 1889:
    #####: 1890:    return true;
    %%%%%: 1890-block  0
        -: 1891:}
        -: 1892:
        -: 1893:/* Add item to array/object. */
    #####: 1894:CJSON_PUBLIC(void) cJSON_AddItemToArray(cJSON *array, cJSON *item)
        -: 1895:{
    #####: 1896:    add_item_to_array(array, item);
    %%%%%: 1896-block  0
    #####: 1897:}
        -: 1898:
        -: 1899:#if defined(__clang__) || (defined(__GNUC__)  && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 5))))
        -: 1900:    #pragma GCC diagnostic push
        -: 1901:#endif
        -: 1902:#ifdef __GNUC__
        -: 1903:#pragma GCC diagnostic ignored "-Wcast-qual"
        -: 1904:#endif
        -: 1905:/* helper function to cast away const */
    #####: 1906:static void* cast_away_const(const void* string)
        -: 1907:{
    #####: 1908:    return (void*)string;
    %%%%%: 1908-block  0
        -: 1909:}
        -: 1910:#if defined(__clang__) || (defined(__GNUC__)  && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 5))))
        -: 1911:    #pragma GCC diagnostic pop
        -: 1912:#endif
        -: 1913:
        -: 1914:
    #####: 1915:static cJSON_bool add_item_to_object(cJSON * const object, const char * const string, cJSON * const item, const internal_hooks * const hooks, const cJSON_bool constant_key)
        -: 1916:{
    #####: 1917:    char *new_key = NULL;
    #####: 1918:    int new_type = cJSON_Invalid;
        -: 1919:
    #####: 1920:    if ((object == NULL) || (string == NULL) || (item == NULL))
    %%%%%: 1920-block  0
    %%%%%: 1920-block  1
    %%%%%: 1920-block  2
        -: 1921:    {
    #####: 1922:        return false;
    %%%%%: 1922-block  0
        -: 1923:    }
        -: 1924:
    #####: 1925:    if (constant_key)
    %%%%%: 1925-block  0
        -: 1926:    {
    #####: 1927:        new_key = (char*)cast_away_const(string);
    %%%%%: 1927-block  0
    #####: 1928:        new_type = item->type | cJSON_StringIsConst;
        -: 1929:    }
        -: 1930:    else
        -: 1931:    {
    #####: 1932:        new_key = (char*)cJSON_strdup((const unsigned char*)string, hooks);
    %%%%%: 1932-block  0
    #####: 1933:        if (new_key == NULL)
        -: 1934:        {
    #####: 1935:            return false;
    %%%%%: 1935-block  0
        -: 1936:        }
        -: 1937:
    #####: 1938:        new_type = item->type & ~cJSON_StringIsConst;
    %%%%%: 1938-block  0
        -: 1939:    }
        -: 1940:
    #####: 1941:    if (!(item->type & cJSON_StringIsConst) && (item->string != NULL))
    %%%%%: 1941-block  0
    %%%%%: 1941-block  1
        -: 1942:    {
    #####: 1943:        hooks->deallocate(item->string);
    %%%%%: 1943-block  0
        -: 1944:    }
        -: 1945:
    #####: 1946:    item->string = new_key;
    #####: 1947:    item->type = new_type;
        -: 1948:
    #####: 1949:    return add_item_to_array(object, item);
    %%%%%: 1949-block  0
        -: 1950:}
        -: 1951:
    #####: 1952:CJSON_PUBLIC(void) cJSON_AddItemToObject(cJSON *object, const char *string, cJSON *item)
        -: 1953:{
    #####: 1954:    add_item_to_object(object, string, item, &global_hooks, false);
    %%%%%: 1954-block  0
    #####: 1955:}
        -: 1956:
        -: 1957:/* Add an item to an object with constant string as key */
    #####: 1958:CJSON_PUBLIC(void) cJSON_AddItemToObjectCS(cJSON *object, const char *string, cJSON *item)
        -: 1959:{
    #####: 1960:    add_item_to_object(object, string, item, &global_hooks, true);
    %%%%%: 1960-block  0
    #####: 1961:}
        -: 1962:
    #####: 1963:CJSON_PUBLIC(void) cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)
        -: 1964:{
    #####: 1965:    if (array == NULL)
    %%%%%: 1965-block  0
        -: 1966:    {
    #####: 1967:        return;
    %%%%%: 1967-block  0
        -: 1968:    }
        -: 1969:
    #####: 1970:    add_item_to_array(array, create_reference(item, &global_hooks));
    %%%%%: 1970-block  0
        -: 1971:}
        -: 1972:
    #####: 1973:CJSON_PUBLIC(void) cJSON_AddItemReferenceToObject(cJSON *object, const char *string, cJSON *item)
        -: 1974:{
    #####: 1975:    if ((object == NULL) || (string == NULL))
    %%%%%: 1975-block  0
    %%%%%: 1975-block  1
        -: 1976:    {
    #####: 1977:        return;
    %%%%%: 1977-block  0
        -: 1978:    }
        -: 1979:
    #####: 1980:    add_item_to_object(object, string, create_reference(item, &global_hooks), &global_hooks, false);
    %%%%%: 1980-block  0
        -: 1981:}
        -: 1982:
    #####: 1983:CJSON_PUBLIC(cJSON*) cJSON_AddNullToObject(cJSON * const object, const char * const name)
        -: 1984:{
    #####: 1985:    cJSON *null = cJSON_CreateNull();
    %%%%%: 1985-block  0
    #####: 1986:    if (add_item_to_object(object, name, null, &global_hooks, false))
        -: 1987:    {
    #####: 1988:        return null;
    %%%%%: 1988-block  0
        -: 1989:    }
        -: 1990:
    #####: 1991:    cJSON_Delete(null);
    %%%%%: 1991-block  0
    #####: 1992:    return NULL;
        -: 1993:}
        -: 1994:
    #####: 1995:CJSON_PUBLIC(cJSON*) cJSON_AddTrueToObject(cJSON * const object, const char * const name)
        -: 1996:{
    #####: 1997:    cJSON *true_item = cJSON_CreateTrue();
    %%%%%: 1997-block  0
    #####: 1998:    if (add_item_to_object(object, name, true_item, &global_hooks, false))
        -: 1999:    {
    #####: 2000:        return true_item;
    %%%%%: 2000-block  0
        -: 2001:    }
        -: 2002:
    #####: 2003:    cJSON_Delete(true_item);
    %%%%%: 2003-block  0
    #####: 2004:    return NULL;
        -: 2005:}
        -: 2006:
    #####: 2007:CJSON_PUBLIC(cJSON*) cJSON_AddFalseToObject(cJSON * const object, const char * const name)
        -: 2008:{
    #####: 2009:    cJSON *false_item = cJSON_CreateFalse();
    %%%%%: 2009-block  0
    #####: 2010:    if (add_item_to_object(object, name, false_item, &global_hooks, false))
        -: 2011:    {
    #####: 2012:        return false_item;
    %%%%%: 2012-block  0
        -: 2013:    }
        -: 2014:
    #####: 2015:    cJSON_Delete(false_item);
    %%%%%: 2015-block  0
    #####: 2016:    return NULL;
        -: 2017:}
        -: 2018:
    #####: 2019:CJSON_PUBLIC(cJSON*) cJSON_AddBoolToObject(cJSON * const object, const char * const name, const cJSON_bool boolean)
        -: 2020:{
    #####: 2021:    cJSON *bool_item = cJSON_CreateBool(boolean);
    %%%%%: 2021-block  0
    #####: 2022:    if (add_item_to_object(object, name, bool_item, &global_hooks, false))
        -: 2023:    {
    #####: 2024:        return bool_item;
    %%%%%: 2024-block  0
        -: 2025:    }
        -: 2026:
    #####: 2027:    cJSON_Delete(bool_item);
    %%%%%: 2027-block  0
    #####: 2028:    return NULL;
        -: 2029:}
        -: 2030:
    #####: 2031:CJSON_PUBLIC(cJSON*) cJSON_AddNumberToObject(cJSON * const object, const char * const name, const double number)
        -: 2032:{
    #####: 2033:    cJSON *number_item = cJSON_CreateNumber(number);
    %%%%%: 2033-block  0
    #####: 2034:    if (add_item_to_object(object, name, number_item, &global_hooks, false))
        -: 2035:    {
    #####: 2036:        return number_item;
    %%%%%: 2036-block  0
        -: 2037:    }
        -: 2038:
    #####: 2039:    cJSON_Delete(number_item);
    %%%%%: 2039-block  0
    #####: 2040:    return NULL;
        -: 2041:}
        -: 2042:
    #####: 2043:CJSON_PUBLIC(cJSON*) cJSON_AddStringToObject(cJSON * const object, const char * const name, const char * const string)
        -: 2044:{
    #####: 2045:    cJSON *string_item = cJSON_CreateString(string);
    %%%%%: 2045-block  0
    #####: 2046:    if (add_item_to_object(object, name, string_item, &global_hooks, false))
        -: 2047:    {
    #####: 2048:        return string_item;
    %%%%%: 2048-block  0
        -: 2049:    }
        -: 2050:
    #####: 2051:    cJSON_Delete(string_item);
    %%%%%: 2051-block  0
    #####: 2052:    return NULL;
        -: 2053:}
        -: 2054:
    #####: 2055:CJSON_PUBLIC(cJSON*) cJSON_AddRawToObject(cJSON * const object, const char * const name, const char * const raw)
        -: 2056:{
    #####: 2057:    cJSON *raw_item = cJSON_CreateRaw(raw);
    %%%%%: 2057-block  0
    #####: 2058:    if (add_item_to_object(object, name, raw_item, &global_hooks, false))
        -: 2059:    {
    #####: 2060:        return raw_item;
    %%%%%: 2060-block  0
        -: 2061:    }
        -: 2062:
    #####: 2063:    cJSON_Delete(raw_item);
    %%%%%: 2063-block  0
    #####: 2064:    return NULL;
        -: 2065:}
        -: 2066:
    #####: 2067:CJSON_PUBLIC(cJSON*) cJSON_AddObjectToObject(cJSON * const object, const char * const name)
        -: 2068:{
    #####: 2069:    cJSON *object_item = cJSON_CreateObject();
    %%%%%: 2069-block  0
    #####: 2070:    if (add_item_to_object(object, name, object_item, &global_hooks, false))
        -: 2071:    {
    #####: 2072:        return object_item;
    %%%%%: 2072-block  0
        -: 2073:    }
        -: 2074:
    #####: 2075:    cJSON_Delete(object_item);
    %%%%%: 2075-block  0
    #####: 2076:    return NULL;
        -: 2077:}
        -: 2078:
    #####: 2079:CJSON_PUBLIC(cJSON*) cJSON_AddArrayToObject(cJSON * const object, const char * const name)
        -: 2080:{
    #####: 2081:    cJSON *array = cJSON_CreateArray();
    %%%%%: 2081-block  0
    #####: 2082:    if (add_item_to_object(object, name, array, &global_hooks, false))
        -: 2083:    {
    #####: 2084:        return array;
    %%%%%: 2084-block  0
        -: 2085:    }
        -: 2086:
    #####: 2087:    cJSON_Delete(array);
    %%%%%: 2087-block  0
    #####: 2088:    return NULL;
        -: 2089:}
        -: 2090:
    #####: 2091:CJSON_PUBLIC(cJSON *) cJSON_DetachItemViaPointer(cJSON *parent, cJSON * const item)
        -: 2092:{
    #####: 2093:    if ((parent == NULL) || (item == NULL))
    %%%%%: 2093-block  0
    %%%%%: 2093-block  1
        -: 2094:    {
    #####: 2095:        return NULL;
    %%%%%: 2095-block  0
        -: 2096:    }
        -: 2097:
    #####: 2098:    if (item->prev != NULL)
    %%%%%: 2098-block  0
        -: 2099:    {
        -: 2100:        /* not the first element */
    #####: 2101:        item->prev->next = item->next;
    %%%%%: 2101-block  0
        -: 2102:    }
    #####: 2103:    if (item->next != NULL)
    %%%%%: 2103-block  0
        -: 2104:    {
        -: 2105:        /* not the last element */
    #####: 2106:        item->next->prev = item->prev;
    %%%%%: 2106-block  0
        -: 2107:    }
        -: 2108:
    #####: 2109:    if (item == parent->child)
    %%%%%: 2109-block  0
        -: 2110:    {
        -: 2111:        /* first element */
    #####: 2112:        parent->child = item->next;
    %%%%%: 2112-block  0
        -: 2113:    }
        -: 2114:    /* make sure the detached item doesn't point anywhere anymore */
    #####: 2115:    item->prev = NULL;
    #####: 2116:    item->next = NULL;
        -: 2117:
    #####: 2118:    return item;
    %%%%%: 2118-block  0
        -: 2119:}
        -: 2120:
    #####: 2121:CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromArray(cJSON *array, int which)
        -: 2122:{
    #####: 2123:    if (which < 0)
    %%%%%: 2123-block  0
        -: 2124:    {
    #####: 2125:        return NULL;
    %%%%%: 2125-block  0
        -: 2126:    }
        -: 2127:
    #####: 2128:    return cJSON_DetachItemViaPointer(array, get_array_item(array, (size_t)which));
    %%%%%: 2128-block  0
        -: 2129:}
        -: 2130:
    #####: 2131:CJSON_PUBLIC(void) cJSON_DeleteItemFromArray(cJSON *array, int which)
        -: 2132:{
    #####: 2133:    cJSON_Delete(cJSON_DetachItemFromArray(array, which));
    %%%%%: 2133-block  0
    #####: 2134:}
        -: 2135:
    #####: 2136:CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObject(cJSON *object, const char *string)
        -: 2137:{
    #####: 2138:    cJSON *to_detach = cJSON_GetObjectItem(object, string);
    %%%%%: 2138-block  0
        -: 2139:
    #####: 2140:    return cJSON_DetachItemViaPointer(object, to_detach);
        -: 2141:}
        -: 2142:
    #####: 2143:CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObjectCaseSensitive(cJSON *object, const char *string)
        -: 2144:{
    #####: 2145:    cJSON *to_detach = cJSON_GetObjectItemCaseSensitive(object, string);
    %%%%%: 2145-block  0
        -: 2146:
    #####: 2147:    return cJSON_DetachItemViaPointer(object, to_detach);
        -: 2148:}
        -: 2149:
    #####: 2150:CJSON_PUBLIC(void) cJSON_DeleteItemFromObject(cJSON *object, const char *string)
        -: 2151:{
    #####: 2152:    cJSON_Delete(cJSON_DetachItemFromObject(object, string));
    %%%%%: 2152-block  0
    #####: 2153:}
        -: 2154:
    #####: 2155:CJSON_PUBLIC(void) cJSON_DeleteItemFromObjectCaseSensitive(cJSON *object, const char *string)
        -: 2156:{
    #####: 2157:    cJSON_Delete(cJSON_DetachItemFromObjectCaseSensitive(object, string));
    %%%%%: 2157-block  0
    #####: 2158:}
        -: 2159:
        -: 2160:/* Replace array/object items with new ones. */
    #####: 2161:CJSON_PUBLIC(void) cJSON_InsertItemInArray(cJSON *array, int which, cJSON *newitem)
        -: 2162:{
    #####: 2163:    cJSON *after_inserted = NULL;
        -: 2164:
    #####: 2165:    if (which < 0)
    %%%%%: 2165-block  0
        -: 2166:    {
    #####: 2167:        return;
    %%%%%: 2167-block  0
        -: 2168:    }
        -: 2169:
    #####: 2170:    after_inserted = get_array_item(array, (size_t)which);
    %%%%%: 2170-block  0
    #####: 2171:    if (after_inserted == NULL)
        -: 2172:    {
    #####: 2173:        add_item_to_array(array, newitem);
    %%%%%: 2173-block  0
    #####: 2174:        return;
        -: 2175:    }
        -: 2176:
    #####: 2177:    newitem->next = after_inserted;
    #####: 2178:    newitem->prev = after_inserted->prev;
    #####: 2179:    after_inserted->prev = newitem;
    #####: 2180:    if (after_inserted == array->child)
    %%%%%: 2180-block  0
        -: 2181:    {
    #####: 2182:        array->child = newitem;
    %%%%%: 2182-block  0
        -: 2183:    }
        -: 2184:    else
        -: 2185:    {
    #####: 2186:        newitem->prev->next = newitem;
    %%%%%: 2186-block  0
        -: 2187:    }
        -: 2188:}
        -: 2189:
    #####: 2190:CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemViaPointer(cJSON * const parent, cJSON * const item, cJSON * replacement)
        -: 2191:{
    #####: 2192:    if ((parent == NULL) || (replacement == NULL) || (item == NULL))
    %%%%%: 2192-block  0
    %%%%%: 2192-block  1
    %%%%%: 2192-block  2
        -: 2193:    {
    #####: 2194:        return false;
    %%%%%: 2194-block  0
        -: 2195:    }
        -: 2196:
    #####: 2197:    if (replacement == item)
    %%%%%: 2197-block  0
        -: 2198:    {
    #####: 2199:        return true;
    %%%%%: 2199-block  0
        -: 2200:    }
        -: 2201:
    #####: 2202:    replacement->next = item->next;
    #####: 2203:    replacement->prev = item->prev;
        -: 2204:
    #####: 2205:    if (replacement->next != NULL)
    %%%%%: 2205-block  0
        -: 2206:    {
    #####: 2207:        replacement->next->prev = replacement;
    %%%%%: 2207-block  0
        -: 2208:    }
    #####: 2209:    if (replacement->prev != NULL)
    %%%%%: 2209-block  0
        -: 2210:    {
    #####: 2211:        replacement->prev->next = replacement;
    %%%%%: 2211-block  0
        -: 2212:    }
    #####: 2213:    if (parent->child == item)
    %%%%%: 2213-block  0
        -: 2214:    {
    #####: 2215:        parent->child = replacement;
    %%%%%: 2215-block  0
        -: 2216:    }
        -: 2217:
    #####: 2218:    item->next = NULL;
    #####: 2219:    item->prev = NULL;
    #####: 2220:    cJSON_Delete(item);
    %%%%%: 2220-block  0
        -: 2221:
    #####: 2222:    return true;
        -: 2223:}
        -: 2224:
    #####: 2225:CJSON_PUBLIC(void) cJSON_ReplaceItemInArray(cJSON *array, int which, cJSON *newitem)
        -: 2226:{
    #####: 2227:    if (which < 0)
    %%%%%: 2227-block  0
        -: 2228:    {
    #####: 2229:        return;
    %%%%%: 2229-block  0
        -: 2230:    }
        -: 2231:
    #####: 2232:    cJSON_ReplaceItemViaPointer(array, get_array_item(array, (size_t)which), newitem);
    %%%%%: 2232-block  0
        -: 2233:}
        -: 2234:
    #####: 2235:static cJSON_bool replace_item_in_object(cJSON *object, const char *string, cJSON *replacement, cJSON_bool case_sensitive)
        -: 2236:{
    #####: 2237:    if ((replacement == NULL) || (string == NULL))
    %%%%%: 2237-block  0
    %%%%%: 2237-block  1
        -: 2238:    {
    #####: 2239:        return false;
    %%%%%: 2239-block  0
        -: 2240:    }
        -: 2241:
        -: 2242:    /* replace the name in the replacement */
    #####: 2243:    if (!(replacement->type & cJSON_StringIsConst) && (replacement->string != NULL))
    %%%%%: 2243-block  0
    %%%%%: 2243-block  1
        -: 2244:    {
    #####: 2245:        cJSON_free(replacement->string);
    %%%%%: 2245-block  0
        -: 2246:    }
    #####: 2247:    replacement->string = (char*)cJSON_strdup((const unsigned char*)string, &global_hooks);
    %%%%%: 2247-block  0
    #####: 2248:    replacement->type &= ~cJSON_StringIsConst;
        -: 2249:
    #####: 2250:    cJSON_ReplaceItemViaPointer(object, get_object_item(object, string, case_sensitive), replacement);
        -: 2251:
    #####: 2252:    return true;
        -: 2253:}
        -: 2254:
    #####: 2255:CJSON_PUBLIC(void) cJSON_ReplaceItemInObject(cJSON *object, const char *string, cJSON *newitem)
        -: 2256:{
    #####: 2257:    replace_item_in_object(object, string, newitem, false);
    %%%%%: 2257-block  0
    #####: 2258:}
        -: 2259:
    #####: 2260:CJSON_PUBLIC(void) cJSON_ReplaceItemInObjectCaseSensitive(cJSON *object, const char *string, cJSON *newitem)
        -: 2261:{
    #####: 2262:    replace_item_in_object(object, string, newitem, true);
    %%%%%: 2262-block  0
    #####: 2263:}
        -: 2264:
        -: 2265:/* Create basic types: */
    #####: 2266:CJSON_PUBLIC(cJSON *) cJSON_CreateNull(void)
        -: 2267:{
    #####: 2268:    cJSON *item = cJSON_New_Item(&global_hooks);
    %%%%%: 2268-block  0
    #####: 2269:    if(item)
        -: 2270:    {
    #####: 2271:        item->type = cJSON_NULL;
    %%%%%: 2271-block  0
        -: 2272:    }
        -: 2273:
    #####: 2274:    return item;
    %%%%%: 2274-block  0
        -: 2275:}
        -: 2276:
    #####: 2277:CJSON_PUBLIC(cJSON *) cJSON_CreateTrue(void)
        -: 2278:{
    #####: 2279:    cJSON *item = cJSON_New_Item(&global_hooks);
    %%%%%: 2279-block  0
    #####: 2280:    if(item)
        -: 2281:    {
    #####: 2282:        item->type = cJSON_True;
    %%%%%: 2282-block  0
        -: 2283:    }
        -: 2284:
    #####: 2285:    return item;
    %%%%%: 2285-block  0
        -: 2286:}
        -: 2287:
    #####: 2288:CJSON_PUBLIC(cJSON *) cJSON_CreateFalse(void)
        -: 2289:{
    #####: 2290:    cJSON *item = cJSON_New_Item(&global_hooks);
    %%%%%: 2290-block  0
    #####: 2291:    if(item)
        -: 2292:    {
    #####: 2293:        item->type = cJSON_False;
    %%%%%: 2293-block  0
        -: 2294:    }
        -: 2295:
    #####: 2296:    return item;
    %%%%%: 2296-block  0
        -: 2297:}
        -: 2298:
    #####: 2299:CJSON_PUBLIC(cJSON *) cJSON_CreateBool(cJSON_bool boolean)
        -: 2300:{
    #####: 2301:    cJSON *item = cJSON_New_Item(&global_hooks);
    %%%%%: 2301-block  0
    #####: 2302:    if(item)
        -: 2303:    {
    #####: 2304:        item->type = boolean ? cJSON_True : cJSON_False;
    %%%%%: 2304-block  0
    %%%%%: 2304-block  1
    %%%%%: 2304-block  2
    %%%%%: 2304-block  3
        -: 2305:    }
        -: 2306:
    #####: 2307:    return item;
    %%%%%: 2307-block  0
        -: 2308:}
        -: 2309:
    #####: 2310:CJSON_PUBLIC(cJSON *) cJSON_CreateNumber(double num)
        -: 2311:{
    #####: 2312:    cJSON *item = cJSON_New_Item(&global_hooks);
    %%%%%: 2312-block  0
    #####: 2313:    if(item)
        -: 2314:    {
    #####: 2315:        item->type = cJSON_Number;
    #####: 2316:        item->valuedouble = num;
        -: 2317:
        -: 2318:        /* use saturation in case of overflow */
    #####: 2319:        if (num >= INT_MAX)
    %%%%%: 2319-block  0
        -: 2320:        {
    #####: 2321:            item->valueint = INT_MAX;
    %%%%%: 2321-block  0
        -: 2322:        }
    #####: 2323:        else if (num <= (double)INT_MIN)
    %%%%%: 2323-block  0
        -: 2324:        {
    #####: 2325:            item->valueint = INT_MIN;
    %%%%%: 2325-block  0
        -: 2326:        }
        -: 2327:        else
        -: 2328:        {
    #####: 2329:            item->valueint = (int)num;
    %%%%%: 2329-block  0
        -: 2330:        }
        -: 2331:    }
        -: 2332:
    #####: 2333:    return item;
    %%%%%: 2333-block  0
        -: 2334:}
        -: 2335:
    #####: 2336:CJSON_PUBLIC(cJSON *) cJSON_CreateString(const char *string)
        -: 2337:{
    #####: 2338:    cJSON *item = cJSON_New_Item(&global_hooks);
    %%%%%: 2338-block  0
    #####: 2339:    if(item)
        -: 2340:    {
    #####: 2341:        item->type = cJSON_String;
    #####: 2342:        item->valuestring = (char*)cJSON_strdup((const unsigned char*)string, &global_hooks);
    %%%%%: 2342-block  0
    #####: 2343:        if(!item->valuestring)
        -: 2344:        {
    #####: 2345:            cJSON_Delete(item);
    %%%%%: 2345-block  0
    #####: 2346:            return NULL;
        -: 2347:        }
        -: 2348:    }
        -: 2349:
    #####: 2350:    return item;
    %%%%%: 2350-block  0
        -: 2351:}
        -: 2352:
    #####: 2353:CJSON_PUBLIC(cJSON *) cJSON_CreateStringReference(const char *string)
        -: 2354:{
    #####: 2355:    cJSON *item = cJSON_New_Item(&global_hooks);
    %%%%%: 2355-block  0
    #####: 2356:    if (item != NULL)
        -: 2357:    {
    #####: 2358:        item->type = cJSON_String | cJSON_IsReference;
    #####: 2359:        item->valuestring = (char*)cast_away_const(string);
    %%%%%: 2359-block  0
        -: 2360:    }
        -: 2361:
    #####: 2362:    return item;
    %%%%%: 2362-block  0
        -: 2363:}
        -: 2364:
    #####: 2365:CJSON_PUBLIC(cJSON *) cJSON_CreateObjectReference(const cJSON *child)
        -: 2366:{
    #####: 2367:    cJSON *item = cJSON_New_Item(&global_hooks);
    %%%%%: 2367-block  0
    #####: 2368:    if (item != NULL) {
    #####: 2369:        item->type = cJSON_Object | cJSON_IsReference;
    #####: 2370:        item->child = (cJSON*)cast_away_const(child);
    %%%%%: 2370-block  0
        -: 2371:    }
        -: 2372:
    #####: 2373:    return item;
    %%%%%: 2373-block  0
        -: 2374:}
        -: 2375:
    #####: 2376:CJSON_PUBLIC(cJSON *) cJSON_CreateArrayReference(const cJSON *child) {
    #####: 2377:    cJSON *item = cJSON_New_Item(&global_hooks);
    %%%%%: 2377-block  0
    #####: 2378:    if (item != NULL) {
    #####: 2379:        item->type = cJSON_Array | cJSON_IsReference;
    #####: 2380:        item->child = (cJSON*)cast_away_const(child);
    %%%%%: 2380-block  0
        -: 2381:    }
        -: 2382:
    #####: 2383:    return item;
    %%%%%: 2383-block  0
        -: 2384:}
        -: 2385:
    #####: 2386:CJSON_PUBLIC(cJSON *) cJSON_CreateRaw(const char *raw)
        -: 2387:{
    #####: 2388:    cJSON *item = cJSON_New_Item(&global_hooks);
    %%%%%: 2388-block  0
    #####: 2389:    if(item)
        -: 2390:    {
    #####: 2391:        item->type = cJSON_Raw;
    #####: 2392:        item->valuestring = (char*)cJSON_strdup((const unsigned char*)raw, &global_hooks);
    %%%%%: 2392-block  0
    #####: 2393:        if(!item->valuestring)
        -: 2394:        {
    #####: 2395:            cJSON_Delete(item);
    %%%%%: 2395-block  0
    #####: 2396:            return NULL;
        -: 2397:        }
        -: 2398:    }
        -: 2399:
    #####: 2400:    return item;
    %%%%%: 2400-block  0
        -: 2401:}
        -: 2402:
    #####: 2403:CJSON_PUBLIC(cJSON *) cJSON_CreateArray(void)
        -: 2404:{
    #####: 2405:    cJSON *item = cJSON_New_Item(&global_hooks);
    %%%%%: 2405-block  0
    #####: 2406:    if(item)
        -: 2407:    {
    #####: 2408:        item->type=cJSON_Array;
    %%%%%: 2408-block  0
        -: 2409:    }
        -: 2410:
    #####: 2411:    return item;
    %%%%%: 2411-block  0
        -: 2412:}
        -: 2413:
    #####: 2414:CJSON_PUBLIC(cJSON *) cJSON_CreateObject(void)
        -: 2415:{
    #####: 2416:    cJSON *item = cJSON_New_Item(&global_hooks);
    %%%%%: 2416-block  0
    #####: 2417:    if (item)
        -: 2418:    {
    #####: 2419:        item->type = cJSON_Object;
    %%%%%: 2419-block  0
        -: 2420:    }
        -: 2421:
    #####: 2422:    return item;
    %%%%%: 2422-block  0
        -: 2423:}
        -: 2424:
        -: 2425:/* Create Arrays: */
    #####: 2426:CJSON_PUBLIC(cJSON *) cJSON_CreateIntArray(const int *numbers, int count)
        -: 2427:{
    #####: 2428:    size_t i = 0;
    #####: 2429:    cJSON *n = NULL;
    #####: 2430:    cJSON *p = NULL;
    #####: 2431:    cJSON *a = NULL;
        -: 2432:
    #####: 2433:    if ((count < 0) || (numbers == NULL))
    %%%%%: 2433-block  0
    %%%%%: 2433-block  1
        -: 2434:    {
    #####: 2435:        return NULL;
    %%%%%: 2435-block  0
        -: 2436:    }
        -: 2437:
    #####: 2438:    a = cJSON_CreateArray();
    %%%%%: 2438-block  0
    #####: 2439:    for(i = 0; a && (i < (size_t)count); i++)
    %%%%%: 2439-block  0
    %%%%%: 2439-block  1
        -: 2440:    {
    #####: 2441:        n = cJSON_CreateNumber(numbers[i]);
    %%%%%: 2441-block  0
    #####: 2442:        if (!n)
        -: 2443:        {
    #####: 2444:            cJSON_Delete(a);
    %%%%%: 2444-block  0
    #####: 2445:            return NULL;
        -: 2446:        }
    #####: 2447:        if(!i)
    %%%%%: 2447-block  0
        -: 2448:        {
    #####: 2449:            a->child = n;
    %%%%%: 2449-block  0
        -: 2450:        }
        -: 2451:        else
        -: 2452:        {
    #####: 2453:            suffix_object(p, n);
    %%%%%: 2453-block  0
        -: 2454:        }
    #####: 2455:        p = n;
    %%%%%: 2455-block  0
        -: 2456:    }
        -: 2457:
    #####: 2458:    return a;
    %%%%%: 2458-block  0
        -: 2459:}
        -: 2460:
    #####: 2461:CJSON_PUBLIC(cJSON *) cJSON_CreateFloatArray(const float *numbers, int count)
        -: 2462:{
    #####: 2463:    size_t i = 0;
    #####: 2464:    cJSON *n = NULL;
    #####: 2465:    cJSON *p = NULL;
    #####: 2466:    cJSON *a = NULL;
        -: 2467:
    #####: 2468:    if ((count < 0) || (numbers == NULL))
    %%%%%: 2468-block  0
    %%%%%: 2468-block  1
        -: 2469:    {
    #####: 2470:        return NULL;
    %%%%%: 2470-block  0
        -: 2471:    }
        -: 2472:
    #####: 2473:    a = cJSON_CreateArray();
    %%%%%: 2473-block  0
        -: 2474:
    #####: 2475:    for(i = 0; a && (i < (size_t)count); i++)
    %%%%%: 2475-block  0
    %%%%%: 2475-block  1
        -: 2476:    {
    #####: 2477:        n = cJSON_CreateNumber((double)numbers[i]);
    %%%%%: 2477-block  0
    #####: 2478:        if(!n)
        -: 2479:        {
    #####: 2480:            cJSON_Delete(a);
    %%%%%: 2480-block  0
    #####: 2481:            return NULL;
        -: 2482:        }
    #####: 2483:        if(!i)
    %%%%%: 2483-block  0
        -: 2484:        {
    #####: 2485:            a->child = n;
    %%%%%: 2485-block  0
        -: 2486:        }
        -: 2487:        else
        -: 2488:        {
    #####: 2489:            suffix_object(p, n);
    %%%%%: 2489-block  0
        -: 2490:        }
    #####: 2491:        p = n;
    %%%%%: 2491-block  0
        -: 2492:    }
        -: 2493:
    #####: 2494:    return a;
    %%%%%: 2494-block  0
        -: 2495:}
        -: 2496:
    #####: 2497:CJSON_PUBLIC(cJSON *) cJSON_CreateDoubleArray(const double *numbers, int count)
        -: 2498:{
    #####: 2499:    size_t i = 0;
    #####: 2500:    cJSON *n = NULL;
    #####: 2501:    cJSON *p = NULL;
    #####: 2502:    cJSON *a = NULL;
        -: 2503:
    #####: 2504:    if ((count < 0) || (numbers == NULL))
    %%%%%: 2504-block  0
    %%%%%: 2504-block  1
        -: 2505:    {
    #####: 2506:        return NULL;
    %%%%%: 2506-block  0
        -: 2507:    }
        -: 2508:
    #####: 2509:    a = cJSON_CreateArray();
    %%%%%: 2509-block  0
        -: 2510:
    #####: 2511:    for(i = 0;a && (i < (size_t)count); i++)
    %%%%%: 2511-block  0
    %%%%%: 2511-block  1
        -: 2512:    {
    #####: 2513:        n = cJSON_CreateNumber(numbers[i]);
    %%%%%: 2513-block  0
    #####: 2514:        if(!n)
        -: 2515:        {
    #####: 2516:            cJSON_Delete(a);
    %%%%%: 2516-block  0
    #####: 2517:            return NULL;
        -: 2518:        }
    #####: 2519:        if(!i)
    %%%%%: 2519-block  0
        -: 2520:        {
    #####: 2521:            a->child = n;
    %%%%%: 2521-block  0
        -: 2522:        }
        -: 2523:        else
        -: 2524:        {
    #####: 2525:            suffix_object(p, n);
    %%%%%: 2525-block  0
        -: 2526:        }
    #####: 2527:        p = n;
    %%%%%: 2527-block  0
        -: 2528:    }
        -: 2529:
    #####: 2530:    return a;
    %%%%%: 2530-block  0
        -: 2531:}
        -: 2532:
    #####: 2533:CJSON_PUBLIC(cJSON *) cJSON_CreateStringArray(const char *const *strings, int count)
        -: 2534:{
    #####: 2535:    size_t i = 0;
    #####: 2536:    cJSON *n = NULL;
    #####: 2537:    cJSON *p = NULL;
    #####: 2538:    cJSON *a = NULL;
        -: 2539:
    #####: 2540:    if ((count < 0) || (strings == NULL))
    %%%%%: 2540-block  0
    %%%%%: 2540-block  1
        -: 2541:    {
    #####: 2542:        return NULL;
    %%%%%: 2542-block  0
        -: 2543:    }
        -: 2544:
    #####: 2545:    a = cJSON_CreateArray();
    %%%%%: 2545-block  0
        -: 2546:
    #####: 2547:    for (i = 0; a && (i < (size_t)count); i++)
    %%%%%: 2547-block  0
    %%%%%: 2547-block  1
        -: 2548:    {
    #####: 2549:        n = cJSON_CreateString(strings[i]);
    %%%%%: 2549-block  0
    #####: 2550:        if(!n)
        -: 2551:        {
    #####: 2552:            cJSON_Delete(a);
    %%%%%: 2552-block  0
    #####: 2553:            return NULL;
        -: 2554:        }
    #####: 2555:        if(!i)
    %%%%%: 2555-block  0
        -: 2556:        {
    #####: 2557:            a->child = n;
    %%%%%: 2557-block  0
        -: 2558:        }
        -: 2559:        else
        -: 2560:        {
    #####: 2561:            suffix_object(p,n);
    %%%%%: 2561-block  0
        -: 2562:        }
    #####: 2563:        p = n;
    %%%%%: 2563-block  0
        -: 2564:    }
        -: 2565:
    #####: 2566:    return a;
    %%%%%: 2566-block  0
        -: 2567:}
        -: 2568:
        -: 2569:/* Duplication */
    #####: 2570:CJSON_PUBLIC(cJSON *) cJSON_Duplicate(const cJSON *item, cJSON_bool recurse)
        -: 2571:{
    #####: 2572:    cJSON *newitem = NULL;
    #####: 2573:    cJSON *child = NULL;
    #####: 2574:    cJSON *next = NULL;
    #####: 2575:    cJSON *newchild = NULL;
        -: 2576:
        -: 2577:    /* Bail on bad ptr */
    #####: 2578:    if (!item)
    %%%%%: 2578-block  0
        -: 2579:    {
    #####: 2580:        goto fail;
    %%%%%: 2580-block  0
        -: 2581:    }
        -: 2582:    /* Create new item */
    #####: 2583:    newitem = cJSON_New_Item(&global_hooks);
    %%%%%: 2583-block  0
    #####: 2584:    if (!newitem)
        -: 2585:    {
    #####: 2586:        goto fail;
    %%%%%: 2586-block  0
        -: 2587:    }
        -: 2588:    /* Copy over all vars */
    #####: 2589:    newitem->type = item->type & (~cJSON_IsReference);
    #####: 2590:    newitem->valueint = item->valueint;
    #####: 2591:    newitem->valuedouble = item->valuedouble;
    #####: 2592:    if (item->valuestring)
    %%%%%: 2592-block  0
        -: 2593:    {
    #####: 2594:        newitem->valuestring = (char*)cJSON_strdup((unsigned char*)item->valuestring, &global_hooks);
    %%%%%: 2594-block  0
    #####: 2595:        if (!newitem->valuestring)
        -: 2596:        {
    #####: 2597:            goto fail;
    %%%%%: 2597-block  0
        -: 2598:        }
        -: 2599:    }
    #####: 2600:    if (item->string)
    %%%%%: 2600-block  0
        -: 2601:    {
    #####: 2602:        newitem->string = (item->type&cJSON_StringIsConst) ? item->string : (char*)cJSON_strdup((unsigned char*)item->string, &global_hooks);
    %%%%%: 2602-block  0
    %%%%%: 2602-block  1
    %%%%%: 2602-block  2
    #####: 2603:        if (!newitem->string)
    %%%%%: 2603-block  0
        -: 2604:        {
    #####: 2605:            goto fail;
    %%%%%: 2605-block  0
        -: 2606:        }
        -: 2607:    }
        -: 2608:    /* If non-recursive, then we're done! */
    #####: 2609:    if (!recurse)
    %%%%%: 2609-block  0
        -: 2610:    {
    #####: 2611:        return newitem;
    %%%%%: 2611-block  0
        -: 2612:    }
        -: 2613:    /* Walk the ->next chain for the child. */
    #####: 2614:    child = item->child;
    %%%%%: 2614-block  0
    #####: 2615:    while (child != NULL)
    %%%%%: 2615-block  0
        -: 2616:    {
    #####: 2617:        newchild = cJSON_Duplicate(child, true); /* Duplicate (with recurse) each item in the ->next chain */
    %%%%%: 2617-block  0
    #####: 2618:        if (!newchild)
        -: 2619:        {
    #####: 2620:            goto fail;
    %%%%%: 2620-block  0
        -: 2621:        }
    #####: 2622:        if (next != NULL)
    %%%%%: 2622-block  0
        -: 2623:        {
        -: 2624:            /* If newitem->child already set, then crosswire ->prev and ->next and move on */
    #####: 2625:            next->next = newchild;
    #####: 2626:            newchild->prev = next;
    #####: 2627:            next = newchild;
    %%%%%: 2627-block  0
        -: 2628:        }
        -: 2629:        else
        -: 2630:        {
        -: 2631:            /* Set newitem->child and move to it */
    #####: 2632:            newitem->child = newchild;
    #####: 2633:            next = newchild;
    %%%%%: 2633-block  0
        -: 2634:        }
    #####: 2635:        child = child->next;
    %%%%%: 2635-block  0
        -: 2636:    }
        -: 2637:
    #####: 2638:    return newitem;
    %%%%%: 2638-block  0
        -: 2639:
    #####: 2640:fail:
    #####: 2641:    if (newitem != NULL)
    %%%%%: 2641-block  0
        -: 2642:    {
    #####: 2643:        cJSON_Delete(newitem);
    %%%%%: 2643-block  0
        -: 2644:    }
        -: 2645:
    #####: 2646:    return NULL;
    %%%%%: 2646-block  0
        -: 2647:}
        -: 2648:
    #####: 2649:static void skip_oneline_comment(char **input)
        -: 2650:{
    #####: 2651:    *input += static_strlen("//");
    %%%%%: 2651-block  0
        -: 2652:
    #####: 2653:    for (; (*input)[0] != '\0'; ++(*input))
    %%%%%: 2653-block  0
    %%%%%: 2653-block  1
        -: 2654:    {
    #####: 2655:        if ((*input)[0] == '\n') {
    %%%%%: 2655-block  0
    #####: 2656:            *input += static_strlen("\n");
    #####: 2657:            return;
    %%%%%: 2657-block  0
        -: 2658:        }
        -: 2659:    }
        -: 2660:}
        -: 2661:
    #####: 2662:static void skip_multiline_comment(char **input)
        -: 2663:{
    #####: 2664:    *input += static_strlen("/*");
    %%%%%: 2664-block  0
        -: 2665:
    #####: 2666:    for (; (*input)[0] != '\0'; ++(*input))
    %%%%%: 2666-block  0
    %%%%%: 2666-block  1
        -: 2667:    {
    #####: 2668:        if (((*input)[0] == '*') && ((*input)[1] == '/'))
    %%%%%: 2668-block  0
    %%%%%: 2668-block  1
        -: 2669:        {
    #####: 2670:            *input += static_strlen("*/");
    #####: 2671:            return;
    %%%%%: 2671-block  0
        -: 2672:        }
        -: 2673:    }
        -: 2674:}
        -: 2675:
    #####: 2676:static void minify_string(char **input, char **output) {
    #####: 2677:    (*output)[0] = (*input)[0];
    #####: 2678:    *input += static_strlen("\"");
    #####: 2679:    *output += static_strlen("\"");
    %%%%%: 2679-block  0
        -: 2680:
        -: 2681:
    #####: 2682:    for (; (*input)[0] != '\0'; (void)++(*input), ++(*output)) {
    %%%%%: 2682-block  0
    %%%%%: 2682-block  1
    #####: 2683:        (*output)[0] = (*input)[0];
        -: 2684:
    #####: 2685:        if ((*input)[0] == '\"') {
    %%%%%: 2685-block  0
    #####: 2686:            (*output)[0] = '\"';
    #####: 2687:            *input += static_strlen("\"");
    #####: 2688:            *output += static_strlen("\"");
    #####: 2689:            return;
    %%%%%: 2689-block  0
    #####: 2690:        } else if (((*input)[0] == '\\') && ((*input)[1] == '\"')) {
    %%%%%: 2690-block  0
    %%%%%: 2690-block  1
    #####: 2691:            (*output)[1] = (*input)[1];
    #####: 2692:            *input += static_strlen("\"");
    #####: 2693:            *output += static_strlen("\"");
    %%%%%: 2693-block  0
        -: 2694:        }
        -: 2695:    }
        -: 2696:}
        -: 2697:
    #####: 2698:CJSON_PUBLIC(void) cJSON_Minify(char *json)
        -: 2699:{
    #####: 2700:    char *into = json;
        -: 2701:
    #####: 2702:    if (json == NULL)
    %%%%%: 2702-block  0
        -: 2703:    {
    #####: 2704:        return;
    %%%%%: 2704-block  0
        -: 2705:    }
        -: 2706:
    #####: 2707:    while (json[0] != '\0')
    %%%%%: 2707-block  0
    %%%%%: 2707-block  1
        -: 2708:    {
    #####: 2709:        switch (json[0])
    %%%%%: 2709-block  0
        -: 2710:        {
    #####: 2711:            case ' ':
        -: 2712:            case '\t':
        -: 2713:            case '\r':
        -: 2714:            case '\n':
    #####: 2715:                json++;
    #####: 2716:                break;
    %%%%%: 2716-block  0
        -: 2717:
    #####: 2718:            case '/':
    #####: 2719:                if (json[1] == '/')
    %%%%%: 2719-block  0
        -: 2720:                {
    #####: 2721:                    skip_oneline_comment(&json);
    %%%%%: 2721-block  0
        -: 2722:                }
    #####: 2723:                else if (json[1] == '*')
    %%%%%: 2723-block  0
        -: 2724:                {
    #####: 2725:                    skip_multiline_comment(&json);
    %%%%%: 2725-block  0
        -: 2726:                } else {
    #####: 2727:                    json++;
    %%%%%: 2727-block  0
        -: 2728:                }
    #####: 2729:                break;
    %%%%%: 2729-block  0
        -: 2730:
    #####: 2731:            case '\"':
    #####: 2732:                minify_string(&json, (char**)&into);
    %%%%%: 2732-block  0
    #####: 2733:                break;
        -: 2734:
    #####: 2735:            default:
    #####: 2736:                into[0] = json[0];
    #####: 2737:                json++;
    #####: 2738:                into++;
    %%%%%: 2738-block  0
        -: 2739:        }
        -: 2740:    }
        -: 2741:
        -: 2742:    /* and null-terminate. */
    #####: 2743:    *into = '\0';
    %%%%%: 2743-block  0
        -: 2744:}
        -: 2745:
    #####: 2746:CJSON_PUBLIC(cJSON_bool) cJSON_IsInvalid(const cJSON * const item)
        -: 2747:{
    #####: 2748:    if (item == NULL)
    %%%%%: 2748-block  0
        -: 2749:    {
    #####: 2750:        return false;
    %%%%%: 2750-block  0
        -: 2751:    }
        -: 2752:
    #####: 2753:    return (item->type & 0xFF) == cJSON_Invalid;
    %%%%%: 2753-block  0
        -: 2754:}
        -: 2755:
    #####: 2756:CJSON_PUBLIC(cJSON_bool) cJSON_IsFalse(const cJSON * const item)
        -: 2757:{
    #####: 2758:    if (item == NULL)
    %%%%%: 2758-block  0
        -: 2759:    {
    #####: 2760:        return false;
    %%%%%: 2760-block  0
        -: 2761:    }
        -: 2762:
    #####: 2763:    return (item->type & 0xFF) == cJSON_False;
    %%%%%: 2763-block  0
        -: 2764:}
        -: 2765:
    #####: 2766:CJSON_PUBLIC(cJSON_bool) cJSON_IsTrue(const cJSON * const item)
        -: 2767:{
    #####: 2768:    if (item == NULL)
    %%%%%: 2768-block  0
        -: 2769:    {
    #####: 2770:        return false;
    %%%%%: 2770-block  0
        -: 2771:    }
        -: 2772:
    #####: 2773:    return (item->type & 0xff) == cJSON_True;
    %%%%%: 2773-block  0
        -: 2774:}
        -: 2775:
        -: 2776:
    #####: 2777:CJSON_PUBLIC(cJSON_bool) cJSON_IsBool(const cJSON * const item)
        -: 2778:{
    #####: 2779:    if (item == NULL)
    %%%%%: 2779-block  0
        -: 2780:    {
    #####: 2781:        return false;
    %%%%%: 2781-block  0
        -: 2782:    }
        -: 2783:
    #####: 2784:    return (item->type & (cJSON_True | cJSON_False)) != 0;
    %%%%%: 2784-block  0
        -: 2785:}
    #####: 2786:CJSON_PUBLIC(cJSON_bool) cJSON_IsNull(const cJSON * const item)
        -: 2787:{
    #####: 2788:    if (item == NULL)
    %%%%%: 2788-block  0
        -: 2789:    {
    #####: 2790:        return false;
    %%%%%: 2790-block  0
        -: 2791:    }
        -: 2792:
    #####: 2793:    return (item->type & 0xFF) == cJSON_NULL;
    %%%%%: 2793-block  0
        -: 2794:}
        -: 2795:
    #####: 2796:CJSON_PUBLIC(cJSON_bool) cJSON_IsNumber(const cJSON * const item)
        -: 2797:{
    #####: 2798:    if (item == NULL)
    %%%%%: 2798-block  0
        -: 2799:    {
    #####: 2800:        return false;
    %%%%%: 2800-block  0
        -: 2801:    }
        -: 2802:
    #####: 2803:    return (item->type & 0xFF) == cJSON_Number;
    %%%%%: 2803-block  0
        -: 2804:}
        -: 2805:
    #####: 2806:CJSON_PUBLIC(cJSON_bool) cJSON_IsString(const cJSON * const item)
        -: 2807:{
    #####: 2808:    if (item == NULL)
    %%%%%: 2808-block  0
        -: 2809:    {
    #####: 2810:        return false;
    %%%%%: 2810-block  0
        -: 2811:    }
        -: 2812:
    #####: 2813:    return (item->type & 0xFF) == cJSON_String;
    %%%%%: 2813-block  0
        -: 2814:}
        -: 2815:
    #####: 2816:CJSON_PUBLIC(cJSON_bool) cJSON_IsArray(const cJSON * const item)
        -: 2817:{
    #####: 2818:    if (item == NULL)
    %%%%%: 2818-block  0
        -: 2819:    {
    #####: 2820:        return false;
    %%%%%: 2820-block  0
        -: 2821:    }
        -: 2822:
    #####: 2823:    return (item->type & 0xFF) == cJSON_Array;
    %%%%%: 2823-block  0
        -: 2824:}
        -: 2825:
    #####: 2826:CJSON_PUBLIC(cJSON_bool) cJSON_IsObject(const cJSON * const item)
        -: 2827:{
    #####: 2828:    if (item == NULL)
    %%%%%: 2828-block  0
        -: 2829:    {
    #####: 2830:        return false;
    %%%%%: 2830-block  0
        -: 2831:    }
        -: 2832:
    #####: 2833:    return (item->type & 0xFF) == cJSON_Object;
    %%%%%: 2833-block  0
        -: 2834:}
        -: 2835:
    #####: 2836:CJSON_PUBLIC(cJSON_bool) cJSON_IsRaw(const cJSON * const item)
        -: 2837:{
    #####: 2838:    if (item == NULL)
    %%%%%: 2838-block  0
        -: 2839:    {
    #####: 2840:        return false;
    %%%%%: 2840-block  0
        -: 2841:    }
        -: 2842:
    #####: 2843:    return (item->type & 0xFF) == cJSON_Raw;
    %%%%%: 2843-block  0
        -: 2844:}
        -: 2845:
    #####: 2846:CJSON_PUBLIC(cJSON_bool) cJSON_Compare(const cJSON * const a, const cJSON * const b, const cJSON_bool case_sensitive)
        -: 2847:{
    #####: 2848:    if ((a == NULL) || (b == NULL) || ((a->type & 0xFF) != (b->type & 0xFF)) || cJSON_IsInvalid(a))
    %%%%%: 2848-block  0
    %%%%%: 2848-block  1
    %%%%%: 2848-block  2
    %%%%%: 2848-block  3
    %%%%%: 2848-block  4
    %%%%%: 2848-block  5
    %%%%%: 2848-block  6
        -: 2849:    {
    #####: 2850:        return false;
    %%%%%: 2850-block  0
        -: 2851:    }
        -: 2852:
        -: 2853:    /* check if type is valid */
    #####: 2854:    switch (a->type & 0xFF)
    %%%%%: 2854-block  0
        -: 2855:    {
    #####: 2856:        case cJSON_False:
        -: 2857:        case cJSON_True:
        -: 2858:        case cJSON_NULL:
        -: 2859:        case cJSON_Number:
        -: 2860:        case cJSON_String:
        -: 2861:        case cJSON_Raw:
        -: 2862:        case cJSON_Array:
        -: 2863:        case cJSON_Object:
    #####: 2864:            break;
    %%%%%: 2864-block  0
        -: 2865:
    #####: 2866:        default:
    #####: 2867:            return false;
    %%%%%: 2867-block  0
        -: 2868:    }
        -: 2869:
        -: 2870:    /* identical objects are equal */
    #####: 2871:    if (a == b)
    %%%%%: 2871-block  0
        -: 2872:    {
    #####: 2873:        return true;
    %%%%%: 2873-block  0
        -: 2874:    }
        -: 2875:
    #####: 2876:    switch (a->type & 0xFF)
    %%%%%: 2876-block  0
        -: 2877:    {
        -: 2878:        /* in these cases and equal type is enough */
    #####: 2879:        case cJSON_False:
        -: 2880:        case cJSON_True:
        -: 2881:        case cJSON_NULL:
    #####: 2882:            return true;
    %%%%%: 2882-block  0
        -: 2883:
    #####: 2884:        case cJSON_Number:
    #####: 2885:            if (compare_double(a->valuedouble, b->valuedouble))
    %%%%%: 2885-block  0
        -: 2886:            {
    #####: 2887:                return true;
    %%%%%: 2887-block  0
        -: 2888:            }
    #####: 2889:            return false;
    %%%%%: 2889-block  0
        -: 2890:
    #####: 2891:        case cJSON_String:
        -: 2892:        case cJSON_Raw:
    #####: 2893:            if ((a->valuestring == NULL) || (b->valuestring == NULL))
    %%%%%: 2893-block  0
    %%%%%: 2893-block  1
        -: 2894:            {
    #####: 2895:                return false;
    %%%%%: 2895-block  0
        -: 2896:            }
    #####: 2897:            if (strcmp(a->valuestring, b->valuestring) == 0)
    %%%%%: 2897-block  0
        -: 2898:            {
    #####: 2899:                return true;
    %%%%%: 2899-block  0
        -: 2900:            }
        -: 2901:
    #####: 2902:            return false;
    %%%%%: 2902-block  0
        -: 2903:
    #####: 2904:        case cJSON_Array:
        -: 2905:        {
    #####: 2906:            cJSON *a_element = a->child;
    #####: 2907:            cJSON *b_element = b->child;
    %%%%%: 2907-block  0
        -: 2908:
    #####: 2909:            for (; (a_element != NULL) && (b_element != NULL);)
    %%%%%: 2909-block  0
    %%%%%: 2909-block  1
        -: 2910:            {
    #####: 2911:                if (!cJSON_Compare(a_element, b_element, case_sensitive))
    %%%%%: 2911-block  0
        -: 2912:                {
    #####: 2913:                    return false;
    %%%%%: 2913-block  0
        -: 2914:                }
        -: 2915:
    #####: 2916:                a_element = a_element->next;
    #####: 2917:                b_element = b_element->next;
    %%%%%: 2917-block  0
        -: 2918:            }
        -: 2919:
        -: 2920:            /* one of the arrays is longer than the other */
    #####: 2921:            if (a_element != b_element) {
    %%%%%: 2921-block  0
    #####: 2922:                return false;
    %%%%%: 2922-block  0
        -: 2923:            }
        -: 2924:
    #####: 2925:            return true;
    %%%%%: 2925-block  0
        -: 2926:        }
        -: 2927:
    #####: 2928:        case cJSON_Object:
        -: 2929:        {
    #####: 2930:            cJSON *a_element = NULL;
    #####: 2931:            cJSON *b_element = NULL;
    #####: 2932:            cJSON_ArrayForEach(a_element, a)
    %%%%%: 2932-block  0
    %%%%%: 2932-block  1
    %%%%%: 2932-block  2
    %%%%%: 2932-block  3
    %%%%%: 2932-block  4
    %%%%%: 2932-block  5
        -: 2933:            {
        -: 2934:                /* TODO This has O(n^2) runtime, which is horrible! */
    #####: 2935:                b_element = get_object_item(b, a_element->string, case_sensitive);
    %%%%%: 2935-block  0
    #####: 2936:                if (b_element == NULL)
        -: 2937:                {
    #####: 2938:                    return false;
    %%%%%: 2938-block  0
        -: 2939:                }
        -: 2940:
    #####: 2941:                if (!cJSON_Compare(a_element, b_element, case_sensitive))
    %%%%%: 2941-block  0
        -: 2942:                {
    #####: 2943:                    return false;
    %%%%%: 2943-block  0
        -: 2944:                }
        -: 2945:            }
        -: 2946:
        -: 2947:            /* doing this twice, once on a and b to prevent true comparison if a subset of b
        -: 2948:             * TODO: Do this the proper way, this is just a fix for now */
    #####: 2949:            cJSON_ArrayForEach(b_element, b)
    %%%%%: 2949-block  0
    %%%%%: 2949-block  1
    %%%%%: 2949-block  2
    %%%%%: 2949-block  3
    %%%%%: 2949-block  4
    %%%%%: 2949-block  5
        -: 2950:            {
    #####: 2951:                a_element = get_object_item(a, b_element->string, case_sensitive);
    %%%%%: 2951-block  0
    #####: 2952:                if (a_element == NULL)
        -: 2953:                {
    #####: 2954:                    return false;
    %%%%%: 2954-block  0
        -: 2955:                }
        -: 2956:
    #####: 2957:                if (!cJSON_Compare(b_element, a_element, case_sensitive))
    %%%%%: 2957-block  0
        -: 2958:                {
    #####: 2959:                    return false;
    %%%%%: 2959-block  0
        -: 2960:                }
        -: 2961:            }
        -: 2962:
    #####: 2963:            return true;
    %%%%%: 2963-block  0
        -: 2964:        }
        -: 2965:
    #####: 2966:        default:
    #####: 2967:            return false;
    %%%%%: 2967-block  0
        -: 2968:    }
        -: 2969:}
        -: 2970:
    #####: 2971:CJSON_PUBLIC(void *) cJSON_malloc(size_t size)
        -: 2972:{
    #####: 2973:    return global_hooks.allocate(size);
    %%%%%: 2973-block  0
        -: 2974:}
        -: 2975:
    #####: 2976:CJSON_PUBLIC(void) cJSON_free(void *object)
        -: 2977:{
    #####: 2978:    global_hooks.deallocate(object);
    %%%%%: 2978-block  0
    #####: 2979:}
