        -:    0:Source:D:/CLionProjects/Cjson_withTests/Google_tests/lib/googletest/src/gtest-port.cc
        -:    0:Graph:D:\CLionProjects\Cjson_withTests\cmake-build-debug\Google_tests\lib\googletest\CMakeFiles\gtest.dir\src\gtest-all.cc.gcno
        -:    0:Data:D:\CLionProjects\Cjson_withTests\cmake-build-debug\Google_tests\lib\googletest\CMakeFiles\gtest.dir\src\gtest-all.cc.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// Copyright 2008, Google Inc.
        -:    2:// All rights reserved.
        -:    3://
        -:    4:// Redistribution and use in source and binary forms, with or without
        -:    5:// modification, are permitted provided that the following conditions are
        -:    6:// met:
        -:    7://
        -:    8://     * Redistributions of source code must retain the above copyright
        -:    9:// notice, this list of conditions and the following disclaimer.
        -:   10://     * Redistributions in binary form must reproduce the above
        -:   11:// copyright notice, this list of conditions and the following disclaimer
        -:   12:// in the documentation and/or other materials provided with the
        -:   13:// distribution.
        -:   14://     * Neither the name of Google Inc. nor the names of its
        -:   15:// contributors may be used to endorse or promote products derived from
        -:   16:// this software without specific prior written permission.
        -:   17://
        -:   18:// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
        -:   19:// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
        -:   20:// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
        -:   21:// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
        -:   22:// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
        -:   23:// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
        -:   24:// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
        -:   25:// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
        -:   26:// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   27:// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
        -:   28:// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   29:
        -:   30:
        -:   31:#include "gtest/internal/gtest-port.h"
        -:   32:
        -:   33:#include <limits.h>
        -:   34:#include <stdio.h>
        -:   35:#include <stdlib.h>
        -:   36:#include <string.h>
        -:   37:#include <fstream>
        -:   38:#include <memory>
        -:   39:
        -:   40:#if GTEST_OS_WINDOWS
        -:   41:# include <windows.h>
        -:   42:# include <io.h>
        -:   43:# include <sys/stat.h>
        -:   44:# include <map>  // Used in ThreadLocal.
        -:   45:# ifdef _MSC_VER
        -:   46:#  include <crtdbg.h>
        -:   47:# endif  // _MSC_VER
        -:   48:#else
        -:   49:# include <unistd.h>
        -:   50:#endif  // GTEST_OS_WINDOWS
        -:   51:
        -:   52:#if GTEST_OS_MAC
        -:   53:# include <mach/mach_init.h>
        -:   54:# include <mach/task.h>
        -:   55:# include <mach/vm_map.h>
        -:   56:#endif  // GTEST_OS_MAC
        -:   57:
        -:   58:#if GTEST_OS_DRAGONFLY || GTEST_OS_FREEBSD || GTEST_OS_GNU_KFREEBSD || \
        -:   59:    GTEST_OS_NETBSD || GTEST_OS_OPENBSD
        -:   60:# include <sys/sysctl.h>
        -:   61:# if GTEST_OS_DRAGONFLY || GTEST_OS_FREEBSD || GTEST_OS_GNU_KFREEBSD
        -:   62:#  include <sys/user.h>
        -:   63:# endif
        -:   64:#endif
        -:   65:
        -:   66:#if GTEST_OS_QNX
        -:   67:# include <devctl.h>
        -:   68:# include <fcntl.h>
        -:   69:# include <sys/procfs.h>
        -:   70:#endif  // GTEST_OS_QNX
        -:   71:
        -:   72:#if GTEST_OS_AIX
        -:   73:# include <procinfo.h>
        -:   74:# include <sys/types.h>
        -:   75:#endif  // GTEST_OS_AIX
        -:   76:
        -:   77:#if GTEST_OS_FUCHSIA
        -:   78:# include <zircon/process.h>
        -:   79:# include <zircon/syscalls.h>
        -:   80:#endif  // GTEST_OS_FUCHSIA
        -:   81:
        -:   82:#include "gtest/gtest-spi.h"
        -:   83:#include "gtest/gtest-message.h"
        -:   84:#include "gtest/internal/gtest-internal.h"
        -:   85:#include "gtest/internal/gtest-string.h"
        -:   86:#include "src/gtest-internal-inl.h"
        -:   87:
        -:   88:namespace testing {
        -:   89:namespace internal {
        -:   90:
        -:   91:#if defined(_MSC_VER) || defined(__BORLANDC__)
        -:   92:// MSVC and C++Builder do not provide a definition of STDERR_FILENO.
        -:   93:const int kStdOutFileno = 1;
        -:   94:const int kStdErrFileno = 2;
        -:   95:#else
        -:   96:const int kStdOutFileno = STDOUT_FILENO;
        -:   97:const int kStdErrFileno = STDERR_FILENO;
        -:   98:#endif  // _MSC_VER
        -:   99:
        -:  100:#if GTEST_OS_LINUX
        -:  101:
        -:  102:namespace {
        -:  103:template <typename T>
        -:  104:T ReadProcFileField(const std::string& filename, int field) {
        -:  105:  std::string dummy;
        -:  106:  std::ifstream file(filename.c_str());
        -:  107:  while (field-- > 0) {
        -:  108:    file >> dummy;
        -:  109:  }
        -:  110:  T output = 0;
        -:  111:  file >> output;
        -:  112:  return output;
        -:  113:}
        -:  114:}  // namespace
        -:  115:
        -:  116:// Returns the number of active threads, or 0 when there is an error.
        -:  117:size_t GetThreadCount() {
        -:  118:  const std::string filename =
        -:  119:      (Message() << "/proc/" << getpid() << "/stat").GetString();
        -:  120:  return ReadProcFileField<size_t>(filename, 19);
        -:  121:}
        -:  122:
        -:  123:#elif GTEST_OS_MAC
        -:  124:
        -:  125:size_t GetThreadCount() {
        -:  126:  const task_t task = mach_task_self();
        -:  127:  mach_msg_type_number_t thread_count;
        -:  128:  thread_act_array_t thread_list;
        -:  129:  const kern_return_t status = task_threads(task, &thread_list, &thread_count);
        -:  130:  if (status == KERN_SUCCESS) {
        -:  131:    // task_threads allocates resources in thread_list and we need to free them
        -:  132:    // to avoid leaks.
        -:  133:    vm_deallocate(task,
        -:  134:                  reinterpret_cast<vm_address_t>(thread_list),
        -:  135:                  sizeof(thread_t) * thread_count);
        -:  136:    return static_cast<size_t>(thread_count);
        -:  137:  } else {
        -:  138:    return 0;
        -:  139:  }
        -:  140:}
        -:  141:
        -:  142:#elif GTEST_OS_DRAGONFLY || GTEST_OS_FREEBSD || GTEST_OS_GNU_KFREEBSD || \
        -:  143:      GTEST_OS_NETBSD
        -:  144:
        -:  145:#if GTEST_OS_NETBSD
        -:  146:#undef KERN_PROC
        -:  147:#define KERN_PROC KERN_PROC2
        -:  148:#define kinfo_proc kinfo_proc2
        -:  149:#endif
        -:  150:
        -:  151:#if GTEST_OS_DRAGONFLY
        -:  152:#define KP_NLWP(kp) (kp.kp_nthreads)
        -:  153:#elif GTEST_OS_FREEBSD || GTEST_OS_GNU_KFREEBSD
        -:  154:#define KP_NLWP(kp) (kp.ki_numthreads)
        -:  155:#elif GTEST_OS_NETBSD
        -:  156:#define KP_NLWP(kp) (kp.p_nlwps)
        -:  157:#endif
        -:  158:
        -:  159:// Returns the number of threads running in the process, or 0 to indicate that
        -:  160:// we cannot detect it.
        -:  161:size_t GetThreadCount() {
        -:  162:  int mib[] = {
        -:  163:    CTL_KERN,
        -:  164:    KERN_PROC,
        -:  165:    KERN_PROC_PID,
        -:  166:    getpid(),
        -:  167:#if GTEST_OS_NETBSD
        -:  168:    sizeof(struct kinfo_proc),
        -:  169:    1,
        -:  170:#endif
        -:  171:  };
        -:  172:  u_int miblen = sizeof(mib) / sizeof(mib[0]);
        -:  173:  struct kinfo_proc info;
        -:  174:  size_t size = sizeof(info);
        -:  175:  if (sysctl(mib, miblen, &info, &size, NULL, 0)) {
        -:  176:    return 0;
        -:  177:  }
        -:  178:  return static_cast<size_t>(KP_NLWP(info));
        -:  179:}
        -:  180:#elif GTEST_OS_OPENBSD
        -:  181:
        -:  182:// Returns the number of threads running in the process, or 0 to indicate that
        -:  183:// we cannot detect it.
        -:  184:size_t GetThreadCount() {
        -:  185:  int mib[] = {
        -:  186:    CTL_KERN,
        -:  187:    KERN_PROC,
        -:  188:    KERN_PROC_PID | KERN_PROC_SHOW_THREADS,
        -:  189:    getpid(),
        -:  190:    sizeof(struct kinfo_proc),
        -:  191:    0,
        -:  192:  };
        -:  193:  u_int miblen = sizeof(mib) / sizeof(mib[0]);
        -:  194:
        -:  195:  // get number of structs
        -:  196:  size_t size;
        -:  197:  if (sysctl(mib, miblen, NULL, &size, NULL, 0)) {
        -:  198:    return 0;
        -:  199:  }
        -:  200:  mib[5] = size / mib[4];
        -:  201:
        -:  202:  // populate array of structs
        -:  203:  struct kinfo_proc info[mib[5]];
        -:  204:  if (sysctl(mib, miblen, &info, &size, NULL, 0)) {
        -:  205:    return 0;
        -:  206:  }
        -:  207:
        -:  208:  // exclude empty members
        -:  209:  int nthreads = 0;
        -:  210:  for (int i = 0; i < size / mib[4]; i++) {
        -:  211:    if (info[i].p_tid != -1)
        -:  212:      nthreads++;
        -:  213:  }
        -:  214:  return nthreads;
        -:  215:}
        -:  216:
        -:  217:#elif GTEST_OS_QNX
        -:  218:
        -:  219:// Returns the number of threads running in the process, or 0 to indicate that
        -:  220:// we cannot detect it.
        -:  221:size_t GetThreadCount() {
        -:  222:  const int fd = open("/proc/self/as", O_RDONLY);
        -:  223:  if (fd < 0) {
        -:  224:    return 0;
        -:  225:  }
        -:  226:  procfs_info process_info;
        -:  227:  const int status =
        -:  228:      devctl(fd, DCMD_PROC_INFO, &process_info, sizeof(process_info), nullptr);
        -:  229:  close(fd);
        -:  230:  if (status == EOK) {
        -:  231:    return static_cast<size_t>(process_info.num_threads);
        -:  232:  } else {
        -:  233:    return 0;
        -:  234:  }
        -:  235:}
        -:  236:
        -:  237:#elif GTEST_OS_AIX
        -:  238:
        -:  239:size_t GetThreadCount() {
        -:  240:  struct procentry64 entry;
        -:  241:  pid_t pid = getpid();
        -:  242:  int status = getprocs64(&entry, sizeof(entry), nullptr, 0, &pid, 1);
        -:  243:  if (status == 1) {
        -:  244:    return entry.pi_thcount;
        -:  245:  } else {
        -:  246:    return 0;
        -:  247:  }
        -:  248:}
        -:  249:
        -:  250:#elif GTEST_OS_FUCHSIA
        -:  251:
        -:  252:size_t GetThreadCount() {
        -:  253:  int dummy_buffer;
        -:  254:  size_t avail;
        -:  255:  zx_status_t status = zx_object_get_info(
        -:  256:      zx_process_self(),
        -:  257:      ZX_INFO_PROCESS_THREADS,
        -:  258:      &dummy_buffer,
        -:  259:      0,
        -:  260:      nullptr,
        -:  261:      &avail);
        -:  262:  if (status == ZX_OK) {
        -:  263:    return avail;
        -:  264:  } else {
        -:  265:    return 0;
        -:  266:  }
        -:  267:}
        -:  268:
        -:  269:#else
        -:  270:
    #####:  271:size_t GetThreadCount() {
        -:  272:  // There's no portable way to detect the number of threads, so we just
        -:  273:  // return 0 to indicate that we cannot detect it.
    #####:  274:  return 0;
    %%%%%:  274-block  0
        -:  275:}
        -:  276:
        -:  277:#endif  // GTEST_OS_LINUX
        -:  278:
        -:  279:#if GTEST_IS_THREADSAFE && GTEST_OS_WINDOWS
        -:  280:
    #####:  281:void SleepMilliseconds(int n) {
    #####:  282:  ::Sleep(static_cast<DWORD>(n));
    %%%%%:  282-block  0
    #####:  283:}
        -:  284:
    #####:  285:AutoHandle::AutoHandle()
    #####:  286:    : handle_(INVALID_HANDLE_VALUE) {}
        -:  287:
    #####:  288:AutoHandle::AutoHandle(Handle handle)
    #####:  289:    : handle_(handle) {}
        -:  290:
    #####:  291:AutoHandle::~AutoHandle() {
    #####:  292:  Reset();
    %%%%%:  292-block  0
    #####:  293:}
        -:  294:
    #####:  295:AutoHandle::Handle AutoHandle::Get() const {
    #####:  296:  return handle_;
    %%%%%:  296-block  0
        -:  297:}
        -:  298:
    #####:  299:void AutoHandle::Reset() {
    #####:  300:  Reset(INVALID_HANDLE_VALUE);
    %%%%%:  300-block  0
    #####:  301:}
        -:  302:
    #####:  303:void AutoHandle::Reset(HANDLE handle) {
        -:  304:  // Resetting with the same handle we already own is invalid.
    #####:  305:  if (handle_ != handle) {
    %%%%%:  305-block  0
    #####:  306:    if (IsCloseable()) {
    %%%%%:  306-block  0
    #####:  307:      ::CloseHandle(handle_);
    %%%%%:  307-block  0
        -:  308:    }
    #####:  309:    handle_ = handle;
    %%%%%:  309-block  0
        -:  310:  } else {
    #####:  311:    GTEST_CHECK_(!IsCloseable())
    %%%%%:  311-block  0
    %%%%%:  311-block  1
    %%%%%:  311-block  2
    $$$$$:  311-block  3
        -:  312:        << "Resetting a valid handle to itself is likely a programmer error "
    #####:  313:            "and thus not allowed.";
    %%%%%:  313-block  0
        -:  314:  }
    #####:  315:}
    %%%%%:  315-block  0
        -:  316:
    #####:  317:bool AutoHandle::IsCloseable() const {
        -:  318:  // Different Windows APIs may use either of these values to represent an
        -:  319:  // invalid handle.
    #####:  320:  return handle_ != nullptr && handle_ != INVALID_HANDLE_VALUE;
    %%%%%:  320-block  0
    %%%%%:  320-block  1
    %%%%%:  320-block  2
    %%%%%:  320-block  3
    %%%%%:  320-block  4
        -:  321:}
        -:  322:
    #####:  323:Notification::Notification()
        -:  324:    : event_(::CreateEvent(nullptr,     // Default security attributes.
        -:  325:                           TRUE,        // Do not reset automatically.
        -:  326:                           FALSE,       // Initially unset.
    #####:  327:                           nullptr)) {  // Anonymous event.
    %%%%%:  327-block  0
    $$$$$:  327-block  1
    #####:  328:  GTEST_CHECK_(event_.Get() != nullptr);
    %%%%%:  328-block  0
    %%%%%:  328-block  1
    %%%%%:  328-block  2
    $$$$$:  328-block  3
    $$$$$:  328-block  4
    #####:  329:}
    %%%%%:  329-block  0
        -:  330:
    #####:  331:void Notification::Notify() {
    #####:  332:  GTEST_CHECK_(::SetEvent(event_.Get()) != FALSE);
    %%%%%:  332-block  0
    %%%%%:  332-block  1
    %%%%%:  332-block  2
    $$$$$:  332-block  3
    #####:  333:}
    %%%%%:  333-block  0
        -:  334:
    #####:  335:void Notification::WaitForNotification() {
    #####:  336:  GTEST_CHECK_(
    %%%%%:  336-block  0
    %%%%%:  336-block  1
    %%%%%:  336-block  2
    $$$$$:  336-block  3
        -:  337:      ::WaitForSingleObject(event_.Get(), INFINITE) == WAIT_OBJECT_0);
    #####:  338:}
    %%%%%:  338-block  0
        -:  339:
       79:  340:Mutex::Mutex()
        -:  341:    : owner_thread_id_(0),
        -:  342:      type_(kDynamic),
        -:  343:      critical_section_init_phase_(0),
       79:  344:      critical_section_(new CRITICAL_SECTION) {
       79:  344-block  0
       79:  345:  ::InitializeCriticalSection(critical_section_);
       79:  346:}
        -:  347:
    #####:  348:Mutex::~Mutex() {
        -:  349:  // Static mutexes are leaked intentionally. It is not thread-safe to try
        -:  350:  // to clean them up.
    #####:  351:  if (type_ == kDynamic) {
    %%%%%:  351-block  0
    #####:  352:    ::DeleteCriticalSection(critical_section_);
    %%%%%:  352-block  0
    #####:  353:    delete critical_section_;
    #####:  354:    critical_section_ = nullptr;
        -:  355:  }
    #####:  356:}
        -:  357:
    #####:  358:void Mutex::Lock() {
    #####:  359:  ThreadSafeLazyInit();
    %%%%%:  359-block  0
    #####:  360:  ::EnterCriticalSection(critical_section_);
    #####:  361:  owner_thread_id_ = ::GetCurrentThreadId();
    #####:  362:}
        -:  363:
    #####:  364:void Mutex::Unlock() {
    #####:  365:  ThreadSafeLazyInit();
    %%%%%:  365-block  0
        -:  366:  // We don't protect writing to owner_thread_id_ here, as it's the
        -:  367:  // caller's responsibility to ensure that the current thread holds the
        -:  368:  // mutex when this is called.
    #####:  369:  owner_thread_id_ = 0;
    #####:  370:  ::LeaveCriticalSection(critical_section_);
    #####:  371:}
        -:  372:
        -:  373:// Does nothing if the current thread holds the mutex. Otherwise, crashes
        -:  374:// with high probability.
    #####:  375:void Mutex::AssertHeld() {
    #####:  376:  ThreadSafeLazyInit();
    %%%%%:  376-block  0
    #####:  377:  GTEST_CHECK_(owner_thread_id_ == ::GetCurrentThreadId())
    %%%%%:  377-block  0
    %%%%%:  377-block  1
    $$$$$:  377-block  2
    #####:  378:      << "The current thread is not holding the mutex @" << this;
    %%%%%:  378-block  0
    %%%%%:  378-block  1
    #####:  379:}
    %%%%%:  379-block  0
        -:  380:
        -:  381:namespace {
        -:  382:
        -:  383:#ifdef _MSC_VER
        -:  384:// Use the RAII idiom to flag mem allocs that are intentionally never
        -:  385:// deallocated. The motivation is to silence the false positive mem leaks
        -:  386:// that are reported by the debug version of MS's CRT which can only detect
        -:  387:// if an alloc is missing a matching deallocation.
        -:  388:// Example:
        -:  389://    MemoryIsNotDeallocated memory_is_not_deallocated;
        -:  390://    critical_section_ = new CRITICAL_SECTION;
        -:  391://
        -:  392:class MemoryIsNotDeallocated
        -:  393:{
        -:  394: public:
        -:  395:  MemoryIsNotDeallocated() : old_crtdbg_flag_(0) {
        -:  396:    old_crtdbg_flag_ = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);
        -:  397:    // Set heap allocation block type to _IGNORE_BLOCK so that MS debug CRT
        -:  398:    // doesn't report mem leak if there's no matching deallocation.
        -:  399:    _CrtSetDbgFlag(old_crtdbg_flag_ & ~_CRTDBG_ALLOC_MEM_DF);
        -:  400:  }
        -:  401:
        -:  402:  ~MemoryIsNotDeallocated() {
        -:  403:    // Restore the original _CRTDBG_ALLOC_MEM_DF flag
        -:  404:    _CrtSetDbgFlag(old_crtdbg_flag_);
        -:  405:  }
        -:  406:
        -:  407: private:
        -:  408:  int old_crtdbg_flag_;
        -:  409:
        -:  410:  GTEST_DISALLOW_COPY_AND_ASSIGN_(MemoryIsNotDeallocated);
        -:  411:};
        -:  412:#endif  // _MSC_VER
        -:  413:
        -:  414:}  // namespace
        -:  415:
        -:  416:// Initializes owner_thread_id_ and critical_section_ in static mutexes.
    #####:  417:void Mutex::ThreadSafeLazyInit() {
        -:  418:  // Dynamic mutexes are initialized in the constructor.
    #####:  419:  if (type_ == kStatic) {
    %%%%%:  419-block  0
    #####:  420:    switch (
    #####:  421:        ::InterlockedCompareExchange(&critical_section_init_phase_, 1L, 0L)) {
    %%%%%:  421-block  0
    %%%%%:  421-block  1
    #####:  422:      case 0:
        -:  423:        // If critical_section_init_phase_ was 0 before the exchange, we
        -:  424:        // are the first to test it and need to perform the initialization.
    #####:  425:        owner_thread_id_ = 0;
        -:  426:        {
        -:  427:          // Use RAII to flag that following mem alloc is never deallocated.
        -:  428:#ifdef _MSC_VER
        -:  429:          MemoryIsNotDeallocated memory_is_not_deallocated;
        -:  430:#endif  // _MSC_VER
    #####:  431:          critical_section_ = new CRITICAL_SECTION;
    %%%%%:  431-block  0
        -:  432:        }
    #####:  433:        ::InitializeCriticalSection(critical_section_);
        -:  434:        // Updates the critical_section_init_phase_ to 2 to signal
        -:  435:        // initialization complete.
    #####:  436:        GTEST_CHECK_(::InterlockedCompareExchange(
    %%%%%:  436-block  0
    %%%%%:  436-block  1
    %%%%%:  436-block  2
    $$$$$:  436-block  3
    $$$$$:  436-block  4
        -:  437:                          &critical_section_init_phase_, 2L, 1L) ==
        -:  438:                      1L);
    #####:  439:        break;
    %%%%%:  439-block  0
    #####:  440:      case 1:
        -:  441:        // Somebody else is already initializing the mutex; spin until they
        -:  442:        // are done.
    #####:  443:        while (::InterlockedCompareExchange(&critical_section_init_phase_,
    %%%%%:  443-block  0
        -:  444:                                            2L,
    #####:  445:                                            2L) != 2L) {
    %%%%%:  445-block  0
        -:  446:          // Possibly yields the rest of the thread's time slice to other
        -:  447:          // threads.
    #####:  448:          ::Sleep(0);
    %%%%%:  448-block  0
        -:  449:        }
    #####:  450:        break;
    %%%%%:  450-block  0
        -:  451:
    #####:  452:      case 2:
    #####:  453:        break;  // The mutex is already initialized and ready for use.
    %%%%%:  453-block  0
        -:  454:
    #####:  455:      default:
    #####:  456:        GTEST_CHECK_(false)
    %%%%%:  456-block  0
    %%%%%:  456-block  1
    %%%%%:  456-block  2
    $$$$$:  456-block  3
        -:  457:            << "Unexpected value of critical_section_init_phase_ "
    #####:  458:            << "while initializing a static mutex.";
    %%%%%:  458-block  0
    %%%%%:  458-block  1
        -:  459:    }
        -:  460:  }
    #####:  461:}
    %%%%%:  461-block  0
        -:  462:
        -:  463:namespace {
        -:  464:
        -:  465:class ThreadWithParamSupport : public ThreadWithParamBase {
        -:  466: public:
    #####:  467:  static HANDLE CreateThread(Runnable* runnable,
        -:  468:                             Notification* thread_can_start) {
    #####:  469:    ThreadMainParam* param = new ThreadMainParam(runnable, thread_can_start);
    %%%%%:  469-block  0
    %%%%%:  469-block  1
        -:  470:    DWORD thread_id;
    #####:  471:    HANDLE thread_handle = ::CreateThread(
        -:  472:        nullptr,  // Default security.
        -:  473:        0,        // Default stack size.
        -:  474:        &ThreadWithParamSupport::ThreadMain,
        -:  475:        param,        // Parameter to ThreadMainStatic
        -:  476:        0x0,          // Default creation flags.
        -:  477:        &thread_id);  // Need a valid pointer for the call to work under Win98.
    #####:  478:    GTEST_CHECK_(thread_handle != nullptr)
    %%%%%:  478-block  0
    %%%%%:  478-block  1
    %%%%%:  478-block  2
    %%%%%:  478-block  3
    $$$$$:  478-block  4
    $$$$$:  478-block  5
    #####:  479:        << "CreateThread failed with error " << ::GetLastError() << ".";
    %%%%%:  479-block  0
    %%%%%:  479-block  1
    %%%%%:  479-block  2
    %%%%%:  479-block  3
    #####:  480:    if (thread_handle == nullptr) {
    %%%%%:  480-block  0
    #####:  481:      delete param;
    %%%%%:  481-block  0
    %%%%%:  481-block  1
        -:  482:    }
    #####:  483:    return thread_handle;
    %%%%%:  483-block  0
    %%%%%:  483-block  1
        -:  484:  }
        -:  485:
        -:  486: private:
        -:  487:  struct ThreadMainParam {
    #####:  488:    ThreadMainParam(Runnable* runnable, Notification* thread_can_start)
    #####:  489:        : runnable_(runnable),
    #####:  490:          thread_can_start_(thread_can_start) {
    %%%%%:  490-block  0
    #####:  491:    }
        -:  492:    std::unique_ptr<Runnable> runnable_;
        -:  493:    // Does not own.
        -:  494:    Notification* thread_can_start_;
        -:  495:  };
        -:  496:
    #####:  497:  static DWORD WINAPI ThreadMain(void* ptr) {
        -:  498:    // Transfers ownership.
    #####:  499:    std::unique_ptr<ThreadMainParam> param(static_cast<ThreadMainParam*>(ptr));
    %%%%%:  499-block  0
    $$$$$:  499-block  1
    #####:  500:    if (param->thread_can_start_ != nullptr)
    #####:  501:      param->thread_can_start_->WaitForNotification();
    %%%%%:  501-block  0
    #####:  502:    param->runnable_->Run();
    %%%%%:  502-block  0
    #####:  503:    return 0;
    %%%%%:  503-block  0
    %%%%%:  503-block  1
        -:  504:  }
        -:  505:
        -:  506:  // Prohibit instantiation.
        -:  507:  ThreadWithParamSupport();
        -:  508:
        -:  509:  GTEST_DISALLOW_COPY_AND_ASSIGN_(ThreadWithParamSupport);
        -:  510:};
        -:  511:
        -:  512:}  // namespace
        -:  513:
    #####:  514:ThreadWithParamBase::ThreadWithParamBase(Runnable *runnable,
    #####:  515:                                         Notification* thread_can_start)
        -:  516:      : thread_(ThreadWithParamSupport::CreateThread(runnable,
    #####:  517:                                                     thread_can_start)) {
    %%%%%:  517-block  0
    #####:  518:}
        -:  519:
    #####:  520:ThreadWithParamBase::~ThreadWithParamBase() {
    #####:  521:  Join();
    #####:  522:}
------------------
_ZN7testing8internal19ThreadWithParamBaseD0Ev:
    #####:  520:ThreadWithParamBase::~ThreadWithParamBase() {
        -:  521:  Join();
    #####:  522:}
    %%%%%:  522-block  0
------------------
_ZN7testing8internal19ThreadWithParamBaseD2Ev:
    #####:  520:ThreadWithParamBase::~ThreadWithParamBase() {
    #####:  521:  Join();
    %%%%%:  521-block  0
    #####:  522:}
------------------
        -:  523:
    #####:  524:void ThreadWithParamBase::Join() {
    #####:  525:  GTEST_CHECK_(::WaitForSingleObject(thread_.Get(), INFINITE) == WAIT_OBJECT_0)
    %%%%%:  525-block  0
    %%%%%:  525-block  1
    %%%%%:  525-block  2
    $$$$$:  525-block  3
    #####:  526:      << "Failed to join the thread with error " << ::GetLastError() << ".";
    %%%%%:  526-block  0
    %%%%%:  526-block  1
    %%%%%:  526-block  2
    %%%%%:  526-block  3
    #####:  527:}
    %%%%%:  527-block  0
        -:  528:
        -:  529:// Maps a thread to a set of ThreadIdToThreadLocals that have values
        -:  530:// instantiated on that thread and notifies them when the thread exits.  A
        -:  531:// ThreadLocal instance is expected to persist until all threads it has
        -:  532:// values on have terminated.
        -:  533:class ThreadLocalRegistryImpl {
        -:  534: public:
        -:  535:  // Registers thread_local_instance as having value on the current thread.
        -:  536:  // Returns a value that can be used to identify the thread from other threads.
    #####:  537:  static ThreadLocalValueHolderBase* GetValueOnCurrentThread(
        -:  538:      const ThreadLocalBase* thread_local_instance) {
    #####:  539:    DWORD current_thread = ::GetCurrentThreadId();
    %%%%%:  539-block  0
    #####:  540:    MutexLock lock(&mutex_);
    %%%%%:  540-block  0
    $$$$$:  540-block  1
        -:  541:    ThreadIdToThreadLocals* const thread_to_thread_locals =
    #####:  542:        GetThreadLocalsMapLocked();
    %%%%%:  542-block  0
        -:  543:    ThreadIdToThreadLocals::iterator thread_local_pos =
    #####:  544:        thread_to_thread_locals->find(current_thread);
    %%%%%:  544-block  0
    #####:  545:    if (thread_local_pos == thread_to_thread_locals->end()) {
    %%%%%:  545-block  0
    #####:  546:      thread_local_pos = thread_to_thread_locals->insert(
    #####:  547:          std::make_pair(current_thread, ThreadLocalValues())).first;
    %%%%%:  547-block  0
    %%%%%:  547-block  1
    %%%%%:  547-block  2
    $$$$$:  547-block  3
    $$$$$:  547-block  4
    $$$$$:  547-block  5
    $$$$$:  547-block  6
    #####:  548:      StartWatcherThreadFor(current_thread);
        -:  549:    }
    #####:  550:    ThreadLocalValues& thread_local_values = thread_local_pos->second;
    %%%%%:  550-block  0
        -:  551:    ThreadLocalValues::iterator value_pos =
    #####:  552:        thread_local_values.find(thread_local_instance);
    #####:  553:    if (value_pos == thread_local_values.end()) {
    %%%%%:  553-block  0
    #####:  554:      value_pos =
        -:  555:          thread_local_values
    #####:  556:              .insert(std::make_pair(
    %%%%%:  556-block  0
    %%%%%:  556-block  1
    $$$$$:  556-block  2
    $$$$$:  556-block  3
        -:  557:                  thread_local_instance,
    #####:  558:                  std::shared_ptr<ThreadLocalValueHolderBase>(
    %%%%%:  558-block  0
    $$$$$:  558-block  1
    $$$$$:  558-block  2
    #####:  559:                      thread_local_instance->NewValueForCurrentThread())))
    %%%%%:  559-block  0
    %%%%%:  559-block  1
        -:  560:              .first;
        -:  561:    }
    #####:  562:    return value_pos->second.get();
    %%%%%:  562-block  0
    %%%%%:  562-block  1
        -:  563:  }
        -:  564:
    #####:  565:  static void OnThreadLocalDestroyed(
        -:  566:      const ThreadLocalBase* thread_local_instance) {
    #####:  567:    std::vector<std::shared_ptr<ThreadLocalValueHolderBase> > value_holders;
    %%%%%:  567-block  0
    $$$$$:  567-block  1
        -:  568:    // Clean up the ThreadLocalValues data structure while holding the lock, but
        -:  569:    // defer the destruction of the ThreadLocalValueHolderBases.
        -:  570:    {
    #####:  571:      MutexLock lock(&mutex_);
    %%%%%:  571-block  0
    $$$$$:  571-block  1
        -:  572:      ThreadIdToThreadLocals* const thread_to_thread_locals =
    #####:  573:          GetThreadLocalsMapLocked();
    %%%%%:  573-block  0
    #####:  574:      for (ThreadIdToThreadLocals::iterator it =
    #####:  575:          thread_to_thread_locals->begin();
    %%%%%:  575-block  0
    #####:  576:          it != thread_to_thread_locals->end();
    %%%%%:  576-block  0
    #####:  577:          ++it) {
    %%%%%:  577-block  0
    #####:  578:        ThreadLocalValues& thread_local_values = it->second;
    %%%%%:  578-block  0
        -:  579:        ThreadLocalValues::iterator value_pos =
    #####:  580:            thread_local_values.find(thread_local_instance);
    #####:  581:        if (value_pos != thread_local_values.end()) {
    %%%%%:  581-block  0
    #####:  582:          value_holders.push_back(value_pos->second);
    %%%%%:  582-block  0
    #####:  583:          thread_local_values.erase(value_pos);
    %%%%%:  583-block  0
        -:  584:          // This 'if' can only be successful at most once, so theoretically we
        -:  585:          // could break out of the loop here, but we don't bother doing so.
        -:  586:        }
        -:  587:      }
        -:  588:    }
        -:  589:    // Outside the lock, let the destructor for 'value_holders' deallocate the
        -:  590:    // ThreadLocalValueHolderBases.
    #####:  591:  }
        -:  592:
    #####:  593:  static void OnThreadExit(DWORD thread_id) {
    #####:  594:    GTEST_CHECK_(thread_id != 0) << ::GetLastError();
    %%%%%:  594-block  0
    %%%%%:  594-block  1
    %%%%%:  594-block  2
    %%%%%:  594-block  3
    %%%%%:  594-block  4
    %%%%%:  594-block  5
    $$$$$:  594-block  6
    $$$$$:  594-block  7
    #####:  595:    std::vector<std::shared_ptr<ThreadLocalValueHolderBase> > value_holders;
    %%%%%:  595-block  0
    $$$$$:  595-block  1
        -:  596:    // Clean up the ThreadIdToThreadLocals data structure while holding the
        -:  597:    // lock, but defer the destruction of the ThreadLocalValueHolderBases.
        -:  598:    {
    #####:  599:      MutexLock lock(&mutex_);
    %%%%%:  599-block  0
    $$$$$:  599-block  1
        -:  600:      ThreadIdToThreadLocals* const thread_to_thread_locals =
    #####:  601:          GetThreadLocalsMapLocked();
    %%%%%:  601-block  0
        -:  602:      ThreadIdToThreadLocals::iterator thread_local_pos =
    #####:  603:          thread_to_thread_locals->find(thread_id);
    %%%%%:  603-block  0
    #####:  604:      if (thread_local_pos != thread_to_thread_locals->end()) {
    %%%%%:  604-block  0
    #####:  605:        ThreadLocalValues& thread_local_values = thread_local_pos->second;
    %%%%%:  605-block  0
    #####:  606:        for (ThreadLocalValues::iterator value_pos =
    #####:  607:            thread_local_values.begin();
    #####:  608:            value_pos != thread_local_values.end();
    %%%%%:  608-block  0
    #####:  609:            ++value_pos) {
    %%%%%:  609-block  0
    #####:  610:          value_holders.push_back(value_pos->second);
    %%%%%:  610-block  0
        -:  611:        }
    #####:  612:        thread_to_thread_locals->erase(thread_local_pos);
    %%%%%:  612-block  0
        -:  613:      }
        -:  614:    }
        -:  615:    // Outside the lock, let the destructor for 'value_holders' deallocate the
        -:  616:    // ThreadLocalValueHolderBases.
    #####:  617:  }
        -:  618:
        -:  619: private:
        -:  620:  // In a particular thread, maps a ThreadLocal object to its value.
        -:  621:  typedef std::map<const ThreadLocalBase*,
        -:  622:                   std::shared_ptr<ThreadLocalValueHolderBase> >
        -:  623:      ThreadLocalValues;
        -:  624:  // Stores all ThreadIdToThreadLocals having values in a thread, indexed by
        -:  625:  // thread's ID.
        -:  626:  typedef std::map<DWORD, ThreadLocalValues> ThreadIdToThreadLocals;
        -:  627:
        -:  628:  // Holds the thread id and thread handle that we pass from
        -:  629:  // StartWatcherThreadFor to WatcherThreadFunc.
        -:  630:  typedef std::pair<DWORD, HANDLE> ThreadIdAndHandle;
        -:  631:
    #####:  632:  static void StartWatcherThreadFor(DWORD thread_id) {
        -:  633:    // The returned handle will be kept in thread_map and closed by
        -:  634:    // watcher_thread in WatcherThreadFunc.
    #####:  635:    HANDLE thread = ::OpenThread(SYNCHRONIZE | THREAD_QUERY_INFORMATION,
    %%%%%:  635-block  0
        -:  636:                                 FALSE,
    #####:  637:                                 thread_id);
    #####:  638:    GTEST_CHECK_(thread != nullptr);
    %%%%%:  638-block  0
    %%%%%:  638-block  1
    %%%%%:  638-block  2
    %%%%%:  638-block  3
    $$$$$:  638-block  4
    $$$$$:  638-block  5
        -:  639:    // We need to pass a valid thread ID pointer into CreateThread for it
        -:  640:    // to work correctly under Win98.
        -:  641:    DWORD watcher_thread_id;
    #####:  642:    HANDLE watcher_thread = ::CreateThread(
        -:  643:        nullptr,  // Default security.
        -:  644:        0,        // Default stack size
        -:  645:        &ThreadLocalRegistryImpl::WatcherThreadFunc,
    #####:  646:        reinterpret_cast<LPVOID>(new ThreadIdAndHandle(thread_id, thread)),
    %%%%%:  646-block  0
    %%%%%:  646-block  1
        -:  647:        CREATE_SUSPENDED, &watcher_thread_id);
    #####:  648:    GTEST_CHECK_(watcher_thread != nullptr);
    %%%%%:  648-block  0
    %%%%%:  648-block  1
    %%%%%:  648-block  2
    %%%%%:  648-block  3
    $$$$$:  648-block  4
    $$$$$:  648-block  5
        -:  649:    // Give the watcher thread the same priority as ours to avoid being
        -:  650:    // blocked by it.
    #####:  651:    ::SetThreadPriority(watcher_thread,
    %%%%%:  651-block  0
    %%%%%:  651-block  1
    %%%%%:  651-block  2
        -:  652:                        ::GetThreadPriority(::GetCurrentThread()));
    #####:  653:    ::ResumeThread(watcher_thread);
    %%%%%:  653-block  0
    #####:  654:    ::CloseHandle(watcher_thread);
    %%%%%:  654-block  0
    #####:  655:  }
    %%%%%:  655-block  0
        -:  656:
        -:  657:  // Monitors exit from a given thread and notifies those
        -:  658:  // ThreadIdToThreadLocals about thread termination.
    #####:  659:  static DWORD WINAPI WatcherThreadFunc(LPVOID param) {
    #####:  660:    const ThreadIdAndHandle* tah =
        -:  661:        reinterpret_cast<const ThreadIdAndHandle*>(param);
    #####:  662:    GTEST_CHECK_(
    %%%%%:  662-block  0
    %%%%%:  662-block  1
    %%%%%:  662-block  2
    $$$$$:  662-block  3
        -:  663:        ::WaitForSingleObject(tah->second, INFINITE) == WAIT_OBJECT_0);
    #####:  664:    OnThreadExit(tah->first);
    %%%%%:  664-block  0
    #####:  665:    ::CloseHandle(tah->second);
    #####:  666:    delete tah;
    #####:  667:    return 0;
    %%%%%:  667-block  0
        -:  668:  }
        -:  669:
        -:  670:  // Returns map of thread local instances.
    #####:  671:  static ThreadIdToThreadLocals* GetThreadLocalsMapLocked() {
    #####:  672:    mutex_.AssertHeld();
    %%%%%:  672-block  0
        -:  673:#ifdef _MSC_VER
        -:  674:    MemoryIsNotDeallocated memory_is_not_deallocated;
        -:  675:#endif  // _MSC_VER
    #####:  676:    static ThreadIdToThreadLocals* map = new ThreadIdToThreadLocals();
    %%%%%:  676-block  0
    %%%%%:  676-block  1
    %%%%%:  676-block  2
    $$$$$:  676-block  3
    $$$$$:  676-block  4
    #####:  677:    return map;
    %%%%%:  677-block  0
    %%%%%:  677-block  1
        -:  678:  }
        -:  679:
        -:  680:  // Protects access to GetThreadLocalsMapLocked() and its return value.
        -:  681:  static Mutex mutex_;
        -:  682:  // Protects access to GetThreadMapLocked() and its return value.
        -:  683:  static Mutex thread_map_mutex_;
        -:  684:};
        -:  685:
        -:  686:Mutex ThreadLocalRegistryImpl::mutex_(Mutex::kStaticMutex);
        -:  687:Mutex ThreadLocalRegistryImpl::thread_map_mutex_(Mutex::kStaticMutex);
        -:  688:
    #####:  689:ThreadLocalValueHolderBase* ThreadLocalRegistry::GetValueOnCurrentThread(
        -:  690:      const ThreadLocalBase* thread_local_instance) {
    #####:  691:  return ThreadLocalRegistryImpl::GetValueOnCurrentThread(
    %%%%%:  691-block  0
    #####:  692:      thread_local_instance);
        -:  693:}
        -:  694:
    #####:  695:void ThreadLocalRegistry::OnThreadLocalDestroyed(
        -:  696:      const ThreadLocalBase* thread_local_instance) {
    #####:  697:  ThreadLocalRegistryImpl::OnThreadLocalDestroyed(thread_local_instance);
    %%%%%:  697-block  0
    #####:  698:}
        -:  699:
        -:  700:#endif  // GTEST_IS_THREADSAFE && GTEST_OS_WINDOWS
        -:  701:
        -:  702:#if GTEST_USES_POSIX_RE
        -:  703:
        -:  704:// Implements RE.  Currently only needed for death tests.
        -:  705:
        -:  706:RE::~RE() {
        -:  707:  if (is_valid_) {
        -:  708:    // regfree'ing an invalid regex might crash because the content
        -:  709:    // of the regex is undefined. Since the regex's are essentially
        -:  710:    // the same, one cannot be valid (or invalid) without the other
        -:  711:    // being so too.
        -:  712:    regfree(&partial_regex_);
        -:  713:    regfree(&full_regex_);
        -:  714:  }
        -:  715:  free(const_cast<char*>(pattern_));
        -:  716:}
        -:  717:
        -:  718:// Returns true if regular expression re matches the entire str.
        -:  719:bool RE::FullMatch(const char* str, const RE& re) {
        -:  720:  if (!re.is_valid_) return false;
        -:  721:
        -:  722:  regmatch_t match;
        -:  723:  return regexec(&re.full_regex_, str, 1, &match, 0) == 0;
        -:  724:}
        -:  725:
        -:  726:// Returns true if regular expression re matches a substring of str
        -:  727:// (including str itself).
        -:  728:bool RE::PartialMatch(const char* str, const RE& re) {
        -:  729:  if (!re.is_valid_) return false;
        -:  730:
        -:  731:  regmatch_t match;
        -:  732:  return regexec(&re.partial_regex_, str, 1, &match, 0) == 0;
        -:  733:}
        -:  734:
        -:  735:// Initializes an RE from its string representation.
        -:  736:void RE::Init(const char* regex) {
        -:  737:  pattern_ = posix::StrDup(regex);
        -:  738:
        -:  739:  // Reserves enough bytes to hold the regular expression used for a
        -:  740:  // full match.
        -:  741:  const size_t full_regex_len = strlen(regex) + 10;
        -:  742:  char* const full_pattern = new char[full_regex_len];
        -:  743:
        -:  744:  snprintf(full_pattern, full_regex_len, "^(%s)$", regex);
        -:  745:  is_valid_ = regcomp(&full_regex_, full_pattern, REG_EXTENDED) == 0;
        -:  746:  // We want to call regcomp(&partial_regex_, ...) even if the
        -:  747:  // previous expression returns false.  Otherwise partial_regex_ may
        -:  748:  // not be properly initialized can may cause trouble when it's
        -:  749:  // freed.
        -:  750:  //
        -:  751:  // Some implementation of POSIX regex (e.g. on at least some
        -:  752:  // versions of Cygwin) doesn't accept the empty string as a valid
        -:  753:  // regex.  We change it to an equivalent form "()" to be safe.
        -:  754:  if (is_valid_) {
        -:  755:    const char* const partial_regex = (*regex == '\0') ? "()" : regex;
        -:  756:    is_valid_ = regcomp(&partial_regex_, partial_regex, REG_EXTENDED) == 0;
        -:  757:  }
        -:  758:  EXPECT_TRUE(is_valid_)
        -:  759:      << "Regular expression \"" << regex
        -:  760:      << "\" is not a valid POSIX Extended regular expression.";
        -:  761:
        -:  762:  delete[] full_pattern;
        -:  763:}
        -:  764:
        -:  765:#elif GTEST_USES_SIMPLE_RE
        -:  766:
        -:  767:// Returns true if ch appears anywhere in str (excluding the
        -:  768:// terminating '\0' character).
    #####:  769:bool IsInSet(char ch, const char* str) {
    #####:  770:  return ch != '\0' && strchr(str, ch) != nullptr;
    %%%%%:  770-block  0
    %%%%%:  770-block  1
    %%%%%:  770-block  2
    %%%%%:  770-block  3
    %%%%%:  770-block  4
        -:  771:}
        -:  772:
        -:  773:// Returns true if ch belongs to the given classification.  Unlike
        -:  774:// similar functions in <ctype.h>, these aren't affected by the
        -:  775:// current locale.
    #####:  776:bool IsAsciiDigit(char ch) { return '0' <= ch && ch <= '9'; }
    %%%%%:  776-block  0
    %%%%%:  776-block  1
    %%%%%:  776-block  2
    %%%%%:  776-block  3
    %%%%%:  776-block  4
    #####:  777:bool IsAsciiPunct(char ch) {
    #####:  778:  return IsInSet(ch, "^-!\"#$%&'()*+,./:;<=>?@[\\]_`{|}~");
    %%%%%:  778-block  0
        -:  779:}
    #####:  780:bool IsRepeat(char ch) { return IsInSet(ch, "?*+"); }
    %%%%%:  780-block  0
    #####:  781:bool IsAsciiWhiteSpace(char ch) { return IsInSet(ch, " \f\n\r\t\v"); }
    %%%%%:  781-block  0
    #####:  782:bool IsAsciiWordChar(char ch) {
    #####:  783:  return ('a' <= ch && ch <= 'z') || ('A' <= ch && ch <= 'Z') ||
    %%%%%:  783-block  0
    %%%%%:  783-block  1
    %%%%%:  783-block  2
    %%%%%:  783-block  3
    #####:  784:      ('0' <= ch && ch <= '9') || ch == '_';
    %%%%%:  784-block  0
    %%%%%:  784-block  1
    %%%%%:  784-block  2
    %%%%%:  784-block  3
    %%%%%:  784-block  4
    %%%%%:  784-block  5
        -:  785:}
        -:  786:
        -:  787:// Returns true if "\\c" is a supported escape sequence.
    #####:  788:bool IsValidEscape(char c) {
    #####:  789:  return (IsAsciiPunct(c) || IsInSet(c, "dDfnrsStvwW"));
    %%%%%:  789-block  0
    %%%%%:  789-block  1
    %%%%%:  789-block  2
    %%%%%:  789-block  3
    %%%%%:  789-block  4
        -:  790:}
        -:  791:
        -:  792:// Returns true if the given atom (specified by escaped and pattern)
        -:  793:// matches ch.  The result is undefined if the atom is invalid.
    #####:  794:bool AtomMatchesChar(bool escaped, char pattern_char, char ch) {
    #####:  795:  if (escaped) {  // "\\p" where p is pattern_char.
    %%%%%:  795-block  0
    #####:  796:    switch (pattern_char) {
    %%%%%:  796-block  0
    #####:  797:      case 'd': return IsAsciiDigit(ch);
    %%%%%:  797-block  0
    #####:  798:      case 'D': return !IsAsciiDigit(ch);
    %%%%%:  798-block  0
    #####:  799:      case 'f': return ch == '\f';
    %%%%%:  799-block  0
    #####:  800:      case 'n': return ch == '\n';
    %%%%%:  800-block  0
    #####:  801:      case 'r': return ch == '\r';
    %%%%%:  801-block  0
    #####:  802:      case 's': return IsAsciiWhiteSpace(ch);
    %%%%%:  802-block  0
    #####:  803:      case 'S': return !IsAsciiWhiteSpace(ch);
    %%%%%:  803-block  0
    #####:  804:      case 't': return ch == '\t';
    %%%%%:  804-block  0
    #####:  805:      case 'v': return ch == '\v';
    %%%%%:  805-block  0
    #####:  806:      case 'w': return IsAsciiWordChar(ch);
    %%%%%:  806-block  0
    #####:  807:      case 'W': return !IsAsciiWordChar(ch);
    %%%%%:  807-block  0
        -:  808:    }
    #####:  809:    return IsAsciiPunct(pattern_char) && pattern_char == ch;
    %%%%%:  809-block  0
    %%%%%:  809-block  1
    %%%%%:  809-block  2
    %%%%%:  809-block  3
    %%%%%:  809-block  4
        -:  810:  }
        -:  811:
    #####:  812:  return (pattern_char == '.' && ch != '\n') || pattern_char == ch;
    %%%%%:  812-block  0
    %%%%%:  812-block  1
    %%%%%:  812-block  2
    %%%%%:  812-block  3
    %%%%%:  812-block  4
    %%%%%:  812-block  5
        -:  813:}
        -:  814:
        -:  815:// Helper function used by ValidateRegex() to format error messages.
    #####:  816:static std::string FormatRegexSyntaxError(const char* regex, int index) {
    #####:  817:  return (Message() << "Syntax error at index " << index
    %%%%%:  817-block  0
    %%%%%:  817-block  1
    %%%%%:  817-block  2
    $$$$$:  817-block  3
    #####:  818:          << " in simple regular expression \"" << regex << "\": ").GetString();
    %%%%%:  818-block  0
    %%%%%:  818-block  1
    %%%%%:  818-block  2
    %%%%%:  818-block  3
    %%%%%:  818-block  4
    %%%%%:  818-block  5
        -:  819:}
        -:  820:
        -:  821:// Generates non-fatal failures and returns false if regex is invalid;
        -:  822:// otherwise returns true.
    #####:  823:bool ValidateRegex(const char* regex) {
    #####:  824:  if (regex == nullptr) {
    %%%%%:  824-block  0
    #####:  825:    ADD_FAILURE() << "NULL is not a valid simple regular expression.";
    %%%%%:  825-block  0
    %%%%%:  825-block  1
    %%%%%:  825-block  2
    %%%%%:  825-block  3
    $$$$$:  825-block  4
    $$$$$:  825-block  5
    $$$$$:  825-block  6
    $$$$$:  825-block  7
    #####:  826:    return false;
        -:  827:  }
        -:  828:
    #####:  829:  bool is_valid = true;
        -:  830:
        -:  831:  // True if ?, *, or + can follow the previous atom.
    #####:  832:  bool prev_repeatable = false;
    #####:  833:  for (int i = 0; regex[i]; i++) {
    %%%%%:  833-block  0
    %%%%%:  833-block  1
    %%%%%:  833-block  2
    #####:  834:    if (regex[i] == '\\') {  // An escape sequence
    %%%%%:  834-block  0
    #####:  835:      i++;
    #####:  836:      if (regex[i] == '\0') {
    %%%%%:  836-block  0
    #####:  837:        ADD_FAILURE() << FormatRegexSyntaxError(regex, i - 1)
    %%%%%:  837-block  0
    %%%%%:  837-block  1
    %%%%%:  837-block  2
    %%%%%:  837-block  3
    $$$$$:  837-block  4
    $$$$$:  837-block  5
    $$$$$:  837-block  6
    $$$$$:  837-block  7
    $$$$$:  837-block  8
    $$$$$:  837-block  9
    #####:  838:                      << "'\\' cannot appear at the end.";
    %%%%%:  838-block  0
    %%%%%:  838-block  1
    #####:  839:        return false;
        -:  840:      }
        -:  841:
    #####:  842:      if (!IsValidEscape(regex[i])) {
    %%%%%:  842-block  0
    #####:  843:        ADD_FAILURE() << FormatRegexSyntaxError(regex, i - 1)
    %%%%%:  843-block  0
    %%%%%:  843-block  1
    %%%%%:  843-block  2
    %%%%%:  843-block  3
    $$$$$:  843-block  4
    $$$$$:  843-block  5
    $$$$$:  843-block  6
    $$$$$:  843-block  7
    $$$$$:  843-block  8
    $$$$$:  843-block  9
    #####:  844:                      << "invalid escape sequence \"\\" << regex[i] << "\".";
    %%%%%:  844-block  0
    %%%%%:  844-block  1
    %%%%%:  844-block  2
    %%%%%:  844-block  3
    #####:  845:        is_valid = false;
        -:  846:      }
    #####:  847:      prev_repeatable = true;
    %%%%%:  847-block  0
        -:  848:    } else {  // Not an escape sequence.
    #####:  849:      const char ch = regex[i];
        -:  850:
    #####:  851:      if (ch == '^' && i > 0) {
    %%%%%:  851-block  0
    %%%%%:  851-block  1
    #####:  852:        ADD_FAILURE() << FormatRegexSyntaxError(regex, i)
    %%%%%:  852-block  0
    %%%%%:  852-block  1
    %%%%%:  852-block  2
    %%%%%:  852-block  3
    %%%%%:  852-block  4
    $$$$$:  852-block  5
    $$$$$:  852-block  6
    $$$$$:  852-block  7
    $$$$$:  852-block  8
    $$$$$:  852-block  9
    $$$$$:  852-block 10
    #####:  853:                      << "'^' can only appear at the beginning.";
    %%%%%:  853-block  0
    %%%%%:  853-block  1
    #####:  854:        is_valid = false;
    #####:  855:      } else if (ch == '$' && regex[i + 1] != '\0') {
    %%%%%:  855-block  0
    %%%%%:  855-block  1
    #####:  856:        ADD_FAILURE() << FormatRegexSyntaxError(regex, i)
    %%%%%:  856-block  0
    %%%%%:  856-block  1
    %%%%%:  856-block  2
    %%%%%:  856-block  3
    %%%%%:  856-block  4
    $$$$$:  856-block  5
    $$$$$:  856-block  6
    $$$$$:  856-block  7
    $$$$$:  856-block  8
    $$$$$:  856-block  9
    $$$$$:  856-block 10
    #####:  857:                      << "'$' can only appear at the end.";
    %%%%%:  857-block  0
    %%%%%:  857-block  1
    #####:  858:        is_valid = false;
    #####:  859:      } else if (IsInSet(ch, "()[]{}|")) {
    %%%%%:  859-block  0
    #####:  860:        ADD_FAILURE() << FormatRegexSyntaxError(regex, i)
    %%%%%:  860-block  0
    %%%%%:  860-block  1
    %%%%%:  860-block  2
    %%%%%:  860-block  3
    %%%%%:  860-block  4
    $$$$$:  860-block  5
    $$$$$:  860-block  6
    $$$$$:  860-block  7
    $$$$$:  860-block  8
    $$$$$:  860-block  9
    $$$$$:  860-block 10
    #####:  861:                      << "'" << ch << "' is unsupported.";
    %%%%%:  861-block  0
    %%%%%:  861-block  1
    %%%%%:  861-block  2
    %%%%%:  861-block  3
    #####:  862:        is_valid = false;
    #####:  863:      } else if (IsRepeat(ch) && !prev_repeatable) {
    %%%%%:  863-block  0
    %%%%%:  863-block  1
    %%%%%:  863-block  2
    %%%%%:  863-block  3
    %%%%%:  863-block  4
    #####:  864:        ADD_FAILURE() << FormatRegexSyntaxError(regex, i)
    %%%%%:  864-block  0
    %%%%%:  864-block  1
    %%%%%:  864-block  2
    %%%%%:  864-block  3
    %%%%%:  864-block  4
    $$$$$:  864-block  5
    $$$$$:  864-block  6
    $$$$$:  864-block  7
    $$$$$:  864-block  8
    $$$$$:  864-block  9
    $$$$$:  864-block 10
    #####:  865:                      << "'" << ch << "' can only follow a repeatable token.";
    %%%%%:  865-block  0
    %%%%%:  865-block  1
    %%%%%:  865-block  2
    %%%%%:  865-block  3
    #####:  866:        is_valid = false;
        -:  867:      }
        -:  868:
    #####:  869:      prev_repeatable = !IsInSet(ch, "^$?*+");
    %%%%%:  869-block  0
        -:  870:    }
        -:  871:  }
        -:  872:
    #####:  873:  return is_valid;
    %%%%%:  873-block  0
        -:  874:}
        -:  875:
        -:  876:// Matches a repeated regex atom followed by a valid simple regular
        -:  877:// expression.  The regex atom is defined as c if escaped is false,
        -:  878:// or \c otherwise.  repeat is the repetition meta character (?, *,
        -:  879:// or +).  The behavior is undefined if str contains too many
        -:  880:// characters to be indexable by size_t, in which case the test will
        -:  881:// probably time out anyway.  We are fine with this limitation as
        -:  882:// std::string has it too.
    #####:  883:bool MatchRepetitionAndRegexAtHead(
        -:  884:    bool escaped, char c, char repeat, const char* regex,
        -:  885:    const char* str) {
    #####:  886:  const size_t min_count = (repeat == '+') ? 1 : 0;
    %%%%%:  886-block  0
    %%%%%:  886-block  1
    %%%%%:  886-block  2
    #####:  887:  const size_t max_count = (repeat == '?') ? 1 :
    %%%%%:  887-block  0
    %%%%%:  887-block  1
    %%%%%:  887-block  2
        -:  888:      static_cast<size_t>(-1) - 1;
        -:  889:  // We cannot call numeric_limits::max() as it conflicts with the
        -:  890:  // max() macro on Windows.
        -:  891:
    #####:  892:  for (size_t i = 0; i <= max_count; ++i) {
    %%%%%:  892-block  0
    %%%%%:  892-block  1
    %%%%%:  892-block  2
        -:  893:    // We know that the atom matches each of the first i characters in str.
    #####:  894:    if (i >= min_count && MatchRegexAtHead(regex, str + i)) {
    %%%%%:  894-block  0
    %%%%%:  894-block  1
    %%%%%:  894-block  2
    %%%%%:  894-block  3
    %%%%%:  894-block  4
        -:  895:      // We have enough matches at the head, and the tail matches too.
        -:  896:      // Since we only care about *whether* the pattern matches str
        -:  897:      // (as opposed to *how* it matches), there is no need to find a
        -:  898:      // greedy match.
    #####:  899:      return true;
    %%%%%:  899-block  0
        -:  900:    }
    #####:  901:    if (str[i] == '\0' || !AtomMatchesChar(escaped, c, str[i]))
    %%%%%:  901-block  0
    %%%%%:  901-block  1
    %%%%%:  901-block  2
    %%%%%:  901-block  3
    %%%%%:  901-block  4
    #####:  902:      return false;
    %%%%%:  902-block  0
        -:  903:  }
    #####:  904:  return false;
    %%%%%:  904-block  0
        -:  905:}
        -:  906:
        -:  907:// Returns true if regex matches a prefix of str.  regex must be a
        -:  908:// valid simple regular expression and not start with "^", or the
        -:  909:// result is undefined.
    #####:  910:bool MatchRegexAtHead(const char* regex, const char* str) {
    #####:  911:  if (*regex == '\0')  // An empty regex matches a prefix of anything.
    %%%%%:  911-block  0
    #####:  912:    return true;
    %%%%%:  912-block  0
        -:  913:
        -:  914:  // "$" only matches the end of a string.  Note that regex being
        -:  915:  // valid guarantees that there's nothing after "$" in it.
    #####:  916:  if (*regex == '$')
    %%%%%:  916-block  0
    #####:  917:    return *str == '\0';
    %%%%%:  917-block  0
        -:  918:
        -:  919:  // Is the first thing in regex an escape sequence?
    #####:  920:  const bool escaped = *regex == '\\';
    #####:  921:  if (escaped)
    %%%%%:  921-block  0
    #####:  922:    ++regex;
    %%%%%:  922-block  0
    #####:  923:  if (IsRepeat(regex[1])) {
    %%%%%:  923-block  0
        -:  924:    // MatchRepetitionAndRegexAtHead() calls MatchRegexAtHead(), so
        -:  925:    // here's an indirect recursion.  It terminates as the regex gets
        -:  926:    // shorter in each recursion.
    #####:  927:    return MatchRepetitionAndRegexAtHead(
    #####:  928:        escaped, regex[0], regex[1], regex + 2, str);
    %%%%%:  928-block  0
        -:  929:  } else {
        -:  930:    // regex isn't empty, isn't "$", and doesn't start with a
        -:  931:    // repetition.  We match the first atom of regex with the first
        -:  932:    // character of str and recurse.
    #####:  933:    return (*str != '\0') && AtomMatchesChar(escaped, *regex, *str) &&
    %%%%%:  933-block  0
    %%%%%:  933-block  1
    %%%%%:  933-block  2
    %%%%%:  933-block  3
    #####:  934:        MatchRegexAtHead(regex + 1, str + 1);
    %%%%%:  934-block  0
    %%%%%:  934-block  1
        -:  935:  }
        -:  936:}
        -:  937:
        -:  938:// Returns true if regex matches any substring of str.  regex must be
        -:  939:// a valid simple regular expression, or the result is undefined.
        -:  940://
        -:  941:// The algorithm is recursive, but the recursion depth doesn't exceed
        -:  942:// the regex length, so we won't need to worry about running out of
        -:  943:// stack space normally.  In rare cases the time complexity can be
        -:  944:// exponential with respect to the regex length + the string length,
        -:  945:// but usually it's must faster (often close to linear).
    #####:  946:bool MatchRegexAnywhere(const char* regex, const char* str) {
    #####:  947:  if (regex == nullptr || str == nullptr) return false;
    %%%%%:  947-block  0
    %%%%%:  947-block  1
    %%%%%:  947-block  2
        -:  948:
    #####:  949:  if (*regex == '^')
    %%%%%:  949-block  0
    #####:  950:    return MatchRegexAtHead(regex + 1, str);
    %%%%%:  950-block  0
        -:  951:
        -:  952:  // A successful match can be anywhere in str.
    #####:  953:  do {
    %%%%%:  953-block  0
    #####:  954:    if (MatchRegexAtHead(regex, str))
    %%%%%:  954-block  0
    #####:  955:      return true;
    %%%%%:  955-block  0
    #####:  956:  } while (*str++ != '\0');
    %%%%%:  956-block  0
    #####:  957:  return false;
    %%%%%:  957-block  0
        -:  958:}
        -:  959:
        -:  960:// Implements the RE class.
        -:  961:
    #####:  962:RE::~RE() {
    #####:  963:  free(const_cast<char*>(pattern_));
    #####:  964:  free(const_cast<char*>(full_pattern_));
    #####:  965:}
        -:  966:
        -:  967:// Returns true if regular expression re matches the entire str.
    #####:  968:bool RE::FullMatch(const char* str, const RE& re) {
    #####:  969:  return re.is_valid_ && MatchRegexAnywhere(re.full_pattern_, str);
    %%%%%:  969-block  0
    %%%%%:  969-block  1
    %%%%%:  969-block  2
    %%%%%:  969-block  3
    %%%%%:  969-block  4
        -:  970:}
        -:  971:
        -:  972:// Returns true if regular expression re matches a substring of str
        -:  973:// (including str itself).
    #####:  974:bool RE::PartialMatch(const char* str, const RE& re) {
    #####:  975:  return re.is_valid_ && MatchRegexAnywhere(re.pattern_, str);
    %%%%%:  975-block  0
    %%%%%:  975-block  1
    %%%%%:  975-block  2
    %%%%%:  975-block  3
    %%%%%:  975-block  4
        -:  976:}
        -:  977:
        -:  978:// Initializes an RE from its string representation.
    #####:  979:void RE::Init(const char* regex) {
    #####:  980:  pattern_ = full_pattern_ = nullptr;
    #####:  981:  if (regex != nullptr) {
    %%%%%:  981-block  0
    #####:  982:    pattern_ = posix::StrDup(regex);
    %%%%%:  982-block  0
        -:  983:  }
        -:  984:
    #####:  985:  is_valid_ = ValidateRegex(regex);
    %%%%%:  985-block  0
    #####:  986:  if (!is_valid_) {
        -:  987:    // No need to calculate the full pattern when the regex is invalid.
    #####:  988:    return;
    %%%%%:  988-block  0
        -:  989:  }
        -:  990:
    #####:  991:  const size_t len = strlen(regex);
        -:  992:  // Reserves enough bytes to hold the regular expression used for a
        -:  993:  // full match: we need space to prepend a '^', append a '$', and
        -:  994:  // terminate the string with '\0'.
    #####:  995:  char* buffer = static_cast<char*>(malloc(len + 3));
    #####:  996:  full_pattern_ = buffer;
        -:  997:
    #####:  998:  if (*regex != '^')
    %%%%%:  998-block  0
    #####:  999:    *buffer++ = '^';  // Makes sure full_pattern_ starts with '^'.
    %%%%%:  999-block  0
        -: 1000:
        -: 1001:  // We don't use snprintf or strncpy, as they trigger a warning when
        -: 1002:  // compiled with VC++ 8.0.
    #####: 1003:  memcpy(buffer, regex, len);
    #####: 1004:  buffer += len;
        -: 1005:
    #####: 1006:  if (len == 0 || regex[len - 1] != '$')
    %%%%%: 1006-block  0
    %%%%%: 1006-block  1
    #####: 1007:    *buffer++ = '$';  // Makes sure full_pattern_ ends with '$'.
    %%%%%: 1007-block  0
        -: 1008:
    #####: 1009:  *buffer = '\0';
    %%%%%: 1009-block  0
        -: 1010:}
        -: 1011:
        -: 1012:#endif  // GTEST_USES_POSIX_RE
        -: 1013:
        -: 1014:const char kUnknownFile[] = "unknown file";
        -: 1015:
        -: 1016:// Formats a source file path and a line number as they would appear
        -: 1017:// in an error message from the compiler used to compile this code.
    #####: 1018:GTEST_API_ ::std::string FormatFileLocation(const char* file, int line) {
    #####: 1019:  const std::string file_name(file == nullptr ? kUnknownFile : file);
    %%%%%: 1019-block  0
    %%%%%: 1019-block  1
    %%%%%: 1019-block  2
    %%%%%: 1019-block  3
    %%%%%: 1019-block  4
    $$$$$: 1019-block  5
    $$$$$: 1019-block  6
        -: 1020:
    #####: 1021:  if (line < 0) {
    #####: 1022:    return file_name + ":";
    %%%%%: 1022-block  0
    %%%%%: 1022-block  1
        -: 1023:  }
        -: 1024:#ifdef _MSC_VER
        -: 1025:  return file_name + "(" + StreamableToString(line) + "):";
        -: 1026:#else
    #####: 1027:  return file_name + ":" + StreamableToString(line) + ":";
    %%%%%: 1027-block  0
    %%%%%: 1027-block  1
    %%%%%: 1027-block  2
    %%%%%: 1027-block  3
    %%%%%: 1027-block  4
    %%%%%: 1027-block  5
    $$$$$: 1027-block  6
    $$$$$: 1027-block  7
    $$$$$: 1027-block  8
    $$$$$: 1027-block  9
    $$$$$: 1027-block 10
    $$$$$: 1027-block 11
        -: 1028:#endif  // _MSC_VER
        -: 1029:}
        -: 1030:
        -: 1031:// Formats a file location for compiler-independent XML output.
        -: 1032:// Although this function is not platform dependent, we put it next to
        -: 1033:// FormatFileLocation in order to contrast the two functions.
        -: 1034:// Note that FormatCompilerIndependentFileLocation() does NOT append colon
        -: 1035:// to the file location it produces, unlike FormatFileLocation().
    #####: 1036:GTEST_API_ ::std::string FormatCompilerIndependentFileLocation(
        -: 1037:    const char* file, int line) {
    #####: 1038:  const std::string file_name(file == nullptr ? kUnknownFile : file);
    %%%%%: 1038-block  0
    %%%%%: 1038-block  1
    %%%%%: 1038-block  2
    %%%%%: 1038-block  3
    %%%%%: 1038-block  4
    $$$$$: 1038-block  5
    $$$$$: 1038-block  6
        -: 1039:
    #####: 1040:  if (line < 0)
    #####: 1041:    return file_name;
    %%%%%: 1041-block  0
    %%%%%: 1041-block  1
        -: 1042:  else
    #####: 1043:    return file_name + ":" + StreamableToString(line);
    %%%%%: 1043-block  0
    %%%%%: 1043-block  1
    %%%%%: 1043-block  2
    %%%%%: 1043-block  3
    %%%%%: 1043-block  4
    $$$$$: 1043-block  5
    $$$$$: 1043-block  6
    $$$$$: 1043-block  7
    $$$$$: 1043-block  8
        -: 1044:}
        -: 1045:
    #####: 1046:GTestLog::GTestLog(GTestLogSeverity severity, const char* file, int line)
    #####: 1047:    : severity_(severity) {
    #####: 1048:  const char* const marker =
    %%%%%: 1048-block  0
    %%%%%: 1048-block  1
    %%%%%: 1048-block  2
    %%%%%: 1048-block  3
    %%%%%: 1048-block  4
    %%%%%: 1048-block  5
    %%%%%: 1048-block  6
    %%%%%: 1048-block  7
    %%%%%: 1048-block  8
        -: 1049:      severity == GTEST_INFO ?    "[  INFO ]" :
        -: 1050:      severity == GTEST_WARNING ? "[WARNING]" :
        -: 1051:      severity == GTEST_ERROR ?   "[ ERROR ]" : "[ FATAL ]";
    #####: 1052:  GetStream() << ::std::endl << marker << " "
    %%%%%: 1052-block  0
    #####: 1053:              << FormatFileLocation(file, line).c_str() << ": ";
    %%%%%: 1053-block  0
    %%%%%: 1053-block  1
    $$$$$: 1053-block  2
    #####: 1054:}
        -: 1055:
        -: 1056:// Flushes the buffers and, if severity is GTEST_FATAL, aborts the program.
    #####: 1057:GTestLog::~GTestLog() {
    #####: 1058:  GetStream() << ::std::endl;
    %%%%%: 1058-block  0
    #####: 1059:  if (severity_ == GTEST_FATAL) {
    #####: 1060:    fflush(stderr);
    %%%%%: 1060-block  0
    #####: 1061:    posix::Abort();
        -: 1062:  }
    #####: 1063:}
        -: 1064:
        -: 1065:// Disable Microsoft deprecation warnings for POSIX functions called from
        -: 1066:// this class (creat, dup, dup2, and close)
        -: 1067:GTEST_DISABLE_MSC_DEPRECATED_PUSH_()
        -: 1068:
        -: 1069:#if GTEST_HAS_STREAM_REDIRECTION
        -: 1070:
        -: 1071:// Object that captures an output stream (stdout/stderr).
        -: 1072:class CapturedStream {
        -: 1073: public:
        -: 1074:  // The ctor redirects the stream to a temporary file.
    #####: 1075:  explicit CapturedStream(int fd) : fd_(fd), uncaptured_fd_(dup(fd)) {
    %%%%%: 1075-block  0
    $$$$$: 1075-block  1
        -: 1076:# if GTEST_OS_WINDOWS
    #####: 1077:    char temp_dir_path[MAX_PATH + 1] = { '\0' };  // NOLINT
    #####: 1078:    char temp_file_path[MAX_PATH + 1] = { '\0' };  // NOLINT
        -: 1079:
    #####: 1080:    ::GetTempPathA(sizeof(temp_dir_path), temp_dir_path);
    #####: 1081:    const UINT success = ::GetTempFileNameA(temp_dir_path,
    %%%%%: 1081-block  0
        -: 1082:                                            "gtest_redir",
        -: 1083:                                            0,  // Generate unique file name.
        -: 1084:                                            temp_file_path);
    #####: 1085:    GTEST_CHECK_(success != 0)
    %%%%%: 1085-block  0
    %%%%%: 1085-block  1
    %%%%%: 1085-block  2
    %%%%%: 1085-block  3
    $$$$$: 1085-block  4
    $$$$$: 1085-block  5
    #####: 1086:        << "Unable to create a temporary file in " << temp_dir_path;
    %%%%%: 1086-block  0
    %%%%%: 1086-block  1
    #####: 1087:    const int captured_fd = creat(temp_file_path, _S_IREAD | _S_IWRITE);
    %%%%%: 1087-block  0
    #####: 1088:    GTEST_CHECK_(captured_fd != -1) << "Unable to open temporary file "
    %%%%%: 1088-block  0
    %%%%%: 1088-block  1
    %%%%%: 1088-block  2
    %%%%%: 1088-block  3
    $$$$$: 1088-block  4
    $$$$$: 1088-block  5
    #####: 1089:                                    << temp_file_path;
    %%%%%: 1089-block  0
    %%%%%: 1089-block  1
    #####: 1090:    filename_ = temp_file_path;
    %%%%%: 1090-block  0
        -: 1091:# else
        -: 1092:    // There's no guarantee that a test has write access to the current
        -: 1093:    // directory, so we create the temporary file in the /tmp directory
        -: 1094:    // instead. We use /tmp on most systems, and /sdcard on Android.
        -: 1095:    // That's because Android doesn't have /tmp.
        -: 1096:#  if GTEST_OS_LINUX_ANDROID
        -: 1097:    // Note: Android applications are expected to call the framework's
        -: 1098:    // Context.getExternalStorageDirectory() method through JNI to get
        -: 1099:    // the location of the world-writable SD Card directory. However,
        -: 1100:    // this requires a Context handle, which cannot be retrieved
        -: 1101:    // globally from native code. Doing so also precludes running the
        -: 1102:    // code as part of a regular standalone executable, which doesn't
        -: 1103:    // run in a Dalvik process (e.g. when running it through 'adb shell').
        -: 1104:    //
        -: 1105:    // The location /sdcard is directly accessible from native code
        -: 1106:    // and is the only location (unofficially) supported by the Android
        -: 1107:    // team. It's generally a symlink to the real SD Card mount point
        -: 1108:    // which can be /mnt/sdcard, /mnt/sdcard0, /system/media/sdcard, or
        -: 1109:    // other OEM-customized locations. Never rely on these, and always
        -: 1110:    // use /sdcard.
        -: 1111:    char name_template[] = "/sdcard/gtest_captured_stream.XXXXXX";
        -: 1112:#  else
        -: 1113:    char name_template[] = "/tmp/captured_stream.XXXXXX";
        -: 1114:#  endif  // GTEST_OS_LINUX_ANDROID
        -: 1115:    const int captured_fd = mkstemp(name_template);
        -: 1116:    if (captured_fd == -1) {
        -: 1117:      GTEST_LOG_(WARNING)
        -: 1118:          << "Failed to create tmp file " << name_template
        -: 1119:          << " for test; does the test have access to the /tmp directory?";
        -: 1120:    }
        -: 1121:    filename_ = name_template;
        -: 1122:# endif  // GTEST_OS_WINDOWS
    #####: 1123:    fflush(nullptr);
    %%%%%: 1123-block  0
    #####: 1124:    dup2(captured_fd, fd_);
    %%%%%: 1124-block  0
    #####: 1125:    close(captured_fd);
    %%%%%: 1125-block  0
    #####: 1126:  }
    %%%%%: 1126-block  0
        -: 1127:
    #####: 1128:  ~CapturedStream() {
    #####: 1129:    remove(filename_.c_str());
    %%%%%: 1129-block  0
    #####: 1130:  }
        -: 1131:
    #####: 1132:  std::string GetCapturedString() {
    #####: 1133:    if (uncaptured_fd_ != -1) {
    %%%%%: 1133-block  0
        -: 1134:      // Restores the original stream.
    #####: 1135:      fflush(nullptr);
    %%%%%: 1135-block  0
    #####: 1136:      dup2(uncaptured_fd_, fd_);
    #####: 1137:      close(uncaptured_fd_);
    #####: 1138:      uncaptured_fd_ = -1;
        -: 1139:    }
        -: 1140:
    #####: 1141:    FILE* const file = posix::FOpen(filename_.c_str(), "r");
    %%%%%: 1141-block  0
    #####: 1142:    if (file == nullptr) {
    #####: 1143:      GTEST_LOG_(FATAL) << "Failed to open tmp file " << filename_
    %%%%%: 1143-block  0
    %%%%%: 1143-block  1
    $$$$$: 1143-block  2
    $$$$$: 1143-block  3
    #####: 1144:                        << " for capturing stream.";
    %%%%%: 1144-block  0
    %%%%%: 1144-block  1
        -: 1145:    }
    #####: 1146:    const std::string content = ReadEntireFile(file);
    %%%%%: 1146-block  0
    #####: 1147:    posix::FClose(file);
    #####: 1148:    return content;
    %%%%%: 1148-block  0
    %%%%%: 1148-block  1
        -: 1149:  }
        -: 1150:
        -: 1151: private:
        -: 1152:  const int fd_;  // A stream to capture.
        -: 1153:  int uncaptured_fd_;
        -: 1154:  // Name of the temporary file holding the stderr output.
        -: 1155:  ::std::string filename_;
        -: 1156:
        -: 1157:  GTEST_DISALLOW_COPY_AND_ASSIGN_(CapturedStream);
        -: 1158:};
        -: 1159:
        -: 1160:GTEST_DISABLE_MSC_DEPRECATED_POP_()
        -: 1161:
        -: 1162:static CapturedStream* g_captured_stderr = nullptr;
        -: 1163:static CapturedStream* g_captured_stdout = nullptr;
        -: 1164:
        -: 1165:// Starts capturing an output stream (stdout/stderr).
    #####: 1166:static void CaptureStream(int fd, const char* stream_name,
        -: 1167:                          CapturedStream** stream) {
    #####: 1168:  if (*stream != nullptr) {
    %%%%%: 1168-block  0
    #####: 1169:    GTEST_LOG_(FATAL) << "Only one " << stream_name
    %%%%%: 1169-block  0
    %%%%%: 1169-block  1
    $$$$$: 1169-block  2
    $$$$$: 1169-block  3
    #####: 1170:                      << " capturer can exist at a time.";
    %%%%%: 1170-block  0
    %%%%%: 1170-block  1
        -: 1171:  }
    #####: 1172:  *stream = new CapturedStream(fd);
    %%%%%: 1172-block  0
    $$$$$: 1172-block  1
    #####: 1173:}
    %%%%%: 1173-block  0
        -: 1174:
        -: 1175:// Stops capturing the output stream and returns the captured string.
    #####: 1176:static std::string GetCapturedStream(CapturedStream** captured_stream) {
    #####: 1177:  const std::string content = (*captured_stream)->GetCapturedString();
    %%%%%: 1177-block  0
        -: 1178:
    #####: 1179:  delete *captured_stream;
    %%%%%: 1179-block  0
    #####: 1180:  *captured_stream = nullptr;
        -: 1181:
    #####: 1182:  return content;
    %%%%%: 1182-block  0
        -: 1183:}
        -: 1184:
        -: 1185:// Starts capturing stdout.
    #####: 1186:void CaptureStdout() {
    #####: 1187:  CaptureStream(kStdOutFileno, "stdout", &g_captured_stdout);
    %%%%%: 1187-block  0
    #####: 1188:}
        -: 1189:
        -: 1190:// Starts capturing stderr.
    #####: 1191:void CaptureStderr() {
    #####: 1192:  CaptureStream(kStdErrFileno, "stderr", &g_captured_stderr);
    %%%%%: 1192-block  0
    #####: 1193:}
        -: 1194:
        -: 1195:// Stops capturing stdout and returns the captured string.
    #####: 1196:std::string GetCapturedStdout() {
    #####: 1197:  return GetCapturedStream(&g_captured_stdout);
    %%%%%: 1197-block  0
        -: 1198:}
        -: 1199:
        -: 1200:// Stops capturing stderr and returns the captured string.
    #####: 1201:std::string GetCapturedStderr() {
    #####: 1202:  return GetCapturedStream(&g_captured_stderr);
    %%%%%: 1202-block  0
        -: 1203:}
        -: 1204:
        -: 1205:#endif  // GTEST_HAS_STREAM_REDIRECTION
        -: 1206:
        -: 1207:
        -: 1208:
        -: 1209:
        -: 1210:
    #####: 1211:size_t GetFileSize(FILE* file) {
    #####: 1212:  fseek(file, 0, SEEK_END);
    %%%%%: 1212-block  0
    #####: 1213:  return static_cast<size_t>(ftell(file));
        -: 1214:}
        -: 1215:
    #####: 1216:std::string ReadEntireFile(FILE* file) {
    #####: 1217:  const size_t file_size = GetFileSize(file);
    %%%%%: 1217-block  0
    #####: 1218:  char* const buffer = new char[file_size];
        -: 1219:
    #####: 1220:  size_t bytes_last_read = 0;  // # of bytes read in the last fread()
    #####: 1221:  size_t bytes_read = 0;       // # of bytes read so far
        -: 1222:
    #####: 1223:  fseek(file, 0, SEEK_SET);
        -: 1224:
        -: 1225:  // Keeps reading the file until we cannot read further or the
        -: 1226:  // pre-determined file size is reached.
    #####: 1227:  do {
    %%%%%: 1227-block  0
    #####: 1228:    bytes_last_read = fread(buffer+bytes_read, 1, file_size-bytes_read, file);
    %%%%%: 1228-block  0
    #####: 1229:    bytes_read += bytes_last_read;
    #####: 1230:  } while (bytes_last_read > 0 && bytes_read < file_size);
    %%%%%: 1230-block  0
        -: 1231:
    #####: 1232:  const std::string content(buffer, bytes_read);
    %%%%%: 1232-block  0
    #####: 1233:  delete[] buffer;
    %%%%%: 1233-block  0
        -: 1234:
    #####: 1235:  return content;
    %%%%%: 1235-block  0
    %%%%%: 1235-block  1
        -: 1236:}
        -: 1237:
        -: 1238:#if GTEST_HAS_DEATH_TEST
        -: 1239:static const std::vector<std::string>* g_injected_test_argvs =
        -: 1240:    nullptr;  // Owned.
        -: 1241:
    #####: 1242:std::vector<std::string> GetInjectableArgvs() {
    #####: 1243:  if (g_injected_test_argvs != nullptr) {
    %%%%%: 1243-block  0
    #####: 1244:    return *g_injected_test_argvs;
    %%%%%: 1244-block  0
        -: 1245:  }
    #####: 1246:  return GetArgvs();
    %%%%%: 1246-block  0
        -: 1247:}
        -: 1248:
    #####: 1249:void SetInjectableArgvs(const std::vector<std::string>* new_argvs) {
    #####: 1250:  if (g_injected_test_argvs != new_argvs) delete g_injected_test_argvs;
    %%%%%: 1250-block  0
    %%%%%: 1250-block  1
    %%%%%: 1250-block  2
    #####: 1251:  g_injected_test_argvs = new_argvs;
    #####: 1252:}
        -: 1253:
    #####: 1254:void SetInjectableArgvs(const std::vector<std::string>& new_argvs) {
    #####: 1255:  SetInjectableArgvs(
    %%%%%: 1255-block  0
    $$$$$: 1255-block  1
    $$$$$: 1255-block  2
    #####: 1256:      new std::vector<std::string>(new_argvs.begin(), new_argvs.end()));
    %%%%%: 1256-block  0
    %%%%%: 1256-block  1
    $$$$$: 1256-block  2
    $$$$$: 1256-block  3
    #####: 1257:}
        -: 1258:
    #####: 1259:void ClearInjectableArgvs() {
    #####: 1260:  delete g_injected_test_argvs;
    %%%%%: 1260-block  0
    %%%%%: 1260-block  1
    #####: 1261:  g_injected_test_argvs = nullptr;
    #####: 1262:}
        -: 1263:#endif  // GTEST_HAS_DEATH_TEST
        -: 1264:
        -: 1265:#if GTEST_OS_WINDOWS_MOBILE
        -: 1266:namespace posix {
        -: 1267:void Abort() {
        -: 1268:  DebugBreak();
        -: 1269:  TerminateProcess(GetCurrentProcess(), 1);
        -: 1270:}
        -: 1271:}  // namespace posix
        -: 1272:#endif  // GTEST_OS_WINDOWS_MOBILE
        -: 1273:
        -: 1274:// Returns the name of the environment variable corresponding to the
        -: 1275:// given flag.  For example, FlagToEnvVar("foo") will return
        -: 1276:// "GTEST_FOO" in the open-source version.
       18: 1277:static std::string FlagToEnvVar(const char* flag) {
        -: 1278:  const std::string full_flag =
       36: 1279:      (Message() << GTEST_FLAG_PREFIX_ << flag).GetString();
       18: 1279-block  0
       18: 1279-block  1
       18: 1279-block  2
       18: 1279-block  3
    $$$$$: 1279-block  4
    $$$$$: 1279-block  5
        -: 1280:
       36: 1281:  Message env_var;
       18: 1281-block  0
    $$$$$: 1281-block  1
      364: 1282:  for (size_t i = 0; i != full_flag.length(); i++) {
       18: 1282-block  0
      364: 1282-block  1
      346: 1283:    env_var << ToUpper(full_flag.c_str()[i]);
      346: 1283-block  0
      346: 1283-block  1
    $$$$$: 1283-block  2
        -: 1284:  }
        -: 1285:
       36: 1286:  return env_var.GetString();
       18: 1286-block  0
       18: 1286-block  1
       18: 1286-block  2
        -: 1287:}
        -: 1288:
        -: 1289:// Parses 'str' for a 32-bit signed integer.  If successful, writes
        -: 1290:// the result to *value and returns true; otherwise leaves *value
        -: 1291:// unchanged and returns false.
    #####: 1292:bool ParseInt32(const Message& src_text, const char* str, Int32* value) {
        -: 1293:  // Parses the environment variable as a decimal integer.
    #####: 1294:  char* end = nullptr;
    #####: 1295:  const long long_value = strtol(str, &end, 10);  // NOLINT
    %%%%%: 1295-block  0
        -: 1296:
        -: 1297:  // Has strtol() consumed all characters in the string?
    #####: 1298:  if (*end != '\0') {
        -: 1299:    // No - an invalid character was encountered.
    #####: 1300:    Message msg;
    %%%%%: 1300-block  0
    $$$$$: 1300-block  1
    #####: 1301:    msg << "WARNING: " << src_text
    %%%%%: 1301-block  0
    %%%%%: 1301-block  1
    #####: 1302:        << " is expected to be a 32-bit integer, but actually"
    %%%%%: 1302-block  0
    #####: 1303:        << " has value \"" << str << "\".\n";
    %%%%%: 1303-block  0
    %%%%%: 1303-block  1
    %%%%%: 1303-block  2
    #####: 1304:    printf("%s", msg.GetString().c_str());
    %%%%%: 1304-block  0
    %%%%%: 1304-block  1
    %%%%%: 1304-block  2
    $$$$$: 1304-block  3
    $$$$$: 1304-block  4
    #####: 1305:    fflush(stdout);
    %%%%%: 1305-block  0
    #####: 1306:    return false;
    %%%%%: 1306-block  0
        -: 1307:  }
        -: 1308:
        -: 1309:  // Is the parsed value in the range of an Int32?
    #####: 1310:  const Int32 result = static_cast<Int32>(long_value);
    #####: 1311:  if (long_value == LONG_MAX || long_value == LONG_MIN ||
    %%%%%: 1311-block  0
    %%%%%: 1311-block  1
    %%%%%: 1311-block  2
        -: 1312:      // The parsed value overflows as a long.  (strtol() returns
        -: 1313:      // LONG_MAX or LONG_MIN when the input overflows.)
        -: 1314:      result != long_value
        -: 1315:      // The parsed value overflows as an Int32.
        -: 1316:      ) {
    #####: 1317:    Message msg;
    %%%%%: 1317-block  0
    $$$$$: 1317-block  1
    #####: 1318:    msg << "WARNING: " << src_text
    %%%%%: 1318-block  0
    %%%%%: 1318-block  1
    #####: 1319:        << " is expected to be a 32-bit integer, but actually"
    %%%%%: 1319-block  0
    #####: 1320:        << " has value " << str << ", which overflows.\n";
    %%%%%: 1320-block  0
    %%%%%: 1320-block  1
    %%%%%: 1320-block  2
    #####: 1321:    printf("%s", msg.GetString().c_str());
    %%%%%: 1321-block  0
    %%%%%: 1321-block  1
    %%%%%: 1321-block  2
    $$$$$: 1321-block  3
    $$$$$: 1321-block  4
    #####: 1322:    fflush(stdout);
    %%%%%: 1322-block  0
    #####: 1323:    return false;
    %%%%%: 1323-block  0
        -: 1324:  }
        -: 1325:
    #####: 1326:  *value = result;
    #####: 1327:  return true;
    %%%%%: 1327-block  0
        -: 1328:}
        -: 1329:
        -: 1330:// Reads and returns the Boolean environment variable corresponding to
        -: 1331:// the given flag; if it's not set, returns default_value.
        -: 1332://
        -: 1333:// The value is considered true if it's not "0".
        9: 1334:bool BoolFromGTestEnv(const char* flag, bool default_value) {
        -: 1335:#if defined(GTEST_GET_BOOL_FROM_ENV_)
        -: 1336:  return GTEST_GET_BOOL_FROM_ENV_(flag, default_value);
        -: 1337:#else
        9: 1338:  const std::string env_var = FlagToEnvVar(flag);
        9: 1338-block  0
        9: 1339:  const char* const string_value = posix::GetEnv(env_var.c_str());
        9: 1339-block  0
       9*: 1340:  return string_value == nullptr ? default_value
        9: 1340-block  0
      18*: 1341:                                 : strcmp(string_value, "0") != 0;
    %%%%%: 1341-block  0
        9: 1341-block  1
        9: 1341-block  2
        -: 1342:#endif  // defined(GTEST_GET_BOOL_FROM_ENV_)
        -: 1343:}
        -: 1344:
        -: 1345:// Reads and returns a 32-bit integer stored in the environment
        -: 1346:// variable corresponding to the given flag; if it isn't set or
        -: 1347:// doesn't represent a valid 32-bit integer, returns default_value.
        3: 1348:Int32 Int32FromGTestEnv(const char* flag, Int32 default_value) {
        -: 1349:#if defined(GTEST_GET_INT32_FROM_ENV_)
        -: 1350:  return GTEST_GET_INT32_FROM_ENV_(flag, default_value);
        -: 1351:#else
        6: 1352:  const std::string env_var = FlagToEnvVar(flag);
        3: 1352-block  0
        3: 1352-block  1
    $$$$$: 1352-block  2
        3: 1353:  const char* const string_value = posix::GetEnv(env_var.c_str());
        3: 1353-block  0
        3: 1354:  if (string_value == nullptr) {
        -: 1355:    // The environment variable is not set.
        3: 1356:    return default_value;
        3: 1356-block  0
        -: 1357:  }
        -: 1358:
    #####: 1359:  Int32 result = default_value;
    #####: 1360:  if (!ParseInt32(Message() << "Environment variable " << env_var,
    %%%%%: 1360-block  0
    %%%%%: 1360-block  1
    %%%%%: 1360-block  2
    %%%%%: 1360-block  3
    %%%%%: 1360-block  4
    $$$$$: 1360-block  5
    $$$$$: 1360-block  6
        -: 1361:                  string_value, &result)) {
    #####: 1362:    printf("The default value %s is used.\n",
    %%%%%: 1362-block  0
    #####: 1363:           (Message() << default_value).GetString().c_str());
    %%%%%: 1363-block  0
    %%%%%: 1363-block  1
    %%%%%: 1363-block  2
    %%%%%: 1363-block  3
    $$$$$: 1363-block  4
    $$$$$: 1363-block  5
    $$$$$: 1363-block  6
    $$$$$: 1363-block  7
    #####: 1364:    fflush(stdout);
    %%%%%: 1364-block  0
    #####: 1365:    return default_value;
    %%%%%: 1365-block  0
        -: 1366:  }
        -: 1367:
    #####: 1368:  return result;
    %%%%%: 1368-block  0
        -: 1369:#endif  // defined(GTEST_GET_INT32_FROM_ENV_)
        -: 1370:}
        -: 1371:
        -: 1372:// As a special case for the 'output' flag, if GTEST_OUTPUT is not
        -: 1373:// set, we look for XML_OUTPUT_FILE, which is set by the Bazel build
        -: 1374:// system.  The value of XML_OUTPUT_FILE is a filename without the
        -: 1375:// "xml:" prefix of GTEST_OUTPUT.
        -: 1376:// Note that this is meant to be called at the call site so it does
        -: 1377:// not check that the flag is 'output'
        -: 1378:// In essence this checks an env variable called XML_OUTPUT_FILE
        -: 1379:// and if it is set we prepend "xml:" to its value, if it not set we return ""
        1: 1380:std::string OutputFlagAlsoCheckEnvVar(){
        1: 1381:  std::string default_value_for_output_flag = "";
        1: 1381-block  0
    $$$$$: 1381-block  1
        1: 1382:  const char* xml_output_file_env = posix::GetEnv("XML_OUTPUT_FILE");
        1: 1383:  if (nullptr != xml_output_file_env) {
    #####: 1384:    default_value_for_output_flag = std::string("xml:") + xml_output_file_env;
    %%%%%: 1384-block  0
    %%%%%: 1384-block  1
    %%%%%: 1384-block  2
    $$$$$: 1384-block  3
    $$$$$: 1384-block  4
    $$$$$: 1384-block  5
    $$$$$: 1384-block  6
        -: 1385:  }
        1: 1386:  return default_value_for_output_flag;
        1: 1386-block  0
        1: 1386-block  1
        -: 1387:}
        -: 1388:
        -: 1389:// Reads and returns the string environment variable corresponding to
        -: 1390:// the given flag; if it's not set, returns default_value.
        6: 1391:const char* StringFromGTestEnv(const char* flag, const char* default_value) {
        -: 1392:#if defined(GTEST_GET_STRING_FROM_ENV_)
        -: 1393:  return GTEST_GET_STRING_FROM_ENV_(flag, default_value);
        -: 1394:#else
        6: 1395:  const std::string env_var = FlagToEnvVar(flag);
        6: 1395-block  0
        6: 1396:  const char* const value = posix::GetEnv(env_var.c_str());
        6: 1396-block  0
       12: 1397:  return value == nullptr ? default_value : value;
        5: 1397-block  0
        1: 1397-block  1
        6: 1397-block  2
        6: 1397-block  3
        -: 1398:#endif  // defined(GTEST_GET_STRING_FROM_ENV_)
        -: 1399:}
        -: 1400:
        -: 1401:}  // namespace internal
        -: 1402:}  // namespace testing
